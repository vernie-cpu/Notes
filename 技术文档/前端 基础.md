# 综合类

## 一、前端jsonp跨域方案原理

**背景：**

由于浏览器同源策略的限制，非同源下的请求，都会产生跨域问题，jsonp即是为了解决这个问题出现的一种简便解决方案。

**同源策略即：同一协议，同一域名，同一端口号。当其中一个不满足时，我们的请求即会发生跨域问题。**

**举个简单的例子：**

​	http://www.abc.com:3000到https://www.abc.com:3000的请求会出现跨域（域名、端口相同但协议不同）
​	http://www.abc.com:3000到http://www.abc.com:3001的请求会出现跨域（域名、协议相同但端口不同）
​	http://www.abc.com:3000到http://www.def.com:3000的请求会出现跨域（域名不同）



**JSONP跨域原理：**

-  **Jsonp(JSON with Padding)** 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。

- 我们注意到，script标签的src还是img标签的src，或者说link标签的href他们没有被同源策略所限制。jsonp就是使用同源策略这一“漏洞”，实现的跨域请求。

- JSONP就是利用了sscript标签的src属性发起的跨域请求，由于script标签的作用是用来执行src指定的js代码，那么我们可以跟后端协商一个函数名，后端将要返回的数据作为函数的参数，一起返回给前端，前端事先定义好该函数，这样就完成了跨域请求。



**JSONP的缺点：**

- 首先，它没有关于JSONP调用的错误处理，一旦回调函数调用失败，浏览器会以静默失败的方式处理。
- 其次，它只支持GET请求，这是由于该技术本身的特性所决定的。因此，对于一些需要对安全性有要求的跨域请求，JSONP的使用需要谨慎一点了。
- JSONP不支持用async:false的方法设置同步。



**JSONP使用举例：**

 - **跨域执行远端的服务器中的js代码**

   apache服务器中的remote.js  

   > apache静态文件路径：/var/www/html/
   >
   > 执行远端的js文件，或者回调函数等需要把资源当作脚本运行的，只能用script标签，否则将不会按照脚本去执行

   ``` js
   alert("我是远程文件");
   ```

   本地html文件jsonp.html

   ``` html
   <!DOCTYPE html>
   <html xmlns="http://www.w3.org/1999/xhtml">
   <head>
       <title> JSONP </title>
       <!--charset 解决文本乱码-->
       <script charset="UTF-8" type="text/javascript" src="http://121.4.47.229/jsonp/remote.js"></script>
   </head>
   <body>
       来了老弟
   </body>
   </html>
   ```

- **远端的js也可以调用本地的脚本函数**

  remote.js

  ``` js
  handleFunc({"result": "我在远端入参"});
  ```

  jsonp.html

  ``` html
  <!DOCTYPE html>
  <html xmlns="http://www.w3.org/1999/xhtml">
  
  <head >
      <meta charset="UTF-8">
      <title> JSONP </title>
      <script type="text/javascript">
          var handleFunc = function(data) {
          alert("本地文件被远程js调用了。远程入参：" + data.result);
          }
      </script>
      <script charset="UTF-8" type="text/javascript" src="http://121.4.47.229/jsonp/remote.js"></script>
  </head>
  <body>
  来了老弟
  </body>
  </html>
  ```

- **服务器动态的生成js代码**

  本地jsonp.html文件

  ``` html
  <!DOCTYPE html>
  <html xmlns="http://www.w3.org/1999/xhtml">
  
  <head>
      <meta charset="UTF-8">
      <title> JSONP </title>
      <script type="text/javascript">
          var flightHandler = function(data) {
            if (data.price){
               alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
            }else{
              alert(data);
            }
          }
          var url = "http://127.0.0.1:5000/jsonp?code=CA199202&callback=flightHandler";
          
          // 创建一个script标签
          var script = document.createElement('script');
          
          // 设置标签属性
          script.setAttribute('src', url);
        	script.setAttribute('charset', "UTF-8");
        	script.setAttribute('type', "text/javascript");
        
        	// 把标签添加到head中
        	document.getElementsByTagName('head')[0].appendChild(script);
      </script>
  </head>
  <body>
  来了老弟
  </body>
  </html>
  ```

  服务端文件demo.py

  > 这里使用flask快速实现一个API，返回值前端作为js代码执行

  ``` python
  import json
  
  from flask import Flask, request
  
  app = Flask(__name__)
  
  
  @app.route('/jsonp', methods=['GET'])
  def index():
      func = request.args.get('callback')
      flight_name = request.args.get('code')
  
      # 航班信息
      flight = {
          "CA199202": {
              'price': 1200,
              'tickets': 37
          },
          "SA6532K": {
              'price': 900,
              'tickets': 60
          }
      }
  
      if flight.get(flight_name):
          # 以json字符串形式返回js脚本
          return func + "(" + json.dumps(flight.get(flight_name)) + ")"
      else:
          return func + "('无航班信息')"
  
  
  if __name__ == '__main__':
      app.run()
  
  ```

- **扩展**

  > Vue前端跨域插件：[Vue-jsonp](https://www.npmjs.com/package/vue-jsonp)
  >
  > 跨域问题，前端通过jsonp方式可以解决；后端服务器也可以配置请求白名单等方式解决。



## 二、OPTIONS 请求

- 背景

  > 出于安全考虑，并不是所有域名访问后端服务都可以。在正式跨域之前，浏览器会根据需要发起一次预检(也就是option请求)，用来让服务端返回允许的方法(如get、post)，被跨域访问的Origin(来源或者域)，还有是否需要Credentials(认证信息)等。

- 简单请求

  - 简单请求条件
    - 方式只能是：GET、POST、HEAD
    - HTTP请求头限制这几种字段：Accept、Accept-Language、Content-Language、Content-Type、Last-Event-ID
    - Content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain
  - **对于简单请求，浏览器直接请求，会在请求头信息中，增加一个origin字段，来说明本次请求来自哪个源（协议+域名+端口）。服务器根据这个值，来决定是否同意该请求，服务器返回的响应会多几个头信息字段。**
    - Access-Control-Allow-Origin：该字段是必须的，* 表示接受任意域名的请求，还可以指定域名，如www.baidu.com
    - Access-Control-Allow-Credentials：该字段可选，是个布尔值，表示是否可以携带cookie。（注意：如果Access-Control-Allow-Origin字段设置*，此字段设为true无效）
    - Access-Control-Allow-Headers：该字段可选，里面可以获取Cache-Control、Content-Type、Expires等，如果想要拿到其他字段，就可以在这个字段中指定。

- 复杂请求

  - **非简单请求是对那种对服务器有特殊要求的请求，比如请求方式是PUT或者DELETE，或者Content-Type字段类型是application/json。都会在正式通信之前，增加一次HTTP请求，称之为预检。浏览器会先询问服务器，当前网页所在域名是否在服务器的许可名单之中，服务器允许之后，浏览器会发出正式的XMLHttpRequest请求，否则会报错。**
    - 与检测的请求方式就是options。
    - options 请求不会携带 cookie 和 请求参数 等信息。

 - 总结

   > options 请求就是预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。





# CSS类

##  一、 CSS选择器优先级及判定标准

### 1. 优先级分级

1. **!important**

   ```css
   .foo {
     color:red !important
   }
   ```

   !important是顶级优先级，唯一推荐使用它的场景为`忽略JS脚本设置的样式，使js设置样式无效`。对于其他场景都没有使用它的理由，`切勿滥用`

2. **style属性内联样式**

   ```html
   <span style="color: red;">内联样式</span>
   ```

3. **ID选择器**

   ```css
   #id {
     color:red
   }
   ```

4. **类选择器**

   ```css
   .foo {
     color:red
   }
   /* disabled状态的标签设置为灰色 */
   [disabled]{
     color: grey
   }
   /* 伪类选择器和类选择器同级 */
   p:hover {
     color:blue
   }
   ```

5. **标签选择器**

   ```css
   body {
     background: white
   }
   ```

6. **通配选择器，选择符和逻辑组合伪类**

   ```css
   * {
     color:red
   }
   :not() {
     color:blue
   }
   /*
   通配选择器统一指*
   
   选择符包括+，-，~，空格和||
   
   逻辑组合伪类包括:not()，:is()，:where()等，这些伪类本身并不影响CSS优先级，影响优先级的是()里的选择器
   */
   ```



### 2. 优先级计算

除开!important和style属性内联样式（因为一个是第一顶级的优先级，另一个是写在HTML标签属性上的第二顶级优先级），在CSS样式中写的选择器样式的优先级满足以下计算规则：

- 每出现一个`ID选择器`，优先级数值`+100`
- 每出现一个`class、属性（href、rel、src等） 或 伪类选择器`，优先级数值`+10`
- 每出现一个`标签选择器`，优先级数值`+1`
- 每出现一个`通配选择器，选择符和逻辑组合伪类`，优先级数值`+0`
- 继承的CSS样式优先级为0
- 若两个选择器最终优先级计算数值相等，则后渲染的选择器优先级更高（**后渲染是相对整个HTML文档的CSS样式渲染顺序来讲的，并非单个CSS文件）**



示例：

```css
/* 优先级：1+0+10 = 11

	根据给定属性的值选择元素。
  语法：[attr] [attr=value] [attr~=value] [attr|=value] [attr^=value] [attr$=value] [attr*=value] [autoplay]
	示例表示：rel属性不是nofollow的a标签样式
*/
a:not([rel=nofollow]) {
}

/* 优先级：1+10+0+10 = 21
	示例表示：body标签中，有foo类，且没有dir属性的标签样式
*/
body .foo:not([dir]){
}
body .foo:is(:hover) {
}

/* 优先级：100+10+1 = 111 */
#foo .bar p {}
```



**增加优先级的方法**

实际开发调节样式时，难免会遇到需要增加CSS选择器优先级去匹配样式的场景，很多人是采取增加CSS样式嵌套来增加优先级数值的做法，如下：

```css
/* 原优先级 */
.foo {}

/* 增加优先级 */
.father .foo {}
```

但是这种做法增加了CSS样式与HTML结构的耦合度，降低了可维护性，推荐如下做法：

```css
/* 重复选择器自身即可 */
.foo .foo {}
```



**优先级注意事项**

- **CSS选择器优先级与DOM元素的层级位置没有关系**

  ```css
  body .foo {
    color: red
  }
  html .foo {
    color:blue
  }
  ```

  这里虽然第二个选择器在第一个选择器渲染后，但有人会考虑到body是html的子元素，距离.foo元素更近，所以应该是红色。但是DOM层级距离是对CSS选择器优先级没有任何影响的，所以按照`优先级数值相等，后渲染优先`的原则，.foo元素是蓝色。

- **选择器优先级越级现象**

  ```css
  #text {
    color:red
  }
  .text {
    color:blue
  }
  ```

  ```html
  <span id="text" class="text">颜色</span>
  ```

  根据id选择器 优先级大于class选择器的原则可知应该是红色。但是如果是下面这种情况呢？

  ```css
      /*如果有256个.text组合而成的选择器*/
      .text.text.text.text...{
          color:blue
      }
  ```

  有人认为class选择器优先级数值为10，如果同时256个，那肯定比只有一个id的id选择器优先级高！

  **实际上，在过去大多浏览器确实是这样的，FireFox浏览器早年的源码表示class类名以8字节字符串存储，所能容纳的最大值为255，超过就会溢出到ID选择器区域。**

  **但是后来`除了IE浏览器`，其他浏览器都修改了策略——`再多的选择器优先级也无法超过比它更高一级的选择器`。**

  **所以这里的文字颜色依然是红色。**





## 二、position 的属性值

> CSS position属性用于指定一个元素在文档中的定位方式。top、right、bottom、left 属性则决定了该元素的最终位置。
>
> position 取值有：static、relative、absolute、fixed、sticky、inherit

然后来看看什么是文档流(normal flow)，下面是 [www.w3.org](https://www.w3.org/TR/CSS21/visuren.html#) 的描述：

> **Normal flow**
>
> Boxes in the normal flow belong to a formatting context, which may be block or inline, but not both simultaneously. [Block-level](https://www.w3.org/TR/CSS21/visuren.html#block-level) boxes participate in a [block formatting](https://www.w3.org/TR/CSS21/visuren.html#block-formatting) context. [Inline-level boxes](https://www.w3.org/TR/CSS21/visuren.html#inline-level) participate in an [inline formatting](https://www.w3.org/TR/CSS21/visuren.html#inline-formatting) context.

理解 normal flow：

1. normal flow直译为常规流、正常流，国内不知何原因大多译为文档流；
2. 窗体自上而下分成一行一行，并在每行中按从左至右的顺序排放元素；
3. 每个非浮动块级元素都独占一行， 浮动元素则按规定浮在行的一端，若当前行容不下，则另起新行再浮动；
4. 内联元素也不会独占一行，几乎所有元素(包括块级，内联和列表元素）均可生成子行，用于摆放子元素；
5. 有三种情况将使得元素脱离normal flow而存在，分别是 float，absolute ，fixed，但是在IE6中浮动元素也存在于normal flow中。



### position: static

MDN的描述：

> 该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top、right、bottom、left 属性无效。

对元素设置 position: static，可以覆盖 position其他布局行为设置。**static 是元素的默认值**，这就是元素出现在常规文档流中的原因。

```html
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>CSS-position-static</title>
 6     <link rel="stylesheet" href="https://cdn.bootcss.com/normalize/8.0.0/normalize.css">
 7     <style>
 8         .container{
 9             background-color: #868686;
10             width: 100%;
11             height: 300px;
12         }
13         .content{
14             background-color: yellow;
15             width: 100px;
16             height: 100px;
17             position: static;
18             left: 10px;/* 这个left没有起作用 */
19         }
20     </style>
21 </head>
22 <body>
23     <div class="container">
24         <div class="content">    
25         </div>
26     </div>
27 </body>
28 </html>
```

对 content 的 position 设定 static 后，left就失效了，而元素（content）就以正常的 normal flow 形式呈现。



### position: relative

MDN的描述：

> 该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。

相对于normal flow中的原位置来定位。

```html
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <meta name="viewport" content="width=device-width, initial-scale=1.0">
 6     <meta http-equiv="X-UA-Compatible" content="ie=edge">
 7     <title>CSS-position-relative</title>  
 8     <link rel="stylesheet" href="https://cdn.bootcss.com/normalize/8.0.0/normalize.css">
 9     <style>
10             .container{
11                 background-color: #868686;
12                 width: 100%;
13                 height: 300px;
14             }
15             .content_0{
16                 background-color: yellow;
17                 width: 100px;
18                 height: 100px;               
19             }
20             .content_1{
21                 background-color: red;
22                 width: 100px;
23                 height: 100px;
24                 position: relative;/* 这里使用了relative，此时没有指定偏移量，所以还是正常的出现在 normal flow*/            
25             }
26             .content_2{
27                 background-color: black;
28                 width: 100px;
29                 height: 100px;               
30             }
31         </style>
32     </head>
33     <body>
34         <div class="container">
35             <div class="content_0">    
36             </div>
37             <div class="content_1">    
38             </div>
39             <div class="content_2">    
40             </div>
41         </div>   
42 </body>
43 </html>
```

为content_1添加偏移量后，可以看到相对于自身原来的位置发生了偏移。

```html
1 .content_1{
2                 background-color: red;
3                 width: 100px;
4                 height: 100px;
5                 position: relative;/* 这里使用了relative  */
6                 left: 20px;/* 这里设置了left和top */
7                 top: 20px;            
8             }
```



### position: absolute

MDN的描述：

> 不为元素预留空间（即脱离 normal flow），通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margin），且不会与其他边距合并。

生成绝对定位的元素，其位置相对于 最近一级、 position 不是 static 定位的 父级元素 进行定位，会脱离normal flow。

**注意：是最近一层的非static的父级元素**。

```html
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <meta name="viewport" content="width=device-width, initial-scale=1.0">
 6     <meta http-equiv="X-UA-Compatible" content="ie=edge">
 7     <title>CSS-position-static</title>
 8     <link rel="stylesheet" href="https://cdn.bootcss.com/normalize/8.0.0/normalize.css">
 9     <style>
10         .container{
11             background-color: #868686;
12             width: 100%;
13             height: 300px;
14             margin-top: 50px;
15         }
16         .content{
17             background-color: red;
18             width: 100px;
19             height: 100px;
20             position: absolute;
21             top: 10px;
22         }
23     </style>
24 </head>
25 <body>
26     <div class="container">
27         <div class="content">    
28         </div>
29     </div>
30 </body>
31 </html>
```

因为 content 的父元素 container 没有设置 position，默认为 static，所以找到的第一个父元素是 body（<body></body>），可以看成是元素（content）相对于 body 向下移动10px。



### position: fixed

MDN的描述

> 不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。

fixed相对于window固定，滚动浏览器窗口并不会使其移动，会脱离normal flow。

```html
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <meta name="viewport" content="width=device-width, initial-scale=1.0">
 6     <meta http-equiv="X-UA-Compatible" content="ie=edge">
 7     <title>CSS-position-static</title>
 8     <link rel="stylesheet" href="https://cdn.bootcss.com/normalize/8.0.0/normalize.css">
 9     <style>
10         .container{
11             background-color: #868686;
12             width: 100%;
13             height: 1000px;
14         }
15         .content{
16             background-color: yellow;
17             width: 100px;
18             height: 100px;
19             position: fixed;/* 这里使用了fixed */
20         }
21     </style>
22 </head>
23 <body>
24     <div class="container">
25         <div class="content">    
26         </div>
27     </div>
28 </body>
29 </html>
```



### position: sticky

MDN的描述

> 盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table`时`），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky对 table元素的效果与 position: relative 相同。

因为各大浏览器对于sticky的兼容问题，而且JS也可以实现这个功能，在这里就不进行深入了，了解一下就好。



### position: inherit

[w3school.com](http://www.w3school.com.cn/cssref/pr_class_position.asp)的 描述：

> 规定应该从父元素继承 position 属性的值。





## 三、理解display和visibility

### display

display 控制元素的显示类型和可见性。

| 值                 | 描述                                                         |
| :----------------- | ------------------------------------------------------------ |
| none               | 此元素不会被显示。隐藏元素，将其从文档流中完全删除，不会占用文档流中的位置。 |
| block              | 此元素将显示为块级元素，此元素前后会带有换行符。             |
| inline             | 默认。此元素会被显示为内联元素，元素前后没有换行符。设置为inline的元素会忽略任何width、height、margin-top 和 margin-bottom 设置；但 padding-top 和 padding-bottom 会越界进入相邻元素的区域，而不是局限于该元素本身的空间。 |
| inline-block       | 行内块元素（CSS2.1 新增的值）。元素前后没有换行符，但此时可使 inline 忽略的空间属性生效。 |
| list-item          | 此元素会作为列表显示。<li> 标签 display 的默认值。           |
| run-in             | 此元素会根据上下文作为块级元素或内联元素显示。               |
| table              | 此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。 |
| inline-table       | 此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。 |
| table-row-group    | 此元素会作为一个或多个行的分组来显示（类似 <tbody>）。       |
| table-header-group | 此元素会作为一个或多个行的分组来显示（类似 <thead>）。       |
| table-footer-group | 此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。       |
| table-row          | 此元素会作为一个表格行显示（类似 <tr>）。                    |
| table-column-group | 此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。    |
| table-column       | 此元素会作为一个单元格列显示（类似 <col>）                   |
| table-cell         | 此元素会作为一个表格单元格显示（类似 <td> 和 <th>）          |
| table-caption      | 此元素会作为一个表格标题显示（类似 <caption>）               |
| inherit            | 规定应该从父元素继承 display 属性的值。                      |



### visibility

visibility 属性规定元素是否可见。

**提示：**即使不可见的元素也会占据页面上的空间。请使用 "display" 属性来创建不占据页面空间的不可见元素。

| 值       | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| visible  | 默认值。元素是可见的。                                       |
| hidden   | 元素是不可见的。与 display:none 的区别是，visibility:hidden 元素虽然不可见，但仍在文档流中占据位置空间。 |
| collapse | 当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 "hidden"。 |
| inherit  | 规定应该从父元素继承 visibility 属性的值。                   |



## 四、CSS中选择器的优先级关系

### 1. CSS三大特性

- **继承：**即子类元素继承父类的样式;

- **优先级：**是指不同类别样式的权重比较;

- **层叠：**是说当数量相同时，通过层叠(后者覆盖前者)的样式。



### 2. CSS选择符

1. 标签选择器(如：body,div,p,ul,li)

2. 类选择器(如：class="head",class="head_logo")
3. ID选择器(如：id="name",id="name_txt")
4. 全局选择器(如：*号)
5. 组合选择器(如：.head .head_logo,注意两选择器用空格键分开)
6. 后代选择器 (如：#head .nav ul li 从父集到子孙集的选择器)
7. 群组选择器 div,span,img {color:Red} 即具有相同样式的标签分组显示
8. 继承选择器(如：div p,注意两选择器用空格键分开)
9. 伪类选择器(如：链接样式，a元素的伪类，4种不同的状态：link、visited、active、hover。以 a:link 表示)
10. 字符串匹配的属性选择符(^ $ *三种，分别对应开始、结尾、包含)
11. 子选择器 (如：div>p ,带大于号>)
12. CSS 相邻兄弟选择器器 (如：h1+p,带加号+)



### 3. CSS 选择器的优先级关系

见 本章 第一小节：一、 CSS选择器优先级及判定标准



### 4. CSS 选择器的解析原则

郑重声明：**CSS选择器定位DOM元素是从右往左的方向，这样的好处是尽早的过滤掉一些无关的样式规则和元素 。**



### 5. 简洁、高效的CSS

所谓高效就是让浏览器查找更少的元素标签来确定匹配的style元素。

1. 不要在ID选择器前使用标签名

   解释：ID选择是唯一的，加上标签名相当于画蛇添足了，没必要。

2. 不要在类选择器前使用标签名

   解释：如果没有相同的名字出现就是没必要，但是如果存在多个相同名字的类选择器则有必要添加标签名防止混淆如：

   ```css
   p.colclass {color：red;} 
   span.colclass {color:red;}
   ```

3. 尽量少使用层级关系

   ```css
   #divclass p.colclass {color:red;}
   /* 修改为 */
   .colclass {color:red;}
   ```

4. 使用类选择器代替层级关系（如上） 





## 五、CSS隐藏元素的方式

### 1.display:none

不为被隐藏的对象保留其物理空间，即该对象在页面上彻底消失，通俗来说就是看不见也摸不到。具体表现如下：

> 1.DOM结构，浏览器不会渲染display:none的元素，不占据空间；
>  2.事件监听：无法进行DOM事件监听；
>  3.性能：动态改变此属性会引起重排，性能较差；
>  4.继承：不会被子元素继承，毕竟子类也不会渲染；
>  5.transition：transition不支持display。



### 2.visibility: hidden

使对象在网页上不可见，但该对象在网页上所占的空间没有改变，通俗来说就是看不见但摸得到。具体表现如下：

> 1.DOM结构：被渲染，但是被隐藏，会占据空间；
>  2.事件监听：无法进行DOM事件监听；
>  3.性能：动态改变此属性会引起重绘，性能较高；
>  4.继承：会被子元素继承，子元素可以通过设置visibility:visible来取消隐藏；
>  5.transition：visibility会立即显示，隐藏时会延时。



### 3.opacity: 0

与visibility: hidden相似，使对象在网页上不可见，但该对象在网页上所占的空间没有改变，但是可以进行DOM事件监听，visibility：hidden不可以，通俗来说就是看不见但是摸得着。具体表现如下：

> 1.DOM结构：透明度为100%，元素被隐藏，会占据空间；
>  2.事件监听：可以进行DOM事件监听；
>  3.性能：提升为合成层，不会引起重绘，性能较高；
>  4.继承：会被子元素继承，子元素并不能通过opacity:1来取消隐藏；
>  5.transition：opacity可以延迟显示和隐藏。



### 4.隐藏元素的其他方法

#### position

position:absolute 设置元素的position与left，top，bottom，right等，将元素移出至可视区域外，它不会影响布局，能够让元素保持可操作性，在读屏软件上可以被识别。

#### transform

transform:rotatex(90deg)或 transform:rotateY(90deg)，与opacity: 0相似，但无法进行事件监听。

#### 通过z-index隐藏







## 六、图片懒加载的原理

### 懒加载的定义

懒加载是一种设计模式，被运用在软件设计和网页设计当中，对于网页界面，其特征为用户透过鼠标，滚动浏览页面，直到页面下方时，就会自动加载更多内容。



### 懒加载的优势

1. 首先它能提升用户的体验，试想一下，如果打开页面的时候就将页面上所有的图片全部获取加载，如果图片数量较大，对于用户来说简直就是灾难，会出现卡顿现象，影响用户体验。
2. 有选择性地请求图片，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。



### 懒加载的原理

**页面在浏览器中打开，img标签的src属性会自动请求其图片地址，实现懒加载先使用自定义属性(例:data-src)来保存图片地址，避免img的自动加载。然后js监听父元素的scroll事件，当此图片出现在可视区域后，js再把自定义src设置为图片src，实现懒加载。**



示例：

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title> LazyLoad </title>
    <style>
        #xz {
            height: 20em;
            width: 30em;
            border: 1px solid black;
            overflow: auto;
        }
        #title {
            height: 40em;
            width: 30em;
        }
        #xz:is(:hover) {
            color: red
        }
    </style>
</head>
<body>
<div id="xz">
    <p id="title">
        啦啦啦我是卖报的小行家
    </p>
    <img width="200" height="150" id="img" src="#" alt="demo" data-src="./ElasticSearch/20211101155841.jpg">
</div>
<script type="text/javascript">
    var view = document.getElementById("xz");
    var img = document.getElementById("img");

    // 真实回调Handler
    function lazyLoad() {
        if (img.getAttribute("src") == "#") {
            var clientHeight = view.clientHeight;
            var scrollTop = view.scrollTop;

            // offsetTop 表示当前元素到父级元素顶部的距离
            // clientHeight 表示元素可视区域高度
            // scrollTop 表示滚动出可视区域的高度
            if (img.offsetTop < clientHeight + scrollTop){
                    img.src = img.getAttribute("data-src");  // 属性 data-src 直接通过 .data-src 调用，-将被识别成运算符
                }
        }
    }

    // 节流函数
  	// 由于是监听scroll事件，回调回被频繁触发，增加一个节流函数。
  	// 去抖相比较节流函数要稍微简单一点，去抖是让函数延迟执行，而节流比去抖多了一个在一定时间内必须要执行一次。
    function throttle(func, delay, time) {
      let timeout;
      let starttime = new Date();

      return function() {
        // 获取this对象、入参，传递给func
        let context = this;
        let args = Array.prototype.slice.call(arguments);

        let currenttime = new Date();

        // 清除延时器
        clearTimeout(timeout);

        // 判断触发时间
        if (currenttime - starttime >= time) {
          func(context, args);
          starttime = currenttime;
        } else {
          timeout = setTimeout(function() {
            func(context, args);
          }, delay);
        }
      };
    }

    // 监听事件
    view.addEventListener("scroll", throttle(lazyLoad, 1000, 3000));
</script>
</body>
</html>
```



## 七、CSS3 增加了哪些新特性

参见W3C教程：http://home.ustc.edu.cn/~xie1993/css3/css3-backgrounds.html





## 八、浮动元素引起的问题和解决办法

### 1. 父元素高度塌陷

> 如果子元素设置了浮动，而父元素没有设置高度，则父元素不会被自动撑开

**解决办法：**

1. **给父元素设置宽高属性**

   - 缺点：
     无法自适应后面添加的元素，即后面用其他方式添加的元素也会出现父元素无法自动撑开的情况。

2. **给父元素设置 overflow：hidden**

   - 缺点：
     内容增多的时候容易造成不会自动换行导致内容被隐藏掉，无法显示要溢出的元素。

3. **内墙法: 在父元素内部最后一个浮动元素的后边添加一个块元素，并给它设置清除浮动属性 clear:both**

   > clear属性，字面意思就是清除，那么both,就是清除浮动元素对我左右两边的影响。

   - 缺点：
     1. 代码冗余，如果出现多处浮动要写多个空盒子，增加了文件的大小。
     2. 使用本方法会出现设置margin值异常，空盒子两边的margin会被无效化。

4. **用伪元素的方式给父元素后面添加一个元素并设置清除属性 clear:both**

   > 内墙法是在浮动元素的后面加一个空的 块级元素 (通常是div),并且该元素设置 clear:both； 属性。
   >
   > 那么正好在css3的属性用法中整好有个选择器也完全符合这个用法，伪元素选择器。它就像伪类一样，让伪元素添加了选择器，但不是描述特殊的状态，允许为元素的 某些部分设置样式 。
   >
   > ```css
   > p::after {
   >   /* P::after{} 一定要有 content。表示在p元素内部的最后添加内容 */
   >   content: "...";
   > }
   > ```
   >
   > 表示在p标签元素的最后面添加样式，同时这也正好符合内墙法的用法。

   伪元素注意事项：

   - 这些伪元素 要配合content属性一起使用
   - 这些伪元素 不会出现在DOM中，所以不能通过js来操作，仅仅是在 CSS 渲染层加入
   - 这些伪元素 的特效通常要使用:hover伪类样式来激活

   

   示例：

   ```html
   <!DOCTYPE html>
   <html>
   <head>
       <meta charset="UTF-8">
       <title> LazyLoad </title>
       <style>
           #xz {
               border: 1px solid black;
           }
           #title {
               height: 20em;
               width: 15em;
               float: left;
           }
           #xz:is(:hover) {
               color: red
           }
           .clearfix:after {
               content: '';  # 在父元素的最后添加一个空字符
               display: block; # 内墙法要求元素是块级，因为 行内元素会忽略掉 margin、padding 等属性。
               clear: both; # 清除浮动元素的影响，关键所在。
           }
       </style>
   </head>
   <body>
   <div id="xz" class="clearfix">
       <p id="title">
           啦啦啦我是卖报的小行家
       </p>
   </div>
   <script type="text/javascript">
   </script>
   </body>
   </html>
   ```

   

### 2. 同一行内的元素浮动属性导致布局问题

> 同一行内的多个元素，要么都设置浮动，要么都不设置。否则会导致布局错乱。

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title> LazyLoad </title>
    <style>
        .blue {
          	<-- float: left; -->
            height: 10em;
            width: 10em;
            background: blue;
        }
        .green {
            float: left;
            height: 10em;
            width: 10em;
            background: green;
        }
    </style>
</head>
<body>
<div style="height: 10em; width: 50em; border: 2px solid black;">
    <span class="blue">blue</span><span class="green">green</span>
</div>
</body>
</html>
```



## 九、CSS3中Flex Box的作用及应用场景

CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。

引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。



### CSS3 弹性盒子内容

弹性盒子由弹性容器(Flex container)和弹性子元素(Flex item)组成。

弹性容器通过设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器。

弹性容器内包含了一个或多个弹性子元素。

**注意：** 

- 弹性容器外及弹性子元素内是正常渲染的。弹性盒子只定义了弹性子元素如何在弹性容器内布局。

- 弹性子元素通常在弹性盒子内一行显示。默认情况每个容器只有一行。

**示例：**

```html
<!DOCTYPE html>
<html>
<head>
<style>
.flex-container {
    <!-- -webkit-/-moz- 前缀表示特定浏览器前缀，-webkit-指Opera或Chrome或Safari，-moz- 指firefox -->
    display: -webkit-flex;
    display: flex;
    width: 400px;
    height: 250px;
    background-color: lightgrey;
}

.flex-item {
    background-color: cornflowerblue;
    width: 100px;
    height: 100px;
    margin: 10px;
}
</style>
</head>
<body>

<div class="flex-container">
  <div class="flex-item">flex item 1</div>
  <div class="flex-item">flex item 2</div>
  <div class="flex-item">flex item 3</div>
</div>

</body>
</html>
```

如果我们设置`body`的 `direction` 属性为 `rtl` (right-to-left),弹性子元素的排列方式也会改变，页面布局也跟着改变:

```css
body {
    direction: rtl;
}
 
.flex-container {
    display: -webkit-flex;
    display: flex;
    width: 400px;
    height: 250px;
    background-color: lightgrey;
}
 
.flex-item {
    background-color: cornflowerblue;
    width: 100px;
    height: 100px;
    margin: 10px;
}
```



### CSS3 弹性盒子属性

下表列出了在弹性盒子中常用到的属性:

教程：https://www.runoob.com/css3/css3-flexbox.html

| 属性                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [display](https://www.runoob.com/cssref/pr-class-display.html) | 指定 HTML 元素盒子类型。                                     |
| [flex-direction](https://www.runoob.com/cssref/css3-pr-flex-direction.html) | 指定了弹性容器中子元素的排列方式                             |
| [justify-content](https://www.runoob.com/cssref/css3-pr-justify-content.html) | 设置弹性盒子元素在主轴（横轴）方向上的对齐方式。             |
| [align-items](https://www.runoob.com/cssref/css3-pr-align-items.html) | 设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式。             |
| [flex-wrap](https://www.runoob.com/cssref/css3-pr-flex-wrap.html) | 设置弹性盒子的子元素超出父容器时是否换行。                   |
| [align-content](https://www.runoob.com/cssref/css3-pr-align-content.html) | 修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐 |
| [flex-flow](https://www.runoob.com/cssref/css3-pr-flex-flow.html) | flex-direction 和 flex-wrap 的简写                           |
| [order](https://www.runoob.com/cssref/css3-pr-order.html)    | 设置弹性盒子的子元素排列顺序。                               |
| [align-self](https://www.runoob.com/cssref/css3-pr-align-self.html) | 在弹性子元素上使用。覆盖容器的 align-items 属性。            |
| [flex](https://www.runoob.com/cssref/css3-pr-flex.html)      | 设置弹性盒子的子元素如何分配空间。                           |





## 十、用伪类实现一个上三角

### **实心三角**

```html
<!DOCTYPE html>
<html>
<head>
    <style type="text/css">
  .turn_left,.turn_top {
    height: 100px;
    width: 150px;
    border-radius: 10px;
    background-color: grey;
    position: relative;
    float: left;
    margin: 50px 50px;
  }

  .turn_left:before {
    content: "";
    width: 0px;
    height: 0px;
    border-top: 10px solid transparent;
    border-bottom: 10px solid transparent;
    border-right: 10px solid red;
    position: absolute;
    top: 40px;
    left: -10px;
  }

  .turn_top:before {
    content: "";
    width: 0px;
    height: 0px;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-bottom: 10px solid red;
    position: absolute;
    top: -10px;
    left: 65px;
  }
    </style>
</head>
<body>
<div>
    <div class="turn_left"></div>
    <div class="turn_top"></div>
</div>
</body>
</html>
```



### **空心三角**

> 本质就是在实心三角的基础上，再做一个小 1px 的白色三角覆盖住实心三角。

```html
<!DOCTYPE html>
<html>
<head>
    <style type="text/css">
  .turn_top {
    height: 100px;
    width: 150px;
    border-radius: 10px;
    border: 1px solid #000000;
    position: relative;
    float: left;
    margin: 50px 50px;
  }

  .turn_top:before {
    content: "";
    width: 0px;
    height: 0px;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-bottom: 10px solid black;
    position: absolute;
    top: -10px;
    left: 65px;
  }
  .turn_top:after {
    content: "";
    width: 0px;
    height: 0px;
    border-left: 9px solid transparent;
    border-right: 9px solid transparent;
    border-bottom: 9px solid white;
    position: absolute;
    top: -9px;
    left: 66px;
  }
    </style>
</head>
<body>
<div>
    <div class="turn_top"></div>
</div>
</body>
</html>
```



### 总结

​		**三角形往哪个方向，那个方向无需设置border，而相反方向设置border颜色，相邻两边的border设为透明。**这样就可实现各个方向的三角形。实心三角形利用CSS中的伪元素（：before）实现，再利用border的transparent属性即可达到效果。而空心三角形是在空心三角形的基础上再加上伪元素（：after）实现。伪元素（：before）实现的是一个实心的三角形，伪元素（：after）实现的是空心的三角形，进而把实心的三角形覆盖，利用绝对定位的top与left的差值绝对了三角形线的粗细而达到如图的效果。





# JS类

## 一、怎么判断两个对象相等

> 两个Object类型对象，即使拥有相同属性、相同值，当使用 == 或 === 进行比较时，也不认为他们相等。这是因为他们是通过 **引用 **比较的，不像基本类型是通过 值 比较的。
>
> 所谓 引用，就是 对象 保存在内存中的地址。我们的变量就是指向这个内存地址的，当我们使用这个变量时，就是通过 变量 找到对象在内存中暴怒的地址，然后再通过内存地址取出 对象 做运算。
>
> 所以，当两个 对象 比较时，实际上就比较的是 内存中的地址，即便两个对象拥有 相同属性、相同值，内存地址也是不一样的，所以判定结果为 false。当两个变量指向同一对象时，此时两个对象比较是相等的，因为 内存地址 是一样的。

**实现对象比较方法**

```js
function deepCompareObject(x, y) {
  // 判断入参是不是都是对象
  if (typeof x !== "object" || typeof y !== "object"){
    throw new TypeError("type is required that parameter is instance of Object!");
  }

  // 指向同一对象时，返回true
  if (x === y) {
    return true
  }

  // 判断x、y的属性数量
  if (Object.keys(x).length != Object.keys(y).length) {
    return false
  }

  // 取出对象x中的所有属性的值，依次和y中的值比较
  for (let prop in x) {
    if (y.hasOwnProperty(prop)) {
      if (typeof x[prop] === "object") {
        if (typeof y[prop] !== "object" || !deepCompareObject(x[prop], y[prop])) {
          return false
        }
      }else if (x[prop] !== y[prop]){
        return false
      }
    }else{
      return false
    }
  }
  return true
};
```



## 二、数组相关的操作方法

### 创建数组

- 方法一：通过`new`运算符创建一个数组构造函数。

```js
var arr = new Array();
```

- 方法二：通过方括号直接创建直接量数组。

```js
var arr = [1,2,3];
```



### 数组赋值

- 方法一：通过下标添加元素。

```js
var arr = new Array();
arr[0] = 'kwan';
arr[1] = 18;
```

- 方法二：通过`array`的`push`方法来添加。



### 基础函数

#### 1. join()

功能：将数组中所有元素都转化为字符串并连接在一起。原数组不改变，返回拼接后的字符串

入参：传入 string 类型的链接字符

```js
    var a = ["a", "b", "c", "d", "ee"]
    var b = a.join("") // 分隔符 ""
```



#### 2.  reverse()

功能：将数组中的元素颠倒顺序。就地修改，同时也将修改后的数组返回

```js
    var a = ["a", "b", "c", "d", "ee"]
    a.reverse()
```



#### 3. concat()

功能：数组拼接的功能 ，返回新数组，原数组不受影响。

```js
    var a = ["a", "b", "c", "d", "ee"]
    var b = [1, 2, 3]
    var c = a.concat(b)
```



#### 4.slice()

截取数组生成新数组，原数组不受影响。

**返回的数组包含第一个参数指定的位置，但不含第二个参数指定位置之间的所有元素。**

**如果为负数，表示相对于数组中最后一个元素的位置。例如：-1 表示数组最后一个元素；-2 表示数组倒数第二个元素。**

**如果只有一个参数，表示从参数位置开始一直取到数组末尾。**

```js
var aa = [1,2,3,4,5,6];
console.log(aa.slice(2)); //[3,4,5,6]
console.log(aa.slice(2,8)); //[3,4,5,6] 超过最大长度，只显示到最后结果
console.log(aa.slice(2,5)); //[3,4,5]
console.log(aa.slice(2,-1)); //[3,4,5] 相对于倒数第一个之前
console.log(aa.slice(2,-2)); //[3,4] 相对于倒数第二个之前
console.log(aa.slice(3)); //[4,5,6] 一个参数从第三个到最后
console.log(aa.slice(-2));//[5,6] 一个参数负值从倒数第二个到最后
```



#### 5. splice()

功能：从数组中删除元素、插入元素 或者同时完成这两种操作。

输入：第一个参数为指定插入或删除的起始位置，第二个参数为要删除的个数。之后的参数表示需要插入到数组中的元素 。如果只有一个参数，默认删除参数后边的所有元素。

输出：返回一个由删除元素组成的数组。

 注意：新建了一个数组，并修改了原数组。

```js
var aa = [1,2,3,4,5,6];
console.log(aa.splice(4)); //[5,6]  返回删除后的数组。起始位置包含在删除元素中
aa; // [1,2,3,4]
console.log(aa.splice(2,2)); //[3,4] 从第二位起删除两个元素
aa; //[1,2]
console.log(aa.splice(1,0,7,8)); //[]从第一位起删除0个元素，添加7,8到原数组。原来位置的元素往后迁移
aa;//[1,7,8,2]
```



#### 6. push()

在数组末尾添加一个或多个元素，并返回新数组长度。

```js
    var a = ["a", "b", "c", "d", "ee"]
    var count = a.push("new_one", "new_two")
    console.log(count) // 7
    console.log(a) // ["a", "b", "c", "d", "ee", "new_one", "new_two"]
```



#### 7. pop()

从数组末尾删除1个元素(删且只删除1个), 并返回 被删除的元素。



#### 8. shift()

在数组开始添加一个或多个元素，并返回新数组长度。



#### 9. unshift()

在数组开始删除一个元素(删且只删除1个),并返回 被删除的元素



#### 10. toString()和toLocaleString()

将数组的每个元素转化为字符串，并且返回用逗号分隔的字符串列表。功能类似join()。

```js
    var a = ["a", "b", "c", "d", "ee"]
    var b = a.toString()
    var c = a.toLocaleString()
    console.log(typeof b) //string
    console.log(typeof c) //string
    console.log(b) // a,b,c,d,ee
```



#### 11. indexOf()和lastIndexOf()

**indexOf: **从数组的开头（位置 0）开始向后查找。返回查找项的索引值，没找到返回-1。
**lastIndexOf:** 从数组的末尾开始向前查找。返回查找项的索引值(索引值永远是正序的索引值)，没找到返回-1。

参数：要查找的项 和（可选的）表示查找起点位置的索引。



### 高阶函数

#### 1. sort()

默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用toString()方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。所以用默认方法排序 数值 是有问题的。

sort 方法是就地排序，修改原数组。同时将修改后的原数组返回。

```js
var a = [1, 2, 5, 16, 11, 8, 10, 13]
a.sort()
console.log(a)  // [1, 10, 11, 13, 16, 2, 5, 8]

a.sort((a, b) => {
  return a-b; // 升序
})

a.sort((a, b) => {
  return b-a; // 降序
})
```



#### 2. forEach()

从头至尾遍历数组，为每个元素回调指定函数。
传入一个回调函数，回调函数时为其传入三个参数：数组元素、元素的索引、数组本身。

```js
var a = [1, 2, 5, 16]
a.forEach((item, index, array) => {
  console.log(item);
  console.log(index);
  console.log(array);
})
```



#### 3. map()

调用的数组的遍历每一个元素传递给指定的回调函数，并返回一个新数组 ，不修改原数组。

```js
var arr = [2,3,4,5,6];
var bb= arr.map(function(x){
  return x*x;
});
console.log(bb); // [4, 9, 16, 25, 36]
```



#### 4. filter()

过滤功能，数组中的每一项回调给定函数，返回满足过滤条件组成的数组。

```js
var a = [1,2,3,4,5,6,3,1];
a.filter(function(v,i,self){
  return self.indexOf(v) == i;
});
//[1, 2, 3, 4, 5, 6]
```



#### 5. every()和some()

every() 判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。
some() 判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。

```js
var arr = [1, 2, 3, 4, 5, 6];
arr.every(x=>x>0);//return true;
arr.every(x=>x>5);//return false;
arr.some(x=>x>5);//return true;
```



#### 6. reduce()和reduceRight()

reduce() 两个参数：函数和递归的初始值。从数组的第一项开始，逐个遍历到最后。
reduceRight() 从数组的最后一项开始，向前遍历到第一项。

```js
//可以用reduce快速求数组之和
var arr=[1,2,3,4];
arr.reduce(function(a,b){
  return a+b;
}); //10
```



## 三、JS中常见的DOM操作API

### DOM

D（document）O（object）M（model） 文档对象模型。

> DOM（文档对象模型）是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义一种方式可以使从程序中对该结构进行访问，从而改变文档的结构、样式和内容。DOM将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。

DOM就是一种想象的树形结构，它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。



### NODE

DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。

节点主要有7种类型：

- `Document`：整个文档树的根节点
- `Document`：doctype标签节点，如`<!DOCTYPE html>`
- `Element`：网页的各种`Html`标签，比如`<body><div>`等
- `Attribute`：网页元素的属性
- `Text`：标签之间或者标签包含的文本
- `Comment`：注释
- `DocunmentFragment`：文档的片段



**DOM树有3种层级结构：**

- 父节点关系（parentNode）：直接的上级节点
- 子节点关系(childNodes)：直接的下级节点
- 兄弟关系(sibling)：拥有同一个父节点的同级节点



### Node API

#### 属性

##### Node.prototype.nodeType

> `nodeType`属性返回一个整数值，表示节点的类型。

数值和结点类型的映射关系：

`Node.ELEMENT_NODE`：1

`Node.ATTRIBUTE_NODE`：2

`Node.TEXT_NODE`：3

`Node.COMMENT_NODE`：8

`Node.DOCUMENT_NODE`：9

`Node.DOCUMENT_TYPE_NODE`：10

`Node.DOCUMENT_FRAGMENT_NODE`：11



##### Node.prototype.nodeName

> `nodeName`属性返回节点名称

注：在元素节点中，返回名称基本都是大写，只有`<svg>`标签返回的是小写。



##### Node.prototype.nodeValue

> `nodeValue`属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。

只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的`nodeValue`可以返回结果，其他类型的节点一律返回`null`。



##### Node.prototype.textContent

> `textContent`返回节点及后代节点的文本 ，即获取文本。

这里和`innerText`一起讲：

早期并没有获取文本的API ，导致编码很繁琐，所以后来IE自己添加了一个API就是`innerText`，然后火狐和opera也推出了`textContent`

两者的区别：

- `textContent`会获取所有元素的内容，包括`<script>`和`<style>`元素，然而`innerText`不会获取这些内容。
- `innerText`可以意识到样式，它不会返回样式为`display:none`也就是隐藏的文本，而`textContent`会。
- 由于`innerText`会意识到样式，也就是会受样式的影响，因此会触发重排（reflow)导致性能低，而`textContent`不会。
- 与`textContent`不同， 在 Internet Explorer (对于小于等于 IE11 的版本) 中对`innerText`进行修改， 不仅会移除当前元素的子节点，而且还会永久性地破坏所有后代文本节点（所以不可能将节点再次插入到任何其他元素或同一元素中)。



##### Node.prototype.nextSibling

> `Node.nextSibling`属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回`null`。

值得注意的是，该属性还包括文本节点和注释节点（``）。因此如果当前节点后面有空格或者回车，该属性会返回一个文本节点，内容为空格或回车。

`document.body.nextSibling`返回了文本节点或者注释节点，而我们需要获得是元素节点， 也可以用`document.prototype.nextElementSibling`直接获取该节点后面最接近的同级元素节点。



##### Node.prototype.previousSibling

> `previousSibling`属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回`null`。

`Node.prototype.previousElementSibling` 前一个同级元素节点。



##### Node.prototype.firstChild，Node.prototype.firstElementChild

> `firstChild`属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回`null`。
> `firstElementChild`属性返回当前节点的第一个元素节点。



##### Node.prototype.lastChild，Node.prototype.lastElementChild

> `lastChild`属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回`null`。
> `lastElementChild`属性返回当前节点的最后一个元素节点。



##### Node.prototype.childNodes

> `childNodes`属性返回一个**类似数组**的对象（`NodeList`集合），成员包括当前节点的所有子节点。

值得注意的是，除了元素节点，`childNodes`属性的返回值还包括文本节点和注释节点。如果当前节点不包括任何子节点，则返回一个空的`NodeList`集合。由于`NodeList`对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。



##### Node.prototype.children

> `children`属性返回一个类似数组的对象（HTMLCollection）,成员包括当前节点的所有子元素节点。

值得注意的是，这里就不会返回文本节点和注释节点了，它只会返回元素节点。由于`HTMLCollection`集合是动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。

小tips : `Nodelist` 和 `HTMLCollection` 集合的区别

1. `NodeList`可以包含各种类型的节点，`HTMLCollection`只能包含 HTML 元素节点.
2. `NodeList` 实例可能是动态集合，也可能是静态集合。目前，只有`Node.childNodes`返回的是一个动态集合，其他的`NodeList` 都是静态集合。而`HTMLCollection`实例都是动态集合，节点的变化会实时反映在集合中.
3. 与`NodeList`接口不同，`HTMLCollection`没有`forEach`方法，只能使用`for`循环遍历。



#### 方法

##### Node.prototype.appendChild()

> `appendChild`方法就是接受一个节点对象作为参数，将其作为最后一个子节点，插入到当前节点 。该方法的返回值就是插入的子节点。

注意：

1. 如果参数节点是 DOM已经存在的节点，`appendChild`方法会将其从原来的位置移动到新位置。

2. 如果`appendChild`方法的参数是`DocumentFragment`节点，那么插入的是`DocumentFragment`的所有子节点，而不是`DocumentFragment`节点本身。返回值是一个空的`DocumentFragment` 。



##### Node.prototype.hasChildNodes()

> `hasChildNodes`方法返回一个布尔值，表示当前节点是否有子节点。

注意：子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，`hasChildNodes`方法也会返回`true`

判断一个节点是否有子节点，有以下3种方法：

1、node.hasChildNodes()

2、node.firstChild ! == null

3、node.childNodes && node.childNodes.length > 0



##### Node.prototype.cloneNode()

> `cloneNode`方法拷贝一个节点，并且可以接受一个布尔值，来表示是否同时拷贝子节点。它的返回值是一个克隆出来的新节点。

深拷贝：深入进去全部拷贝，包括子节点。

浅拷贝：只拷贝节点本身。

值得注意的是，该方法返回的节点不在文档中，无任何父节点，必须用如`appendChild()`等方法添加。



##### Node.prototype.insertBefore()

> `insertBefore`方法用于将某个节点插入父节点内部的指定位置。

`insertBefore`方法接受两个参数，第一个参数是所要插入的节点`newNode`，第二个参数是父节点`parentNode`内部的一个子节点`referenceNode`。`newNode`将插在`referenceNode`这个子节点的前面。返回值是插入的新节点`newNode`。



##### Node.prototype.removeChild()

> `removeChild`方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。

值得注意的是，被移除的节点依然存在于内存之中，但不再是DOM的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。

如果参数节点不是当前节点的子节点，`removeChild`方法将报错。



##### Node.prototype.replaceChild()

> `replaceChild`方法用于将一个新的节点，替换当前节点的某一个子节点。



##### Node.prototype.contains()

> `contains`方法返回一个布尔值，表示参数节点是否为该节点的后代节点。



#####  Node.prototype.isEqualNode()，Node.prototype.isSameNode()

> `isEqualNode`方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。
>  `isSameNode`方法返回一个布尔值，表示两个节点是否为同一个节点。

所以说，`isSameNode`就等同于 `===`严格相等运算符。



##### Node.prototype.normalize()

> `normailize`方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点



### Document API

`document`节点对象代表整个文档，每张网页都有自己的`document`对象。`window.document`属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。

`document`对象有不同的办法可以获取。

#### 属性

1.1 用于指向其他节点(快捷获取某些特殊节点)的属性

- `document.doctype` 指向`<DOCTYPE>`节点，即文档类型节点。
- `document.documentElement`指向 DOM 的 `html`节点
- `document.activeElement`指向获得焦点的那个节点
- `document.fullscreenElement`返回当前以全屏状态展示的 DOM 元素。
- `document.body`指向`<body>`节点
- `document.head`指向`<head>`节点。
- `document.scrollingElement`返回文档的滚动元素。



1.2 返回文档特定元素的伪数组集合的属性

- `document.links`属性返回当前文档所有设定了`href`属性的`<a>`及`<area>`节点。
- `document.forms`属性返回所有`<form>`表单节点。
- `document.images`属性返回页面所有`<img>`图片节点。
- `document.scripts`属性返回所有`<script>`节点。
- `document.styleSheets`属性返回文档内嵌或引入的样式表集合

以上均为动态集合，而且除了`document.styleSheets`，以上的集合属性返回的都是`HTMLCollection`实例。



1.3 返回文档信息的属性

- `document.documentURI和document.URL`属性都返回一个字符串，表示当前文档的网址。
- `document.domain`属性返回当前文档的域名，不包含协议和接口。
- `document.Location`对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。
- `document.title`属性返回当前文档的标题。
- `document.characterSet`属性返回当前文档的编码，比如`UTF-8`。
- `document.referrer`属性返回一个字符串，表示当前文档的访问者来自哪里。
- `document.cookie`属性返回文档的cookie信息，也可以直接通过该属性设置cookie。



1.4 返回文档状态的属性

- `document.hidden`属性返回一个布尔值，表示当前页面是否可见。

- `document.visibilityState`返回文档的可见状态。

  

#### 方法

- `document.open`方法清除当前文档所有内容，使得文档处于可写状态，供`document.write`方法写入内容。
- `document.close`方法用来关闭`document.open()`打开的文档。
- `document.write`方法用于向当前文档写入内容。
- `document.writeln`方法与`write`方法完全一致，除了会在输出内容的尾部添加换行符。
- `document.querySelector`接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。
- `document.querySelectorAll`方法与`querySelector`用法类似，区别是返回一个`NodeList`对象，包含所有匹配给定选择器的节点。
- `document.getElementsByTagName`搜索 HTML 标签名，返回符合条件的元素。
- `document.getElementsByClassName` 返回一个类似数组的对象（`HTMLCollection`实例），包括了所有`class`名字符合指定条件的元素，元素的变化实时反映在返回结果中。
- `document.getElementsByName`方法用于选择拥有`name`属性的 HTML 元素，返回一个类似数组的的对象（`NodeList`实例）.
- `document.getElementById`方法返回匹配指定`id`属性的元素节点
- `document.createElement`方法用来生成元素节点，并返回该节点。
- `document.createTextNode`方法用来生成文本节点（`Text`实例）。
- `document.createDocumentFragment`方法生成一个空的文档片段对象（`DocumentFragment`实例）。
- `document.hasFocus`方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。



### Element API

#### 属性

- `Element.id`属性返回指定元素的`id`属性，该属性可读写。
- `Element.tagName`属性返回指定元素的大写标签名
- `Element.title`属性用来读写当前元素的 HTML 属性`title`
- `Element.attributes`属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点
- `Element.className`属性用来读写当前元素节点的`class`属性。
- `Element.classList`返回一个伪数组，成员是当前元素节点的每个`class`。
- `Element.innerHTML`属性返回一个字符串，等同于该元素包含的所有 HTML 代码。
- `Element.innerText`属性返回一个字符串，等同于该元素包含的文本信息，和`innerHTML`的区别是不包含 标签元素，只有文本。
- `Element.clientHeight`属性返回一个整数值，表示元素的可见高度，即 内容 + padding。
- `Element.offsetHeight`属性返回一个整数值，表示元素的像素高度，即 可见高度 + border = 内容 + padding + border。
- `Element.clientWidth`属性返回元素节点的可见宽度，同样只对块级元素。
- `Element.scrollHeight`属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。
- `Element.scrollTop` 返回元素上边缘与视图之间的距离，即滚出可见区域的高度。
- `Element.offsetTop` 返回元素相对父元素垂直偏移位置，即当前元素到父元素上边缘的高度。
- `Element.scrollWidth`属性表示当前元素的总宽度（单位像素），其他地方都与`scrollHeight`属性类似。
- `Element.children`属性返回一个类似数组的对象（`HTMLCollection`实例），包括当前元素节点的所有子元素。
- `Element.childElementCount`属性返回当前元素节点包含的子元素节点的个数，与`Element.children.length`的值相同。



#### 方法

- `getAttribute()`读取某个属性的值
- `getAttributeNames()`返回当前元素的所有属性名
- `setAttribute()`写入属性值
- `hasAttribute()`某个属性是否存在
- `hasAttributes()`当前元素是否有属性
- `removeAttribute()`删除属性
- `Element.querySelector`接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。
- `Element.querySelectorAll`接受 CSS 选择器作为参数，返回一个`NodeList`实例，包含所有匹配的子元素。
- `Element.remove`方法继承自 ChildNode 接口，用于将当前元素节点从它的父节点移除。
- `Element.getBoundingClientRect`方法返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息
- `Element.addEventListener()`：添加事件的回调函数
- `Element.removeEventListener()`：移除事件监听函数
- `Element.dispatchEvent()`：触发事件





## 四、什么是闭包

### 什么是闭包

闭包是指有权访问另外一个函数作用域中的变量的函数。可以理解为 能够读取另一个函数作用域的变量的函数。

```js
var outer = function() {
  let name = "im outer function";
  let inner = function() {
    console.log(name);
  }
  return inner;  // inner 就是一个闭包函数，因为他能够访问到outer函数作用域内部的变量。
}
```



### 理解闭包函数

**问：为什么闭包函数能够访问其他函数的作用域 ?**

> JS中，基本数据类型的变量的值一般都是存在栈内存中，而对象类型的变量的值存储在堆内存中，栈内存存储对应堆内存的空间地址。基本的数据类型: Number 、Boolean、Undefined、String、Null。
>
> **示例：**
>
> ```js
> var a = 1;  // 变量a 指向基本数据类型的数值 1，这个 1 是保存在栈内存中的。
> var b = {m: 20}; // 变量b 引用一个对象。 b 在栈内存中指向一个 堆内存地址，通过这个地址就能找到 对内存中的对象
> ```
>
> 当我们执行 b={m:30}时，堆内存就有新的对象{m：30}，栈内存的b指向新的空间地址( 指向{m：30} )，而堆内存中原来的{m：20}就会被程序引擎垃圾回收掉，节约内存空间。

js函数也是对象，它也是在堆与栈内存中存储的，分析一下如下的例子：

```json
var a = 1;
function fn(){
    var b = 2;
    function fn1(){
        console.log(b);
    }
    fn1();
}
fn();
```

栈是一种先进后出的数据结构：

1. 在执行fn前，此时我们在全局执行环境(浏览器就是window作用域)，全局作用域里有个变量a；
2. 进入fn，此时栈内存就会push一个fn的执行环境，这个环境里有变量b和函数对象fn1，这里可以访问自身执行环境和全局执行环境所定义的变量；
3.  进入fn1，此时栈内存就会push 一个fn1的执行环境，这里面没有定义其他变量，但是我们可以访问到fn和全局执行环境里面的变量，因为程序在访问变量时，是向底层栈一个个找，如果找到全局执行环境里都没有对应变量，则程序抛出underfined的错误。
4. 随着fn1()执行完毕，fn1的执行环境被杯销毁，接着执行完fn()，fn的执行环境也会被销毁，只剩全局的执行环境下，现在没有b变量，和fn1函数对象了，只有a 和 fn(函数声明作用域是window下)。

在函数内访问某个变量是根据函数作用域链来判断变量是否存在的，而函数作用域链是程序根据函数所在的执行环境栈来初始化的，所以上面的例子，我们在fn1里面打印变量b，根据fn1的作用域链的找到对应fn执行环境下的变量b。所以当程序在调用某个函数时，做了以下的工作：准备执行环境，初始函数作用域链和arguments参数对象。



**回到前一个示例：**

```js
var outer = function() {
  let name = "im outer function";
  let inner = function() {
    console.log(name);
  }
  return inner;  // inner 就是一个闭包函数，因为他能够访问到outer函数作用域内部的变量。
}

var inner = outer();  // 获得inner闭包函数
inner();  // 打印变量name

// 当程序执行完var inner = outer()，其实outer的执行环境并没有被销毁，因为他里面的变量a仍然被被inner的函数作用域链所引用，当程序执行完inner(), 这时候，inner和outer的执行环境才会被销毁调；《JavaScript高级编程》书中建议：由于闭包会携带包含它的函数的作用域，因为会比其他函数占用更多内存，过度使用闭包，会导致内存占用过多。
```



### 闭包带来的问题

#### 1. 引用变量可能发生变化

```js
var outer = function() {
  let res = [];
  for (var i = 0; i < 10; i++){
    res[i] = function() {
      console.log(i);
    }
  }
  return res;
}

outer().forEach(
  function(func){
    func();
  }
)
// 看样子result每个闭包函数对打印对应数字，1,2,3,4,...,10, 实际不是，因为每个闭包函数访问变量i是outer执行环境下的变量i，随着循环的结束，i已经变成10了，所以执行每个闭包函数，结果打印10， 10， ..., 10。

// 解决这个问题：
for (let i = 0; i < 10; i++){  // 改用let定义变量i，ES6的新语法，let 定义的变量是块级作用域。
```



#### 2. this 指向问题

```js
var outer = function() {
  var aa = 11
  return function() {
    console.log(this.aa);
  }
}

outer()(); // undefined

// 因为里面的闭包函数是在window作用域下执行的，也就是说，this指向window，变量 aa 作用域自outer向上的栈
```



#### 3. 内存泄漏问题

```js
function  showId() {
  var el = document.getElementById("app")
  el.onclick = function(){
    alert(el.id)   // 这样会导致闭包引用外层的el，当执行完showId后，el无法释放
  }
}

// 改成下面
function  showId() {
  var el = document.getElementById("app")
  var id  = el.id
  el.onclick = function(){
    alert(id)   // 这样会导致闭包引用外层的el，当执行完showId后，el无法释放
  }
  el = null    // 主动释放el
}
```













## 五、事件冒泡和事件捕获

### 冒泡和捕获

> 事件冒泡：事件由 目标结点 向 根结点 传递；
>
> 事件捕获：事件由 根结点 向 目标结点 传递；
>
> 一般的，事件分为三个阶段：捕获阶段、目标阶段、冒泡阶段。
>
> ##### （1）捕获阶段（Capture Phase）
>
> 事件的第一个阶段是捕获阶段。事件从文档的根节点流向目标对象节点。途中经过各个层次的DOM节点，并在各节点上触发捕获事件，直到到达事件的目标节点。捕获阶段的主要任务是建立传播路径，在冒泡阶段，事件会通过这个路径回溯到文档跟节点。
>
> ##### （2）目标阶段（Target Phase）
>
> 当事件到达目标节点的，事件就进入了目标阶段。事件在目标节点上被触发，然后会逆向回流，直到传播至最外层的文档节点。
>
> ##### （3）冒泡阶段（Bubble Phase）
>
> 事件在目标元素上触发后，并不在这个元素上终止。它会随着DOM树一层层向上冒泡，回溯到根节点。
> 冒泡过程非常有用。它将我们从对特定元素的事件监听中释放出来，如果没有事件冒泡，我们需要监听很多不同的元素来确保捕获到想要的事件。

我们可以将网页的结构想象为一棵树。比如说网页的主体可以包含表格，表格本身又包含多行，而表格行内包含了若干单元格，见图。

<img src="./images/frontend_001.jpg" alt="冒泡和捕获" style="zoom:50%; float: left;" />

比方说，你编写了一个脚本，一旦鼠标移过页面上的元素，就会弹出提示框（alert）。如果移过单元格，你希望弹出“移过单元格”的提示，你肯定能收到。不仅如此，随后你还会收到“移过行”、“移过表格”的提示，最后是“移过主体”。这就是**事件冒泡**，也就是说事件从树的下面向上面冒泡。**这是网页工作的一般方式。**

但是，如果你想让事件以相反的方向发生呢，也就是从上向下？这种情况就称为**事件捕获**，脚本弹出提示框的顺序是主体、表格、行，最后是单元格。

这是使用高级事件处理程序的一大优势：调用 addEventListener()的时候，开发人员可以控制事件发生的方向。addEventListener()函数有 3 个参数：事件本身（目标）、触发事件时调用的函数（监听器），以及用来指定事件被捕获（true）还是冒泡（false）的布尔值。

**冒泡示例：**

```html
<html>
<head>
    <meta charset="UTF-8">
</head>
<body>
<table id="one">
    <thead id="two">
        <tr id="three">
            <td>冒泡和捕获</td>
        </tr>
    </thead>
</table>
<script>
    var one = document.getElementById("one");
    var two = document.getElementById("two");
    var three = document.getElementById("three");

    var call_1 = function() {
        alert("come from one")
    }
    var call_2 = function() {
        alert("come from two")
    }
    var call_3 = function() {
        alert("come from three")
    }

    three.addEventListener("click", call_3, false);  // 将监听入参bool值改为true，则表示捕获
    two.addEventListener("click", call_2, false);
    one.addEventListener("click", call_1, false);

</script>
</body>
</html>
```



### 事件代理

在传统的事件处理中，需要为每一个元素添加或者是删除事件处理器。然而，事件处理器将有可能导致内存泄露或者是性能下降，用得越多这种风险就越大。JavaScript事件代理可以把事件处理器添加到一个父元素上，这样就避免了把事件处理器添加到多个子元素上。

**它是怎么运作的呢？**

事件代理用到了两个JavaSciprt事件特性：**事件冒泡以及目标元素**。当一个元素上的事件被触发的时候，同样的事件将会在那个元素的所有祖先元素中被触发。这一过程被称为事件冒泡；使用事件代理，我们可以把事件处理器添加到一个元素上，等待一个事件从它的子级元素里冒泡上来，并且可以得知这个事件是从哪个元素开始的。

**这对我有什么好处呢？**

比如说在一个10列、100行的HTML表格里，让其每一个单元格在被点击的时候变成可编辑状态。如果把事件处理器加到这1000个单元格会产生一个很大的性能问题，并且有可能导致内存泄露甚至是浏览器的崩溃。相反地，使用事件代理，你只需要把一个事件处理器添加到table元素上就可以了，这个函数可以把点击事件给截下来，并且判断出是哪个单元格被点击了。

**事件代理示例：**

```html
<html>
<head>
    <meta charset="UTF-8">
</head>
<body>
<table>
    <thead>
        <tr id="parent">
            <td id="one">喝醉</td>
            <td id="two">闹事</td>
            <td id="three">刑满释放</td>
        </tr>
    </thead>
</table>
<script>
    var parent = document.getElementById("parent");

    var call = function(event) {
        if (event.target.tagName.toLowerCase() === "td"){
            alert(`目标元素 ${event.target.innerText}`)
        }
            alert(`当前元素 ${event.currentTarget.id}`)
    }
    parent.addEventListener("click", call, false);
</script>
</body>
</html>
```



### 阻止事件冒泡

> stopPropagation方法，该方法阻止触发事件流中的其他事件，它没有参数。

**为什么要阻止事件冒泡**

有种可能是，某个DOM节点绑定了某事件监听器，本来是想当该DOM节点触发事件，才会执行回调函数。结果是该节点的某后代节点触发某事件，由于事件冒泡，该DOM节点事件也会触发，执行了回调函数，这样就违背了最初的本意了。

**阻止事件冒泡示例：**

```html
<html>
<head>
    <meta charset="UTF-8">
</head>
<body>
<table>
    <thead>
        <tr id="parent">
            <td id="one">喝醉</td>
        </tr>
    </thead>
</table>
<script>
    var parent = document.getElementById("parent");
    var one = document.getElementById("one");

    var call_1 = function(event) {
        alert(`父元素`);  // 因为子元素在回调中阻止了事件冒泡，所以父元素将不能监听到该事件
    }
    var call_2 = function(event) {
        alert(`子元素`);
        event.stopPropagation();  // 阻止冒泡
    }
    parent.addEventListener("click", call_1);
    one.addEventListener("click", call_2);

</script>
</body>
</html>
```

需要注意的是，我们无法在事件捕获阶段阻止事件冒泡！

例如，我们在 parent 的监听代码里加上true，那么 tr 标签就会触发事件。因为捕获是从根节点向目标节点触发，而冒泡是从目标节点向根节点触发。



## 六、JS实现重载和多态

> **重载：**
>
> 重载可认为是静态的多态，静态联编，发生在编译阶段；
>
> 重载就是一组具有相同名字、不同参数列表的函数（方法）。
>
> 重载，函数特征之一，表现为在一个类中同名不同参的方法分别被调用会产生不同的结果。
>
> **多态：**
>
> 多态是动态的，动态联编，发生在运行阶段；
>
> 多态，面向对象特征之一，表现为不同对象调用相同方法会产生不同的结果。可以理解一个方法被不同实现后 展现不同的效果及状态。
>
> 静态的比动态的效率高，但动态的最大优点是多态性，提高代码复用性。

### 重载

js本身不支持重载，所以只能通过其他方式实现，arguments检测传参的个数，然后再执行不同的方式

```javascript
// 根据参数个数区分执行方式
var overload = function(){
  switch(arguments.length){
    case 0:
      return null;
    case 1:
      return arguments[0];
    case 2:
      return arguments[0] + arguments[1]
    default:
      return "too many!!"
  }
}

console.log(overload());
console.log(overload(3, 5));
console.log(overload(4, 5, 8));


// 根据参数类型来判断
var overload = function(a, b){
  if (typeof a == "number" && typeof b == "number"){
    return a + b;
  }
  if (typeof a == "string" && typeof b == "string"){
    return `thank you input: ${a} and ${b}`
  }
  return "type error!"
}

console.log(overload("ruojie", "hasaki"));
console.log(overload(3, 5));
console.log(overload(4, "four"));
```



### 多态

通过对比非多态和多态代码理解多态。

```js
// 非多态
var makeSound = function(animal) {
    if(animal instanceof Duck) {
        console.log('嘎嘎嘎');
    } else if (animal instanceof Chicken) {
        console.log('咯咯咯');
    }
}
var Duck = function(){}
var Chiken = function() {};
makeSound(new Chicken());
makeSound(new Duck());

// 多态
var makeSound = function(animal) {
    animal.sound();
}
 
var Duck = function(){}
Duck.prototype.sound = function() {
    console.log('嘎嘎嘎')
}
var Chiken = function() {};
Chiken.prototype.sound = function() {
    console.log('咯咯咯')
}
 
makeSound(new Chicken());
makeSound(new Duck());
```



## 七、深拷贝原理

### 浅拷贝

子对象复制父对象，父子对象发生关联，两者属性值指向同一内存空间，共享内存。简单来讲，就是改变其中一个对象，另一个对象也会跟着改变。

**浅拷贝方法：**

1. Object.assign() 当object只有一层的时候是深拷贝，当有多层的时候是浅拷贝。二级属性下的值仍会随原有值的改变而改变。

2. Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。

3. 函数库lodash的_.clone方法



### 深拷贝

拷贝对象各个层级的属性。简单的讲，就是复制出来的每个对象都有属于自己的内存空间，不会互相干扰。

**深拷贝方法：**

1. JSON.parse(JSON.stringify())	原理是现将对象转成一个新的字符串返回，而原对象不受影响；在将字符串解析成一个新的对象。

2. 函数库lodash的_.cloneDeep方法

3. 手写递归

4. jQuery.extend()方法



### 浅拷贝和深拷贝的区别

浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。

深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。



### 赋值和浅拷贝的区别

- 赋值

  当我们把一个对象赋值给一个新的变量时，赋的其实是该对象的在栈中的地址，而不是堆中的数据。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。

- 浅拷贝

  浅拷贝是按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。









## 八、JS中实现继承的方式

要实现继承，首先需要有一个父类，代码如下：

```js
// 定义一个动物类
function Animal(name) {
  // 实例属性
  this.name = name || 'Animal';
  // 实例方法
  this.sleep = function() {
    console.log(`${this.name} 正在睡觉`);
  }
}
// 原型方法
// 原型和原形链见第 十二 小节
Animal.prototype.eat = function(food) {
  console.log(`${this.name} 正在吃： ${food}`);
}
```



### 1. 原型链继承

**核心**： 将父类的实例作为子类的原型

```js
function Cat(){};
// 下面这一行是重点
Cat.prototype = new Animal();

Cat.prototype.name = "Cat";

var cat = new Cat();
console.log(cat.name); // Cat
cat.sleep(); // Cat 正在睡觉
cat.eat("fish"); // Cat 正在吃：fish

console.log(Cat.prototype instanceof Animal); // true
console.log(cat instanceof Cat); // true
console.log(cat instanceof Animal); // true
```

**优点：**

- 非常纯粹的继承关系，实例是子类的实例，也是父类的实例
- 父类新增原型方法/原型属性，子类都能访问到
- 简单，易于实现

**缺点：**

- 要想为子类新增属性和方法，必须要在`new Animal()`这样的语句之后执行，不能放到构造器中
- 无法实现多继承
- 来自原型对象的引用属性是所有实例共享的
- 创建子类实例时，无法向父类构造函数传参



### 2. 构造继承

**核心**：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）

```js
function Cat(name){
  // 使用 call 函数重新定义 this。等同于把 Cat 的实例放到了 Animal中完成了实例化。
  Animal.call(this, name)
};


var cat = new Cat("ccc");
console.log(cat.name); // ccc
cat.sleep(); // ccc 正在睡觉

console.log(cat instanceof Cat); // true
console.log(cat instanceof Animal); // false

cat.eat("fish"); // Uncaught TypeError: cat.eat is not a function
```

**优点：**

- 解决了1中，子类实例共享父类引用属性的问题
- 创建子类实例时，可以向父类传递参数
- 可以实现多继承（call多个父类）

**缺点：**

- 实例并不是父类的实例，只是子类的实例
- 只能继承父类的实例属性和方法，不能继承原型属性/方法
- 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能



### 3. 实例继承

**核心**：为父类实例添加新特性，作为子类实例返回

```js
function Cat(name){
  let instance = new Animal();
  instance.name = name || "Tom";
  return instance;
};


var cat = new Cat("ccc");
console.log(cat.name); // ccc
cat.sleep(); // ccc 正在睡觉
cat.eat("fish"); // ccc 正在吃：fish

console.log(cat instanceof Cat); // false
console.log(cat instanceof Animal); // true
```

**优点：**

- 不限制调用方式，不管是new 子类()还是子类()，返回的对象具有相同的效果

**缺点：**

- 实例是父类的实例，不是子类的实例
- 不支持多继承



### 4. 拷贝继承

```js
function Cat(name){
  let instance = new Animal();
  for (let p in instance){
    Cat.prototype[p] = instance[p];
  }
  Cat.prototype.name = name || "Tom";
};


var cat = new Cat("ccc");
console.log(cat.name); // ccc
cat.sleep(); // ccc 正在睡觉
cat.eat("fish"); // ccc 正在吃：fish

console.log(cat instanceof Cat); // true
console.log(cat instanceof Animal); // false
```

**优点：**

- 支持多继承

**缺点：**

- 效率较低，内存占用高（因为要拷贝父类的属性）
- 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）



### 5. 组合继承

**核心**：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用

```js
function Cat(name){
  Animal.call(this, name);
};
Cat.prototype = new Animal();
// 修复构造函数指向
Cat.prototype.constructor = Cat;


var cat = new Cat("ccc");
console.log(cat.name); // ccc
cat.sleep(); // ccc 正在睡觉
cat.eat("fish"); // ccc 正在吃：fish

console.log(cat instanceof Cat); // true
console.log(cat instanceof Animal); // true
```

**优点：**

- 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法
- 既是子类的实例，也是父类的实例
- 不存在原型的引用属性共享问题
- 可传参
- 函数可复用

**缺点：**

- 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）



### 6. 寄生组合继承（推荐）

**核心：**通过寄生方式，砍掉父类的实例属性。这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点

```js
function Cat(name){
  Animal.call(this, name);
};
// Object.create()方法创建一个新对象，使用现有的对象来作为新创建的对象的__proto__。
// Object.create(proto，[propertiesObject])
// 返回值：一个新对象，带着指定的原型对象和属性。
Cat.prototype = Object.create(Animal.prototype);
// 修复构造函数指向
Cat.prototype.constructor = Cat;


var cat = new Cat("ccc");
console.log(cat.name); // ccc
cat.sleep(); // ccc 正在睡觉
cat.eat("fish"); // ccc 正在吃：fish

console.log(cat instanceof Cat); // true
console.log(cat instanceof Animal); // true
```





### 7. ES6 的继承

实际开发比较常用，写法更加面向对象，原理还是原型链。

**super**

super这个关键字，既可以当作函数使用，也可以当作对象使用。当作函数使用时，super代表父类的构造函数，并在子类中执行Parent.apply(this)，从而将父类实例对象的属性和方法，添加到子类的this上面。以下三点需要特别注意：

1. 子类必须在constructor方法中调用super方法，如果子类没有定义constructor方法，constructor方法以及其内部的super方法会被默认添加。
2. 在子类的constructor方法中，只有调用super之后，才可以使用this关键字，否则会报错。
3. super作为对象时，在子类中指向父类的原型对象。即super=Parent.prototype。

示例一：

```js
class Animal {
  constructor(name) {
    this.name = name;
  };
  showName() {
    console.log(this.name);
  };
  type() {
    return "宠物";
  }
};

class Cat extends Animal{
  constructor(name) {
    super(name);
  };
  showType(){
    console.log(super.type());
  }
}

var cat = new Cat("咖啡猫");
cat.showName(); // 咖啡猫
cat.showType(); // 宠物
```

示例二：

```js
function Animal(name) {
  // 实例属性
  this.name = name || 'Animal';
  // 实例方法
  this.sleep = function() {
    console.log(`${this.name} 正在睡觉`);
  }
}
// 原型方法
// 原型和原形链见第 十二 小节
Animal.prototype.eat = function(food) {
  console.log(`${this.name} 正在吃： ${food}`);
}

class Cat extends Animal{ // JS中 class 本质上就是函数
  constructor(name) {
    super(name);
  }
}

var cat = new Cat("咖啡猫");
cat.eat("鱼丸"); // 咖啡猫 正在吃： 鱼丸
cat.sleep(); // 咖啡猫 正在睡觉
```



**static**

在一个方法前加上关键字static，就表示该方法不会被实例继承，但是父类的静态方法，会被子类继承。

```js
class Animal {
	static showWhat (name) {
		alert(name)
	}
	showName (name) {
		showWhat(name)
	}
}
class Cat extends Animal {}


Cat.showWhat('小猪') //小猪

var an = new Animal()
an.showWhat('小狗') //Uncaught TypeError: an.showWhat is not a function
```



## 九、this关键字

this 是Javascript语言的一个关键字，它代表函数运行时自动生成的一个内部对象，只能在函数内部使用。

**this 指的是调用函数的那个对象，也可以理解为函数运行时所在的环境。**

this 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，谁调用的函数，this就指向谁。



**示例一：**

```js
var obj = {
  foo: function() {
    console.log(this.name);
  },
  name: "Kevin"
}
var name = "Bole";
var foo = obj.foo;

obj.foo(); // Kevin

foo(); // Bole
```

分析：

1. 对于obj.foo()来说，foo是被对象obj调用，所以this指向obj；

2. 对于foo()来说，foo是被全局对象直接调用，所以this指向全局window。

   obj.foo 是一个函数`function(){console.log(this.name)}`，此时 foo 就是不带任何修饰的函数调用，`function(){console.log(this.a)}.call(undefined)`，按理说打印出来的 this 应该是 undefined，但是浏览器里有一条规则：

   > 如果你传的 context 就 null 或者 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）

因为两次调用this指向的对象不一样，所以两次调用的属性其实分别是两个对象的同名属性，结果也就不一样了。



**补充：**

1. DOM对象绑定事件也属于方法调用模式，因此它绑定的this就是事件源DOM对象。

   ```js
   document.addEventListener('click', function(e){
       console.log(this); // document对象
       setTimeout(function(){
           console.log(this);  // window对象
       }, 200);
   }, false);
   ```

   解析：点击页面监听click事件属于方法调用，this指向事件源DOM对象，即`obj.fn.apply(obj)`，setTimeout内的函数属于回调函数，可以这么理解，`f1.call(null,f2)`，所以this指向window。这也是 setTimeout 丢失 this 的根因。

2. new一个函数时，背地里会将创建一个连接到prototype成员的新对象，同时this会被绑定到那个新对象上。

   ```js
   function Person(name,age){
   // 这里的this都指向实例
       this.name = name
       this.age = age
       this.sayAge = function(){
           console.log(this.age)
       }
   }
   
   var dot = new Person('Dot',2)
   dot.sayAge()//2
   ```

   



## 十、call、applay、bind的区别

**call、apply、bind 的作用是改 变函数运行时 this 的指向。**

### call

call 方法第一个参数是要绑定给this的值，后面传入的是一个参数列表。当第一个参数为null、undefined的时候，默认指向window。

**理解call：**

```js
// 上下两行等价
obj1.fn()
obj1.fn.call(obj1); // 通过对象 obj1 调用函数 fn，就等价于在 call 的时候，将 this 指向了 obj1。这也能解释 第九节中this指向的问题。

fn1()
fn1.call(null); // 无任何参数调用时，等价于 call 的时候，传入 null，根据浏览器规则，传入null时，就使用默认的上下文 window 传入，所以此时 this 是指向 window的。

f1(a, b)
f1.call(null, a, b); // 带参调用函数时，等价于 call 的第一个参数传 null，后面的参数就是函数调用的参数。
```



**示例：**

```js
var obj = {
    message: 'My name is: '
}

function getName(firstName, lastName) {
    console.log(this.message + firstName + ' ' + lastName)
}

var message = "His name is: "

getName.call(null, 'Dot', 'Dolby'); // His name is: Dot Dolby  此时函数内部的this指向 window
getName.call(obj, 'Dot', 'Dolby'); // My name is: Dot Dolby  此时函数内部的this指向 obj
```



### apply

apply接受两个参数，第一个参数是要绑定给this的值，第二个参数是一个参数数组。当第一个参数为null、undefined的时候，默认指向window。

**理解apply：**

```js
obj1.fn() 
obj1.fn.apply(obj1);

fn1()
fn1.apply(null);

f1(a, b)
f1.apply(null, [a, b]);
// 事实上 apply 和 call 的用法几乎相同, 唯一的差别在于：当函数需要传递多个变量时, apply可以接受一个数组作为参数输入, call则是接受一系列的单独变量。
```

**示例：**

```js
var obj = {
    message: 'My name is: '
}

function getName(firstName, lastName) {
    console.log(this.message + firstName + ' ' + lastName)
}

var message = "His name is: "

getName.apply(null, ['Dot', 'Dolby']); // His name is: Dot Dolby  此时函数内部的this指向 window
getName.apply(obj, ['Dot', 'Dolby']); // My name is: Dot Dolby  此时函数内部的this指向 obj
```



call和apply可用来借用别的对象的方法，这里以call()为例：

```js
var Person1  = function () {
    this.name = 'Dot';
}
var Person2 = function () {
    this.getname = function () {
        console.log(this.name);
    }
    Person1.call(this);  // 在实例化 Person2 的时候，将 person 对象作为参数传入，使 Person1 的 this 指向了 person
}
var person = new Person2();
person.getname();       // Dot
```



对于什么时候该用什么方法，其实不用纠结。如果你的参数本来就存在一个数组中，那自然就用 apply，如果参数比较散乱相互之间没什么关联，就用 call。像上面的找一组数中最大值的例子，当然是用apply合理。



### bind

和call很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表。区别在于bind方法返回值是函数以及bind接收的参数列表的使用。

- bind返回值是函数

  bind 方法不会立即执行，而是返回一个改变了上下文 this 后的函数。而原函数中的 this 并没有被改变，依旧指向全局对象 window。

  ```js
  var obj = {
      message: 'My name is: '
  }
  
  function getName(firstName, lastName) {
      console.log(this.message + firstName + ' ' + lastName)
  }
  
  var message = "His name is: ";
  
  var newFunc = getName.bind(obj);
  
  console.log(newFunc); // getName(){...}
  newFunc("zhang", "jian"); // My name is: zhang jian
  
  getName("zhang", "jian"); // His name is: zhang jian  原函数不受影响
  ```

- bind参数的使用

  bind 方法在被调用时，还可以预先根据参数位置，传入一些一致的位置参数。类似于python中的偏函数。

  ```js
  var obj = {
      message: 'My name is: '
  }
  
  function getName(firstName, lastName) {
      console.log(this.message + firstName + ' ' + lastName)
  }
  
  var newFunc1 = getName.bind(obj, "zhang");
  var newFunc2 = getName.bind(obj, "ou", "yang");
  
  
  newFunc1("jian"); // My name is: zhang jian
  newFunc1("jie"); // My name is: zhang jie
  
  newFunc2(); // My name is: ou yang
  newFunc2("feng"); //  My name is: ou yang  多余的位置参数会被丢弃
  ```

  

### 总结

**call、apply和bind函数存在的区别:**

bind 返回一个新函数，便于稍后调用； apply， call则是立即调用。apply 以数组的形式传入多个参数，而 call 则是按位置逐个传入。

除此外， 在 ES6 的箭头函数下，call 和 apply 将失效，对于箭头函数来说:

- 箭头函数体内的 this 对象，就是定义时所在的对象， 而不是使用时所在的对象；所以不需要类似于`var _this = this`这种丑陋的写法；
- 箭头函数不可以当作构造函数，也就是说不可以使用 new 命令， 否则会抛出一个错误；
- 箭头函数不可以使用 arguments 对象,，该对象在函数体内不存在。如果要用，可以用 Rest 参数代替；
- 不可以使用 yield 命令, 因此箭头函数不能用作 Generator 函数。





## 十一、var 和 let 的区别

ES6 新增了`let`命令，用来声明局部变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效，而且有暂时性死区的约束。

先看个`var`的常见变量提升的面试题目：

```js
题目1：
var a = 99;            // 全局变量a
f();                   // f是函数，虽然定义在调用的后面，但是函数声明会提升到作用域的顶部。 
console.log(a);        // a=>99,  此时是全局变量的a
function f() {
  console.log(a);      // 当前的a变量是下面变量a声明提升后，默认值undefined
  var a = 10;
  console.log(a);      // a => 10
}

// 输出结果：
undefined
10
99
```



### ES6可以用let定义块级作用域变量

在ES6之前，我们都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以`{}`限定不了var声明变量的访问范围。
例如：

```js
{ 
  var i = 9;
} 
console.log(i);  // 9
```

ES6新增的`let`，可以声明块级作用域的变量。

```js
{ 
  let i = 9;     // i变量只在 花括号内有效！！！
} 
console.log(i);  // Uncaught ReferenceError: i is not defined
```



### let 配合for循环的独特应用

`let`非常适合用于 `for`循环内部的块级作用域。JS中的for循环体比较特殊，每次执行都是一个全新的独立的块作用域，用let声明的变量传入到 for循环体的作用域后，不会发生改变，不受外界的影响。看一个常见的面试题目：

```js
for (var i = 0; i <10; i++) {  
  setTimeout(function() {  // 同步注册回调函数到 异步的 宏任务队列。
    console.log(i);        // 执行此代码时，同步代码for循环已经执行完成
  }, 0);
}
// 输出结果
10   共10个
// 这里面的知识点： JS的事件循环机制，setTimeout的机制等
```

如果把 `var`改成 `let`声明：

```js
// i虽然在全局作用域声明，但是在for循环体局部作用域中使用的时候，变量会被固定，不受外界干扰。
for (let i = 0; i < 10; i++) { 
  setTimeout(function() {
    console.log(i);    //  i 是循环体内局部作用域，不受外界影响。
  }, 0);
}
// 输出结果：
0  1  2  3  4  5  6  7  8 9
```



### let没有变量提升与有暂时性死区

用`let`声明的变量，不存在变量提升。而且要求必须 等`let`声明语句执行完之后，变量才能使用，不然会报`Uncaught ReferenceError`错误。
例如：

```js
console.log(aicoder);    // 错误：Uncaught ReferenceError ...
let aicoder = 'aicoder.com';
// 这里就可以安全使用aicoder
```

> ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。
> 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。



### let变量不能重复声明

let不允许在相同作用域内，重复声明同一个变量。否则报错：`Uncaught SyntaxError: Identifier 'XXX' has already been declared`

例如：

```js
let a = 0;
let a = 'sss';
// Uncaught SyntaxError: Identifier 'a' has already been declared
```



### 总结

ES6的let让js真正拥有了块级作用域，也是向这更安全更规范的路走，虽然加了很多约束，但是都是为了让我们更安全的使用和写代码。





## 十二、原型和原形链

构造函数创建对象：

```js
function Person(){};
var person = new Person();
person.name = "Kevin";
console.log(person.name); // Kevin
```

Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。



### prototype

每个函数都有一个 prototype 属性。
每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性。

<img src="./images/frontend_002.jpg" style="float: left; width: 50%;">

```js
function Person(){};
// 注意：只有函数才会有 prototype 属性
Person.prototype.name = "Kevin";
var person1 = new Person();
var person2 = new Person();

console.log(person1.name); // Kevin
console.log(person2.name); // Kevin
```



### `__proto__`

上面说到，每一个JavaScript对象(null除外)在创建的时候就会关联 实例原型(即构造函数的`prototype`属性)，那么 JS对象 通过什么属性指向该 原型呢，那就是 `__proto__`属性。

<img src="./images/frontend_003.jpg" style="float: left; width: 50%;">

```js
function Person(){};
Person.prototype.name = "Kevin";
var person1 = new Person();

console.log(person1.__proto__ === Person.prototype); // true
```



### constructor

每个原型都有一个 constructor 属性指向关联的构造函数，就是说实例原型通过 constructor 指向构造函数。

<img src="./images/frontend_004.jpg" style="float: left; width: 50%;">

```js
function Person(){};
Person.prototype.name = "Kevin";
var person1 = new Person();

console.log(person1.__proto__ === Person.prototype); // true
// ES5 的对象方法，获取对象的原型
console.log(Object.getPrototypeOf(person1) === Person.prototype); // true
// 实例的 constructor 指向构造函数
console.log(Person === Person.prototype.constructor); // true
```



### 实例与原型

实例与原型的关联关系，类似于继承。当实例与原型中有相同的属性时，调用时优先使用实例自己的，当实例中没有时，才会到原型中去找。

```js
function Person(){};
Person.prototype.name= "Kevin";
var person = new Person();
person.name = "Tom";

console.log(person.name); // Tom

// 当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.__proto__，也就是 Person.prototype中查找。
delete person.name;
console.log(person.name); // Kevin
```



### 原型与原型

上面还说到，实例原型 本身也是一个对象。普通 JS 对象的 `__proto__` 属性指向的就是自己关联的原型，那么 这个原型对象的 `__proto__` 属性又指向谁呢？他指向的 就是 Object.prototype。因为我们每一个对象本质上也都是 Object 的实例对象。

<img src="./images/frontend_005.jpg" style="float: left; width: 50%;">

```js
function Person(){};
var person = new Person();
var object = new Object();

console.log(person.__proto__.__proto__ === Object.prototype); // true
console.log(Person.prototype.__proto__ === object.__proto__); // true
```



### 原形链

从上面可以看到，普通原型的`__proto__`指向的是 Object.prototype ，那么 Object.prototype  的 `__proto__` 又指向谁呢？是不是感觉已经到了 无物可指 的地步？你没猜错，就是 null。

<img src="./images/frontend_006.jpg" style="float: left; width: 50%;">

```js
var object = new Object();
console.log(object.__proto__.__proto__ === null); // true
console.log(Object.prototype.__proto__ === null); // true
```

JavaScript 默认并不会**复制**对象的属性，相反，JavaScript 只是在两个对象之间创建一个**关联**，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，**委托**的说法反而更准确些。



# Vue类

## 一、computed和watch的区别

### computed 计算属性

计算属性 computed 是为了模板中的表达式简洁，易维护，符合用于简单运算的设计初衷。

```vue
<template>
  <div>
    <!-- 使用计算属性，也当成属性使用，不需要加（） -->
    <p>{{ formatName }}</p>
    <p v-for="score in filterScore" :key="score">{{ score }}</p>
  </div>
</template>
<script>
export default {
  data() {
    return {
      firstname: "king",
      lastname: "author",
      score: [90, 95, 98, 80, 85, 91, 88, 82]
    };
  },
  computed: {
    formatName() {
      // 把于复杂，冗长，且不好维护的计算过程，放到计算属性中
      return this.firstname.substring(0, 1).toUpperCase() + this.firstname.substring(1) + " " + this.lastname.substring(0, 1).toUpperCase() + this.lastname.substring(1);
    },
    filterScore() {
      // 通过计算属性过滤列表
      return this.score.filter(item => item >= 90);
    }
  }
};
</script>
```

**总结：**

1. 变量不在 data中定义，而是定义在computed中，写法跟写方法一样，有返回值。函数名直接在页面模板中渲染，不加小括号 。

2. 根据传入的变量的变化进行结果的更新。

3. 计算属性基于响应式依赖进行缓存。如其中的任意一个值未发生变化，它调用的就是上一次 计算缓存的数据，因此提高了程序的性能。而methods中每调用一次就会重新计算一次，为了减少不必要的资源消耗，选择用计算属性。

4. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化。

5. computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

   

### watch 监听属性

监听属性 watch 是监听 data() 函数中定义的属性变量。监听函数需要与被监听的属性同名。

```vue
<template>
  <div>
    <input type="text" v-model="lastname" />
    <input type="text" v-model="address.city" />
  </div>
</template>
<script>
export default {
  data() {
    return {
      firstname: "king",
      lastname: "author",
      address: {
        contry: "china",
        province: "sichuan",
        city: "chengdu"
      }
    };
  },
  watch: {
    // 监听名字的变化，1s后打印变化信息
    lastname(newValue, oldValue) {
      setTimeout(() => {
        console.log(`修改前：${oldValue}; \n 修改后：${newValue}`);
      }, 1000);
    },
    // 监听函数也可以是字符串的形式，方便见对象里面的值
    "address.city": (newValue, oldValue) => {
      console.log(`修改前：${oldValue}; \n 修改后：${newValue}`);
    }
  }
};
</script>
```

**总结：**

1. 不支持缓存，数据变，直接会触发相应的操作；

2. watch 支持异步；

3. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；

4. 当一个属性发生变化时，需要执行对应的操作；

5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数还有两个属性：
   1. immediate：组件加载立即触发回调函数执行；
   2. deep: 深度监听，为了发现**对象内部值**的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异，只有以响应式的方式触发才会被监听到。



### 计算属性 和 监听属性 的区别

1. **watch 支持异步，computed 不支持。当需要在数据变化时执行异步或开销较大的操作时，首选watch；**
2. computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听，如果需要第一次加载做监听，添加immediate属性，设置为true（immediate:true）；
3. computed中的函数必须要用return返回，watch中的函数不是必须要用return；
4. computed中的函数所依赖的属性没有发生变化，那么调用当前的函数的时候会从缓存中读取，而watch在每次监听的值发生变化的时候都会执行回调；
5. computed，当一个属性受多个属性影响的时候，建议使用computed。例如：购物车商品结算。watch，当一条数据影响多条数据的时候，建议使用watch。例如：搜索框。





## 二、插槽

在 Vue 中，插槽（Slots）是父组件将内容“注入”到子组件的另一种方式。是使用模板代码来完成的。在子组建中使用`<slot></slot>`标签，中间添加默认值，就相当于在子组件中申请了一块中间，当父组件向子组件中添加内容时，子组件就将其添加到 slot 预留的位置上。

在最终输出时，插槽的执行与 Vue 中的 prop 类似的功能：从父组件到子组件传递数据。

**prop 将数据值传递给子组件；插槽只能传递直接模板代码，**这在某些情况下有一些好处：

1. 子组件的可重用性会更好，可以将其传递给其他组件，而不必担心格式和数据的一致性。
2. 更加灵活，不必像 prop 那样总是填充每个值，在子组件使用时还要检查值是否存在；相反 slot 的可读性能能会更好，使用也更方便。



**vue的slot主要分三种：默认插槽、具名插槽、作用域插槽**



### 默认插槽

默认插槽就是一个 slot 标签，标签没有其他属性，都使用默认值。**子组件中可以有多个默认插槽，父组件填充内容时，多个插槽都会被填充。**

**子组件：**

```vue
<template>
    <div>
        <p>我是子组件</p>
        <p>
            <!-- 像这样的没有任何属性的 slot 标签就是一个默认插槽 -->
            <slot>我是插槽默认信息</slot>
        </p>
    </div>
</template>
```



**父组件：单纯的调用子组件，不向 slot 中填充内容**

```vue
<template>
  <div>
    <sub_demo></sub_demo>
  </div>
</template>
<script>
import sub_demo from "@/views/sub_demo.vue"
export default {
  components: {
    sub_demo,
  }
};
</script>
```

**结果：**

<img src="./images/frontend_007.jpg" style="float:left">



**父组件：向子组件填充内容，默认信息将不会被渲染**

```vue
<template>
  <div>
    <sub_demo>
      <p>射雕英雄传</p>
      <div>
        <em> 麻麻赖赖，呜呜咋咋。。。。</em>
      </div>
    </sub_demo>
  </div>
</template>
<script>
import sub_demo from "@/views/sub_demo.vue"
export default {
  components: {
    sub_demo,
  }
};
</script>
```

**结果：**

<img src="./images/frontend_008.jpg" style="float:left">



### 具名插槽

顾名思义，就是给子组件的插槽主动取个名字，在父组件填充内容时就可以按需填充。

注意：**具名插槽在填充内容时，必须要指定插槽名称。它不会像默认插槽那样自动填充。**

**子组件：**

```vue
<template>
  <div>
    <p>我是子组件</p>
    <p>
      <slot name="first">我是插槽默认信息 1</slot>
      <slot name="second">我是插槽默认信息 2</slot>
    </p>
  </div>
</template>
```



**父组件：**

```vue
<template>
  <div>
    <sub_demo>
      <!-- 通过 template 标签的 v-slot 属性指定填充到哪个插槽 -->
      <template v-slot:second>
        <p>《天龙八部》</p>
      </template>
      <template v-slot:first>
        <p>
          话说乔峰准备大干一场...
        </p>
      </template>
    </sub_demo>
  </div>
</template>
<script>
import sub_demo from "@/views/sub_demo.vue"
export default {
  components: {
    sub_demo,
  }
};
</script>
```



### 作用域插槽

从前面 默认插槽 和 具名插槽 可以看到，子组件的插槽只是提供了一个内容展示区，而具体的 内容、样式 都是由 父组件决定的。而 作用域插槽 的出现，就改变了这种情况，作用域插槽 允许子组件在插槽上面绑定数据，以供父组件使用。

作用域插槽 在子组件展示内容相同，仅仅是样式不同时，有很好的表现。



#### 单个插槽

**子组件：**

```vue
<template>
  <div>
    <p>我是子组件</p>
    <p>
      <!-- 子组件将数据绑定到 books 属性 -->
      <slot :books="books">我是插槽默认信息 1</slot>
    </p>
  </div>
</template>
<script>
export default {
  data() {
    return {
      books: ["天龙八部", "书剑恩仇录", "雪山飞狐", "神雕侠侣"],
    };
  }
};
</script>
```



**父组件：**

```vue
<template>
  <div>
    <sub_demo>
      <!-- 父组件通过 v-slot取到一个数据对象，下面的 “data” 是自定义的，也可以是其他任何合法的变量 -->
      <template v-slot="data">
        <!-- 子组件绑定属性 books 按如下方式获取 -->
        <p v-for="name in data.books" :key="name">{{ name }}</p>
      </template>
    </sub_demo>
  </div>
</template>
<script>
import sub_demo from "@/views/sub_demo.vue";
export default {
  components: {
    sub_demo
  }
};
</script>
```

<img src="./images/frontend_009.jpg" style="float:left">



#### 多个插槽

多个插槽时，按照单个插槽的方式同样可以取到数据对象，但是 多个 template 标签并不知道到底要填充到哪个插槽。

所以，使用 多个作用域插槽 时，还要配合 具名插槽 一起实现精准的内容填充。

**子组件：**

```vue
<template>
  <div>
    <p>我是子组件</p>
    <p>
      <slot name="book" :books="books">我是插槽默认信息 1</slot>
    </p>
    <p>
      <slot name="role" :roles="roles">我是插槽默认信息 2</slot>
    </p>
  </div>
</template>
<script>
export default {
  data() {
    return {
      books: ["天龙八部", "书剑恩仇录", "雪山飞狐", "神雕侠侣"],
      roles: ["乔峰", "书生", "胡斐", "小龙女"]
    };
  }
};
</script>
```



**父组件：**

```vue
<template>
  <div>
    <sub_demo>
      <!-- 按下面的方式 指定插槽 并获取数据对象 -->
      <template v-slot:book="data">
        <p v-for="name in data.books" :key="name">{{ name }}</p>
      </template>
			<!-- 多个 数据对象的 变量名称可以相同。因为 变量的作用域只是在它所属的 template 生效。所以下面的 data 和上面的 data 指向的是两个不同的对象 -->
      <template v-slot:role="data">
        <p v-for="name in data.roles" :key="name">{{ name }}</p>
      </template>
    </sub_demo>
  </div>
</template>
<script>
import sub_demo from "@/views/sub_demo.vue";
export default {
  components: {
    sub_demo
  }
};
</script>
```

<img src="./images/frontend_010.jpg" style="float:left; width: 40%">



## 三、vue中路由的使用步骤



## 四、vue的生命周期



## 五、深入理解 MVC、MVVM



## 六、vue双向绑定的原理



## 七、vue实现父组件向子组件传递数据



## 八、vue中如何自定义一个过滤器



## 九、如何开发一个vue插件



## 十、vue中如何实现给样式添加作用域，其实现原理是什么


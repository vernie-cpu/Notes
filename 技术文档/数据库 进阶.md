## MYSQL入门

### MYSQL 的分支、变种及替代

- Drizzle：从mysql fork 出来的，但是和mysql很不兼容。主要是用来提高数据库的可用性问题。
- MariaDB：包含了mysql所有功能，并提供更多的扩展。
- Percona Server：向后兼容mysql，提供对数据库内部执行逻辑对外开放和性能优化。
- Postgre SQL(PG)：稳定性极强，面对高并发、灾难备份等。
- SQLite：物联网数据库首选，无需启动进程就可运行。



### MYSQL 体系架构

#### 架构组件

> 在进入mysql内部之前，要依赖各种API接口，即客户端来发起链接。

- 连接池：创建链接、控制连接数、身份认证、获取用户权限、连接缓存。连接池减少链接创建、销毁的开销，提升mysql性能。
- 管理工具和服务：SQL复制、集群管理等。
- SQL接口：接收客户端的SQL语句。
- Parser：解析SQL语句，检查SQL语句的语法正确性，不正确就直接返回了。
- Optimizer：优化解析出来的SQL执行语句。例如在一个语句进行多表关联的时候，决定各个表的连接顺序。
- Caches&Buffer：5.7 以前版本，执行SQL时会默认开启查询缓存。
- 插件式引擎：mysql为操作引擎提供了统一接口，用户可根据需要使用不同的操作引擎，只要实现mysql的接口即可。当前MYSQL默认使用的引擎是InnoDB。在对表执行具体的读写操作时，会判断用户是否拥有对该表的操作权限。
- 文件与日志系统：数据库引擎的读写对象，占用磁盘空间。



#### 架构分层

- **连接层**    组件包含 连接池，主要作用是 创建新的连接线程、以及缓存已经创建好的线程；同时完成对客户端的身份认证、权限认证。

  ``` shell
  # 查看数据库配置的最大连接数
  mysql> show variables like '%max_connections%';
  +-----------------+-------+
  | Variable_name   | Value |
  +-----------------+-------+
  | max_connections | 151   |
  +-----------------+-------+
  1 row in set (0.01 sec)
  
  # 通常max_connections在小于2*CPU核数时，执行效率是最高的。
  ```

- **Server 层**	组件包含 SQL接口、Parser、Optimizer、Caches&Buffer。主要就是 接收客户端的SQL请求，完成对SQL的解析、语法检查、优化后，交给操作引擎执行语句。mysql 5.7 之后，不再默认开启缓存查询，因为 mysql 缓存采用hash映射保存，需要逐个字符检查是否命中，加之SQL语句千变万化，命中的概率更小，故在mysql 8.0 之后完全弃用了。

  ``` shell
  # 查看数据库是否开启缓存。查询版本为 5.7，缓存大小一般是 1M
  mysql> show variables like '%query_cache_type%';
  +------------------+-------+
  | Variable_name    | Value |
  +------------------+-------+
  | query_cache_type | OFF   |
  +------------------+-------+
  1 row in set (0.00 sec)
  ```

- **存储引擎层**	组件包含 引擎。这里是真正执行sql语句，读写磁盘的地方。引擎实现了对系统文件系统的具体操作。

  - InnoDB：当前默认引擎，最开始是三方引擎。擅长处理大量的短事物。
  - MyISAM：5.1 版本之前的默认引擎。
  - Archive：压缩数据保存，占用空间很小，只支持插入和查询操作。但查询时需要解压，比较费时。主要应用在日志采集方面。
  - Blackhole：不做数据保存落盘，只记录操作日志。主要用于mysql复制，不拷贝磁盘数据，而是由从库自己执行语句落盘。
  - CSV：针对csv格式文件。主要用于数据处理方面。
  - Federated：实现本地数据库 访问 远程数据库中的数据。
  - Memory：数据放到内存中，读写很快。但是没有持久化。
  - NDB集群引擎：用于mysql集群。

  ``` shell
  mysql> show engines; # 查看数据库支持哪些引擎
  +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
  | Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
  +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
  | MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
  | MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
  | CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
  | BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
  | MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
  | PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
  | ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
  | InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
  | FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
  +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
  
  mysql> show variables like '%storage_engine%'; # 查看默认使用的引擎
  +----------------------------------+--------+
  | Variable_name                    | Value  |
  +----------------------------------+--------+
  | default_storage_engine           | InnoDB |
  | default_tmp_storage_engine       | InnoDB |
  | disabled_storage_engines         |        |
  | internal_tmp_disk_storage_engine | InnoDB |
  +----------------------------------+--------+
  
  mysql> set default_storage_engine=MyISAM; #修改默认存储引擎
  Query OK, 0 rows affected (0.01 sec)
  
  mysql> show variables like '%storage_engine%';
  +----------------------------------+--------+
  | Variable_name                    | Value  |
  +----------------------------------+--------+
  | default_storage_engine           | MyISAM |
  | default_tmp_storage_engine       | InnoDB |
  | disabled_storage_engines         |        |
  | internal_tmp_disk_storage_engine | InnoDB |
  +----------------------------------+--------+
  4 rows in set (0.00 sec)
  ```
  
- MyISAM和InnoDB的比较

  <table border="1">
  <tr>
    <th width=100px>对比项</th>
    <th width=400px>MyISAM</th>
    <th>InnoDB</th>
  </tr>
  <tr>
    <td>主外键</td>
    <td>不支持</td>
    <td>支持</td>
  </tr>
  <tr>
    <td>事物</td>
    <td>不支持</td>
    <td>支持</td>
  </tr>
  <tr>
    <td>行表锁</td>
    <td>表锁，即使操作一条记录也会锁住整个表<br><font style="color:red">不适合高并发</font></td>
    <td>行锁，操作时只锁住某一行，不对其他行有影响<br><font style="color:red">适合高并发</font></td>
  </tr>
  <tr>
    <td>缓存</td>
    <td>只缓存索引，不缓存真实数据</td>
    <td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存的大小对性能有决定性影响</td>
  </tr>
  <tr>
    <td>表空间</td>
    <td>小</td>
    <td>大</td>
  </tr>
  <tr>
    <td>关注点</td>
    <td>性能</td>
    <td>事物</td>
  </tr>
  <tr>
    <td>默认安装</td>
    <td>Y</td>
    <td>Y</td>
  </tr>
  </table>

### 目录结构

- bin 目录：存放可执行文件

  - mysqld：mysqld服务器程序，用来启动mysql

  - mysqld_safe: 一个执行脚本，内部调用mysqld，同时启动一个守护进程，当主进程mysql服务挂掉后，守护进程会再起动一个，同时mysqld_safe还会主动收集错误日志。

    ``` shell
    ./bin/mysql_safe --defaults-file=/var/local/my.conf --user=mysql &
    # 指定服务启动的配置文件、启动的用户信息，后台运行
    # 变量参数分类：
    # 按性质：
    # 	静态：在服务启动时指定，服务运行过程中不允许再做修改
    #   动态：与静态相反
    # 按作用域：
    #		全局：作用于所有实例的变量。修改时加上关键子字 global。 例如：set global rootdir="/db/dir"
    # 	局部：在当前实例生效的。修改变量时，直接 set 就可以
    ```

  - mysql.server: 默认不存放在bin目录，默认放在support_files文件夹。它内部调用mysqld_safe，用于启动和关闭mysql服务

    ``` shell
    mysql.server start/stop
    ```

  - mysql_multi: 用于在同一台服务器启动多个mysql实例

  - mysqladmin：客户端程序，检查mysql服务配置等

  - mysqldump：客户端程序，实现mysql逻辑备份

- 数据目录：存放mysql数据文件，数据目录路径在服务启动时，由conf 配置文件制定的

  ``` shell
  mysql> show variables like '%datadir%';  # 查看数据目录，这是个静态变量，只能通过配置文件修改重启服务生效
  +---------------+-----------------+
  | Variable_name | Value           |
  +---------------+-----------------+
  | datadir       | /var/lib/mysql/ |
  +---------------+-----------------+
  ```

  存放数据：

  - 库在文件系统中的表示。我们每创建一个database就会在datadir目录下新增一个以database命名的文件夹。

  - 表在文件系统中的表示。在database的文件夹中，就存放了每张表的数据文件。其中 表名.frm 记录表的结构（列名、数据类型、外键信息等）。表名.ibd 存放表的数据和索引。MyISAM引擎创建的表用 表名.MYD 存储数据；表名.MYI 存储索引。

  - 数据存放位置。在mysql 5.5.8 之后，将会为每张表都创建一个独立的空间（表空间）来保存表相关数据。

  - 日志文件。包括 错误日志、慢查询日志（默认是不开启的）、查询日志（默认是不开启的，比较影响性能）。

    ``` shell
    mysql> show variables like '%log_error%';  # 此时的错误日志并没有输出到日志文件
    +---------------------+--------------+
    | Variable_name       | Value        |
    +---------------------+--------------+
    | binlog_error_action | ABORT_SERVER |
    | log_error           | stderr       |
    | log_error_verbosity | 3            |
    +---------------------+--------------+
    3 rows in set (0.00 sec)
    
    
    mysql> show variables like '%general_log%';  # 查询日志默认关闭
    +------------------+---------------------------------+
    | Variable_name    | Value                           |
    +------------------+---------------------------------+
    | general_log      | OFF                             |
    | general_log_file | /var/lib/mysql/3d84bd4ee18b.log |
    +------------------+---------------------------------+
    2 rows in set (0.00 sec)
    
    mysql> show variables like '%slow_query_log%';  # 慢查询日志
    +---------------------+--------------------------------------+
    | Variable_name       | Value                                |
    +---------------------+--------------------------------------+
    | slow_query_log      | OFF                                  |
    | slow_query_log_file | /var/lib/mysql/3d84bd4ee18b-slow.log |
    +---------------------+--------------------------------------+
    2 rows in set (0.00 sec)
    
    mysql> set global slow_query_log = ON;  # 打开慢查询日志
    Query OK, 0 rows affected (0.03 sec)
    ```

  - 二进制文件（bin log）:记录所有对mysql数据修改的操作。当进行数据库的迁移时，就是读取的 bin log日志，在新库中执行相同的数据修改操作。

### 数据库事物

> 事物是数据库管理系统(DBMS)执行过程中的一个逻辑单位（不可再进行分割），由一个有限的数据库操作序列构成（多个DML语句，select语句不包含事物），要不全部成功，要不全部不成功。

四大特性：

- **原子性（Atomicity）**：即事物是执行过程中不可以再分割的一个逻辑单位。

- **一致性（Consistency）**：保证数据的一致性，即事物修改数据前后一定是和事物的修改规则一致的。

- **持久性（Durability）**：持久性就是事物修改数据后，进行持久化保存，不会因为宕机、断电等情况丢失数据。

- **隔离性（Isolation）**：即多个事物之间，操作相同数据对象时，是想互不影响的。要实现事物的隔离，就必须要求事物的执行是串行的；但是串行执行事物，与会严重影响数据库性能。所以很多时候，会选择牺牲部分隔离性，来提升数据库性能，也因此会带来以下一些问题。

  - **脏读：**一个事物读取到了另外一个事物修改但是未提交的数据。
  - **不可重复读：**当事物内相同的记录被检索两次，且两次得到的结果不相同时，称之为不可重复读。
  - **幻读：**在事物执行过程中，另一个事物将新纪录添加到正在读取的事物中时，会发生幻读。在SQL 92 标准中，幻读是指在同一事物中，两次执行检索到的记录条数不一样（新增/减少）；而在MYSQL的标准中，幻读强调第二次检索时，检索到了第一次检索不存在的记录，而把丢失第一次检索记录归到不可重复读。

  > 事物隔离级别：
  >
  > - READ UNCOMMITED（未提交读）：可能产生 脏读、不可重复读、幻读。
  > - READ COMMITED（已提交读）：可能产生 不可重复读、幻读。
  > - REPEATABLE READ（可重复读）：SQL 92 标准中可能产生 幻读；MYSQL 标准中 已基本解决幻读。
  > - SERIALIZABLE（可串行化）：最高隔离性级别，不存在数据不安全的问题，但牺牲了数据库性能。



## MYSQL中表设计和数据类型优化

### 范式化设计

> 范式来源于英文 Normal Form，简称NF。要想设计一个好的关系，必须使关系满足一定的约束条件，此约束已经形成了规范，分成几个等级，一级比一级要求严格。满足这些规范的数据库是简洁的、结构明晰的。
>
> 六种范式：
>
> - 第一范式（1NF）
> - 第二范式（2NF）
> - 第三范式（3NF）
> - 巴斯-科德范式（BCNF）
> - 第四范式（4NF）
> - 第五范式（5NF，又称完美范式）

#### 第一范式（1NF）

- 每一列的属性都是不可再分的属性值，确保每一列的原子性；
- 两列的属性相似或相近或一样。尽量合并属性一样的列，确保不产生冗余数据；
- 单一属性的列为基本数据类型构成；
- 设计出来的表都是简单的二维表。

#### 第二范式（2NF）

- 第二范式是在第一范式的基础之上建立起来的；
- 要求实体（表）的属性完全依赖于主关键字（主键）。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体和原实体是一对多的关系。例如：订单和商品的对应关系，同一订单对应多个商品，那么就不能以 **订单编号和商品ID** 作为联合主键 来创建表；而应该把订单信息作为一张表，而订单和商品的对应关系作为另一张表。
  - 总结就是说用唯一的列作为主键，而不是多列作为联合主键。

#### 第三范式（3NF）

- 第三范式是在第二范式的基础上建立的
- 要求是一个数据表中不包含已在其他表中包含的非主键信息。即数据不能存在传递关系，每个属性都跟主键有直接关系而不是间接关系。例如：有一个商品表，记录 商品ID（主键）、商品名称。那么在订单表中，就只能出现 商品ID ，不能再出现商品名称 或只出现商品名称。

### 反范式化设计

>所谓反范式化设计，就是针对范式化设计而言的。
>
>1. 为了性能和读取效率而适当的违反数据设计范式的要求。
>2. 为了查询性能，允许存在部分冗余数据（减少联查）。换句话说，反范式设计就是使用空间换时间。

反范式优点总结：

- 性能提升-冗余、缓存和汇总
  - 冗余：将特定表中的多个属性放到另一个需要经常关联查询的表中。例如：将 商品表中的 商品名称 连通ID 一起放到订单表中，这样每次查询订单的时候就可以直接拿到商品名称，而不用关联查询。
  - 缓存：对数据库中某一字段的频繁操作，可以先缓存起来，统一写入数据库。例如：一个统计用户发送消息条数的表，那么就可以先用redis来缓存具体的条数，每隔一段时间写一次库。
  - 汇总：当经常需要对数据库表进行GRROUP BY分组统计时，可以单独在创建一张汇总表。通常都是统计报表用的比较多，且对数据的实时性要求并不高，所以通常采用定时任务的方式，按固定周期统计一次数据到汇总表。
- 性能提升-计数器表
  - 计数器表：同上面 性能提升-缓存 场景一样，如果对用户的点击数进行统计，那么应该单独创建一个计数器表，该表很小，只需要有一个 user_id 和 count 字段即可。
  - **扩展**：如果要统计全站的点击数，在不使用redis缓存的场景下，表中某一行的将成为巨量用户修改的hotkey，此时如果采用行锁，将很影响性能。此时采用 热点分散 的思想，在计数器表中，创建一万个统计行，每个用户更新数据时，更新任意一行即可。而要得到全站的点击数，只需要统计这一万行的总数即可。
- 反范式设计-分库分表中的查询
  - 分库分表中的反范式：比如：电商网站中，分别以买家和卖家的为度查询商品信息，此时以任意一方的为度去保存商品信息，都会很影响对方对数据的统计查询。所以此时干脆将商品信息案卖家和买家为度各创建一张表，将原来的一张商品信息表，根据卖家、买家的相关属性拆分成两张表。











## 常见问题解答

### 一、如何排查数据库慢的原因

### 二、 如何优化慢查询语句

### 三、SELECT 查询语句中各子句的执行顺序

SQL 查询的大致语法结构如下：

``` sql
# 语句前的序号表示子句执行的先后顺序
(5)SELECT DISTINCT <select_list>                     
(1)FROM <left_table> <join_type> JOIN <right_table> ON <on_predicate>
(2)WHERE <where_predicate>
(3)GROUP BY <group_by_specification>
(4)HAVING <having_predicate>
(6)ORDER BY <order_by_list>
(7)LIMIT n, m

# 具体的关键字执行顺序如下，这些步骤执行时，每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。
# 这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只是最后一步生成的表才会返回给调用者。
# 如果没有在查询中指定某一子句，将跳过相应的步骤。
FROM
ON 
JOIN 
WHERE 
GROUP BY 
HAVING 
SELECT
DISTINCT 
ORDER BY 
LIMIT
```

**执行步骤详解：**

- **一、FROM阶段**

  FROM阶段标识出查询的来源表，并处理表运算符。在涉及到联接运算的查询中（各种JOIN），主要有以下几个步骤：

  - **求笛卡尔积**。不论是什么类型的联接运算，首先都是执行交叉连接（CROSS JOIN），求笛卡儿积（Cartesian product），生成虚拟表VT1-J1。
  - **ON筛选器**。 这个阶段对上个步骤生成的VT1-J1进行筛选，根据ON子句中出现的谓词进行筛选，让谓词取值为true的行通过了考验，插入到VT1-J2。
  - **添加外部行**。如果指定了OUTER JOIN，如LEFT OUTER JOIN、RIGHT OUTER JOIN，还需要将VT1-J2中没有找到匹配的行，作为外部行添加到VT1-J2中，生成VT1-J3。如果FROM子句包含两个以上表，则对上一个连接生成的结果表VT1-J3和下一个表重复依次执行3个步骤，直到处理完所有的表为止。

  经过以上步骤，FROM阶段就完成了。

- **二、WHERE阶段**

  WHERE阶段是根据<where_predicate>中条件对VT1中的行进行筛选，让条件成立的行才会插入到VT2中。**此时数据还没有分组，所以不能在WHERE中出现对统计的过滤。**

- **三、GROUP BY阶段**

  GROUP阶段按照指定的列名列表，将VT2中的行进行分组，生成VT3。最后每个分组只有一行。**在GROUP BY阶段，数据库认为两个NULL值是相等的，因此会将NULL值分到同一个分组中。**

- **四、HAVING阶段**

  该阶段根据HAVING子句中出现的谓词对VT3的分组进行筛选，并将符合条件的组插入到VT4中。**COUNT(expr) 会返回expr不为NULL的行数，count(1)、count(\*)会返回包括NULL值在内的所有数量。**

- **五、SELECT阶段**

  这个阶段是投影的过程，处理SELECT子句提到的元素，产生VT5。这个步骤一般按下列顺序进行：

  - 计算SELECT列表中的表达式，生成VT5-1。
  - 若有DISTINCT，则删除VT5-1中的重复行，生成VT5-2。

- **六、ORDER BY阶段**

  根据ORDER BY子句中指定的列明列表，对VT5-2中的行，进行排序，生成VT6。**如果不指定排序，数据并非总是按照主键顺序进行排序的。NULL被视为最小值。**

- **七、LIMIT阶段**

  取出指定行的记录，产生虚拟表VT7，并返回给查询用户。**LIMIT n, m的效率是十分低的，一般可以通过在WHERE条件中指定范围来优化 \**WHERE\** id > ? limit 10。**


## MYSQL入门

### MYSQL 的分支、变种及替代

- Drizzle：从mysql fork 出来的，但是和mysql很不兼容。主要是用来提高数据库的可用性问题。
- MariaDB：包含了mysql所有功能，并提供更多的扩展。
- Percona Server：向后兼容mysql，提供对数据库内部执行逻辑对外开放和性能优化。
- Postgre SQL(PG)：稳定性极强，面对高并发、灾难备份等。
- SQLite：物联网数据库首选，无需启动进程就可运行。



### MYSQL 体系架构

#### 架构组件

> 在进入mysql内部之前，要依赖各种API接口，即客户端来发起链接。

- 连接池：创建链接、控制连接数、身份认证、获取用户权限、连接缓存。连接池减少链接创建、销毁的开销，提升mysql性能。
- 管理工具和服务：SQL复制、集群管理等。
- SQL接口：接收客户端的SQL语句，保存 存储过程、视图、触发器等。
- Parser：解析SQL语句，检查SQL语句的语法正确性，不正确就直接返回了。
- Optimizer：优化解析出来的SQL执行语句。例如在一个语句进行多表关联的时候，决定各个表的连接顺序。
- Caches&Buffer：5.7 以前版本，执行SQL时会默认开启查询缓存。
- 插件式引擎：mysql为操作引擎提供了统一接口，用户可根据需要使用不同的操作引擎，只要实现mysql的接口即可。当前MYSQL默认使用的引擎是InnoDB。在对表执行具体的读写操作时，会判断用户是否拥有对该表的操作权限。
- 文件与日志系统：数据库引擎的读写对象，占用磁盘空间。



#### 架构分层

- **连接层**    组件包含 连接池，主要作用是 创建新的连接线程、以及缓存已经创建好的线程；同时完成对客户端的身份认证、权限认证。

  ``` shell
  # 查看数据库配置的最大连接数
  mysql> show variables like '%max_connections%';
  +-----------------+-------+
  | Variable_name   | Value |
  +-----------------+-------+
  | max_connections | 151   |
  +-----------------+-------+
  1 row in set (0.01 sec)
  
  # 通常max_connections在小于2*CPU核数时，执行效率是最高的。
  ```

- **Server 层**	组件包含 SQL接口、Parser、Optimizer、Caches&Buffer。主要就是 接收客户端的SQL请求，完成对SQL的解析、语法检查、优化后，交给操作引擎执行语句。mysql 5.7 之后，不再默认开启缓存查询，因为 mysql 缓存采用hash映射保存，需要逐个字符检查是否命中，加之SQL语句千变万化，命中的概率更小，故在mysql 8.0 之后完全弃用了。

  ``` shell
  # 查看数据库是否开启缓存。查询版本为 5.7，缓存大小一般是 1M
  mysql> show variables like '%query_cache_type%';
  +------------------+-------+
  | Variable_name    | Value |
  +------------------+-------+
  | query_cache_type | OFF   |
  +------------------+-------+
  1 row in set (0.00 sec)
  ```

- **引擎层**	组件包含 引擎。这里是真正执行sql语句，读写磁盘的地方。引擎实现了对系统文件系统的具体操作。

  - InnoDB：5.5 版本之后的默认引擎，最开始是三方引擎。擅长处理大量的短事物。
  - MyISAM：5.5 版本之前的默认引擎。
  - Archive：压缩数据保存，占用空间很小，只支持插入和查询操作。但查询时需要解压，比较费时。主要应用在日志采集方面。
  - Blackhole：不做数据保存落盘，只记录操作日志。主要用于mysql复制，不拷贝磁盘数据，而是由从库自己执行语句落盘。
  - CSV：针对csv格式文件。主要用于数据处理方面。
  - Federated：实现本地数据库 访问 远程数据库中的数据。
  - Memory：数据放到内存中，读写很快。但是没有持久化。
  - NDB集群引擎：用于mysql集群。

  ``` shell
  mysql> show engines; # 查看数据库支持哪些引擎
  +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
  | Engine             | Support | Comment                                                        | Transactions | XA   | Savepoints |
  +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
  | MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables      | NO           | NO   | NO         |
  | MRG_MYISAM         | YES     | Collection of identical MyISAM tables                          | NO           | NO   | NO         |
  | CSV                | YES     | CSV storage engine                                             | NO           | NO   | NO         |
  | BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears) | NO           | NO   | NO         |
  | MyISAM             | YES     | MyISAM storage engine                                          | NO           | NO   | NO         |
  | PERFORMANCE_SCHEMA | YES     | Performance Schema                                             | NO           | NO   | NO         |
  | ARCHIVE            | YES     | Archive storage engine                                         | NO           | NO   | NO         |
  | InnoDB             | DEFAULT | Supports transactions, row-level locking, and foreign keys     | YES          | YES  | YES        |
  | FEDERATED          | NO      | Federated MySQL storage engine                                 | NULL         | NULL | NULL       |
  +--------------------+---------+----------------------------------------------------------------+--------------+------+------------+
  
  mysql> show variables like '%storage_engine%'; # 查看默认使用的引擎
  +----------------------------------+--------+
  | Variable_name                    | Value  |
  +----------------------------------+--------+
  | default_storage_engine           | InnoDB |
  | default_tmp_storage_engine       | InnoDB |
  | disabled_storage_engines         |        |
  | internal_tmp_disk_storage_engine | InnoDB |
  +----------------------------------+--------+
  
  mysql> set default_storage_engine=MyISAM; #修改默认存储引擎
  Query OK, 0 rows affected (0.01 sec)
  
  mysql> show variables like '%storage_engine%';
  +----------------------------------+--------+
  | Variable_name                    | Value  |
  +----------------------------------+--------+
  | default_storage_engine           | MyISAM |
  | default_tmp_storage_engine       | InnoDB |
  | disabled_storage_engines         |        |
  | internal_tmp_disk_storage_engine | InnoDB |
  +----------------------------------+--------+
  4 rows in set (0.00 sec)
  ```
  
- MyISAM和InnoDB的比较

  <table border="1">
  <tr>
    <th width=100px>对比项</th>
    <th width=400px>MyISAM</th>
    <th>InnoDB</th>
  </tr>
  <tr>
    <td>外键</td>
    <td>不支持</td>
    <td>支持</td>
  </tr>
  <tr>
    <td>事物</td>
    <td>不支持</td>
    <td>支持</td>
  </tr>
  <tr>
    <td>行表锁</td>
    <td>表锁，即使操作一条记录也会锁住整个表<br><font style="color:red">不适合高并发</font></td>
    <td>行锁，操作时只锁住某一行，不对其他行有影响<br><font style="color:red">适合高并发</font></td>
  </tr>
  <tr>
    <td>缓存</td>
    <td>只缓存索引，不缓存真实数据</td>
    <td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存的大小对性能有决定性影响</td>
  </tr>
  <tr>
    <td>表空间</td>
    <td>小</td>
    <td>大</td>
  </tr>
  <tr>
    <td>关注点</td>
    <td>性能</td>
    <td>事物</td>
  </tr>
  <tr>
    <td>默认安装</td>
    <td>Y</td>
    <td>Y</td>
  </tr>
  </table>
  
- **存储层**

  数据存储层，主要是将数据存储在文件系统之上，并完成与存储引擎的交互。



### 目录结构

- bin 目录：存放可执行文件

  - mysqld：mysqld服务器程序，用来启动mysql

  - mysqld_safe: 一个执行脚本，内部调用mysqld，同时启动一个守护进程，当主进程mysql服务挂掉后，守护进程会再起动一个，同时mysqld_safe还会主动收集错误日志。

    ``` shell
    ./bin/mysql_safe --defaults-file=/var/local/my.conf --user=mysql &
    # 指定服务启动的配置文件、启动的用户信息，后台运行
    # 变量参数分类：
    # 按性质：
    # 	静态：在服务启动时指定，服务运行过程中不允许再做修改
    #   动态：与静态相反
    # 按作用域：
    #		全局：作用于所有实例的变量。修改时加上关键子字 global。 例如：set global rootdir="/db/dir"
    # 	局部：在当前实例生效的。修改变量时，直接 set 就可以
    ```

  - mysql.server: 默认不存放在bin目录，默认放在support_files文件夹。它内部调用mysqld_safe，用于启动和关闭mysql服务

    ``` shell
    mysql.server start/stop
    ```

  - mysql_multi: 用于在同一台服务器启动多个mysql实例

  - mysqladmin：客户端程序，检查mysql服务配置等

  - mysqldump：客户端程序，实现mysql逻辑备份

- 数据目录：存放mysql数据文件，数据目录路径在服务启动时，由conf 配置文件制定的

  ``` shell
  mysql> show variables like '%datadir%';  # 查看数据目录，这是个静态变量，只能通过配置文件修改重启服务生效
  +---------------+-----------------+
  | Variable_name | Value           |
  +---------------+-----------------+
  | datadir       | /var/lib/mysql/ |
  +---------------+-----------------+
  ```

  存放数据：

  - 库在文件系统中的表示。我们每创建一个database就会在datadir目录下新增一个以database命名的文件夹。

  - 表在文件系统中的表示。在database的文件夹中，就存放了每张表的数据文件。其中 表名.frm 记录表的结构（列名、数据类型、外键信息等）。表名.ibd 存放表的数据和索引。MyISAM引擎创建的表用 表名.MYD 存储数据；表名.MYI 存储索引。

  - 数据存放位置。在mysql 5.5.8 之后，将会为每张表都创建一个独立的空间（表空间）来保存表相关数据。

  - 日志文件。包括 错误日志、慢查询日志（默认是不开启的）、查询日志（默认是不开启的，比较影响性能）。

    ``` shell
    mysql> show variables like '%log_error%';  # 此时的错误日志并没有输出到日志文件
    +---------------------+--------------+
    | Variable_name       | Value        |
    +---------------------+--------------+
    | binlog_error_action | ABORT_SERVER |
    | log_error           | stderr       |
    | log_error_verbosity | 3            |
    +---------------------+--------------+
    3 rows in set (0.00 sec)
    
    
    mysql> show variables like '%general_log%';  # 查询日志默认关闭
    +------------------+---------------------------------+
    | Variable_name    | Value                           |
    +------------------+---------------------------------+
    | general_log      | OFF                             |
    | general_log_file | /var/lib/mysql/3d84bd4ee18b.log |
    +------------------+---------------------------------+
    2 rows in set (0.00 sec)
    
    mysql> show variables like '%slow_query_log%';  # 慢查询日志
    +---------------------+--------------------------------------+
    | Variable_name       | Value                                |
    +---------------------+--------------------------------------+
    | slow_query_log      | OFF                                  |
    | slow_query_log_file | /var/lib/mysql/3d84bd4ee18b-slow.log |
    +---------------------+--------------------------------------+
    2 rows in set (0.00 sec)
    
    mysql> set global slow_query_log = ON;  # 打开慢查询日志
    Query OK, 0 rows affected (0.03 sec)
    ```

  - 二进制文件（bin log）:记录所有对mysql数据修改的操作。当进行数据库的迁移时，就是读取的 bin log日志，在新库中执行相同的数据修改操作。



## MYSQL中表设计和数据类型优化

### 范式化设计

> 范式来源于英文 Normal Form，简称NF。要想设计一个好的关系，必须使关系满足一定的约束条件，此约束已经形成了规范，分成几个等级，一级比一级要求严格。满足这些规范的数据库是简洁的、结构明晰的。
>
> 六种范式：
>
> - 第一范式（1NF）
> - 第二范式（2NF）
> - 第三范式（3NF）
> - 巴斯-科德范式（BCNF）
> - 第四范式（4NF）
> - 第五范式（5NF，又称完美范式）

#### 第一范式（1NF）

- 每一列的属性都是不可再分的属性值，确保每一列的原子性；
- 两列的属性相似或相近或一样。尽量合并属性一样的列，确保不产生冗余数据；
- 单一属性的列为基本数据类型构成；
- 设计出来的表都是简单的二维表。

#### 第二范式（2NF）

- 第二范式是在第一范式的基础之上建立起来的；
- 要求实体（表）的属性完全依赖于主关键字（主键）。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体和原实体是一对多的关系。例如：订单和商品的对应关系，同一订单对应多个商品，那么就不能以 **订单编号和商品ID** 作为联合主键 来创建表；而应该把订单信息作为一张表，而订单和商品的对应关系作为另一张表。
  - 总结就是说用唯一的列作为主键，而不是多列作为联合主键。

#### 第三范式（3NF）

- 第三范式是在第二范式的基础上建立的
- 要求是一个数据表中不包含已在其他表中包含的非主键信息。即数据不能存在传递关系，每个属性都跟主键有直接关系而不是间接关系。例如：有一个商品表，记录 商品ID（主键）、商品名称。那么在订单表中，就只能出现 商品ID ，不能再出现商品名称 或只出现商品名称。

### 反范式化设计

>所谓反范式化设计，就是针对范式化设计而言的。
>
>1. 为了性能和读取效率而适当的违反数据设计范式的要求。
>2. 为了查询性能，允许存在部分冗余数据（减少联查）。换句话说，反范式设计就是使用空间换时间。

反范式优点总结：

- 性能提升-冗余、缓存和汇总
  - 冗余：将特定表中的多个属性放到另一个需要经常关联查询的表中。例如：将 商品表中的 商品名称 连通ID 一起放到订单表中，这样每次查询订单的时候就可以直接拿到商品名称，而不用关联查询。
  - 缓存：对数据库中某一字段的频繁操作，可以先缓存起来，统一写入数据库。例如：一个统计用户发送消息条数的表，那么就可以先用redis来缓存具体的条数，每隔一段时间写一次库。
  - 汇总：当经常需要对数据库表进行GRROUP BY分组统计时，可以单独在创建一张汇总表。通常都是统计报表用的比较多，且对数据的实时性要求并不高，所以通常采用定时任务的方式，按固定周期统计一次数据到汇总表。
- 性能提升-计数器表
  - 计数器表：同上面 性能提升-缓存 场景一样，如果对用户的点击数进行统计，那么应该单独创建一个计数器表，该表很小，只需要有一个 user_id 和 count 字段即可。
  - **扩展**：如果要统计全站的点击数，在不使用redis缓存的场景下，表中某一行的将成为巨量用户修改的hotkey，此时如果采用行锁，将很影响性能。此时采用 热点分散 的思想，在计数器表中，创建一万个统计行，每个用户更新数据时，更新任意一行即可。而要得到全站的点击数，只需要统计这一万行的总数即可。
- 反范式设计-分库分表中的查询
  - 分库分表中的反范式：比如：电商网站中，分别以买家和卖家的为度查询商品信息，此时以任意一方的为度去保存商品信息，都会很影响对方对数据的统计查询。所以此时干脆将商品信息案卖家和买家为度各创建一张表，将原来的一张商品信息表，根据卖家、买家的相关属性拆分成两张表。



### 数据类型优化

> MySQL支持的数据类型非常多，选择正确的数据类型对于获得高性能至关重要。不管存储那种类型的数据，下面几个原则都有助于做出更好的选择。
>
> - **更小的通常更好**
>
>   一般情况下，应该尽量使用可以正确存储数据的最小数据类型（例如只需要存0-200，tinyint unsigned更好）。更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少。
>
> - **简单就好**
>
>   简单数据类型的操作通常需要更少的CPU周期。例如，**整型比字符操作代价更低**，因为字符集和校对规则（排序规则）是字符串比较比整型比较更复杂。这里有两个例子：一个是应该用MySQL内建的类型（比如date,time,datetime）而不是字符串来存储日期时间，另外一个是应该用整型来存储IP地址。
>
> - **尽量避免使用NULL**
>
>   很多表都包含了可为NULL的列，即使应用程序不需要保存NULL也是如此，这是因为可为NULL是列的默认属性。通常情况下最好指定列为NOT NULL，除非真的需要存储NULL值。
>
>   如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。可为NULL的列会使用更多的存储空间，在MySQL里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节，在MyISAM中甚至还可能导致固定大小的索引（例如只有一个整数列的索引）变成可变大小的索引。
>
>   通常把可为NULL的值改为NOT NULL带来的性能提升比较小，所以（调优时）没有必要首先在现有的schema中查找并修改掉这种情况，除非确定这会导致问题。但是，如果计划在列上建立索引，就应该避免设计成可为NULL的列。
>
>   **当然也有例外，例如值得一提的是，InnoDB使用单独的位（bit）存储NULL值，所以对于稀疏数据（大部分值为NULL，只有少数行为非NULL的值）有良好的空间效率。但这一点不适用于MyISAM。**



#### 整数类型

整数类型：TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT。分别使用8,16,24,32,64位存储空间。它们的存储范围从 -2的(N-1)次方 到 2的(N-1)次方-1，其中N为存储空间的位数。

整数类型有可选的 **UNSIGNED** 属性，表示不允许负值，这大致可以使正数的上限提高一倍，例如TINYINT UNSIGNED可以存储的范围是0-255，而TINYINT 的存储范围是-128~127。

MySQL可以为整数类型指定宽度，例如INT(11)，对大多数应用这是没有意义的：他不会限制值的合法范围，只是规定了MySQL的一些交互工具（例如MySQL命令行客户端）用来显示字符的个数。对于存储来说，INT(1)和INT(20)是相同的。



#### 实数类型

实数是带有小数部分的数字。然而，它们不只是为了存储小数部分，也可以使用DECIMAL存储比BIGINT还大的整数。MySQL既支持精确类型，也支持不精确类型。

FLOAT 和 DOUBLE 类型支持使用标准的浮点运算进行近似计算。如果需要知道浮点运算时怎么计算的，则需要研究所使用的平台的浮点数的具体实现。

DECIMAL 类型用于存储精确的小数。但因为CPU不支持对DECIMAL的直接计算，所以在MySQL5.0及更高版本中，MySQL服务器自身实现了DECIMAL的高精度计算。相对而言，这比CPU直接支持原生浮点数运算要慢。

浮点和DECIMAL类型都可以指定精度。对于DECIMAL列，可以指定小数点前后所允许的最大位数。这会影响列的空间消耗。DECIMAL最大保存65个数字，本质是以字符形式保存的。

**浮点类型在存储同样范围的值时，通常比DECIMAL使用更少的空间。FLOAT使用4个字节存储，DOUBLE占用8个字节，相比FLOAT有更高的精度和更大的范围。**

因为需要额外的空间和计算开销，所以应该尽量只在对小数进行精确计算时才使用DECIMAL——例如存储财务数据。但数据量比较大的时候，可以考虑使用BIGINT代替DECIMAL，将需要存储的货币单位根据小数点的位数乘以相应的倍数即可。假设要存储财务数据精确到万分之一分，则可以把所有金额乘以100W，然后将结果存储在BIGINT里，这样可以同时避免浮点存储计算不精确和DECIMAL精确计算代价高的问题。



#### 字符串类型

下面的描述假设使用的存储引擎是InnoDB/或者MyISAM。如果不是这两种存储引擎的，请参考所使用的存储引擎的文档。

- **VARCHAR和CHAR**

  - **VARCHAR:** 它比定长类型更节省空间，因为它仅使用必要的空间。VARCHAR节省了空间，所以对性能也有帮助。但是由于行是变长的，在UPDATE时可能使行变得比原来更长，这就导致需要做额外的工作。

    下面的情况使用VARCHAR是合适的：字符串最大长度比平均长度大很多；列的更新少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符使用不同的字节数。

    在5.0或更高的版本中，MySQL在存储和检索时会保留末尾空格。InnoDB则更灵活，它可以把长的VARCHAR存储为BLOB。

  - **CHAR: **定长，当存储CHAR值时，MySQL会删除所有的末尾空格。定长的CHAR类型不容易产生碎片，对于非常短的列，CHAR比VARCHAR在存储空间上也更有效率，VACHAR还有一个或两个记录长度的额外字节。CHAR适合存储很短的字符串，或者所有值都接近同一个长度。例如：**CHAR非常适合存储密码的MD5值，因为这是一个定长的值。CHAR会根据需要采用空格填充以方便比较。**

  与CHAR和VARCHAR类似的类型还有BINARY和VARBINARY，它们存储的是二进制字符串。二进制字符串中存储的是字节码而不是字符。

  二进制比较的优势并不仅仅体现在大小写敏感上。MySQL比较BINARY字符串是，每次按一个字节，并且根据该字节的数值进行比较。因此，二进制比字符比较简单的多，所以也就更快。

- **BLOB 和 TEXT类型**

  BLOB和TEXT类型：BLOB和TEXT都是为了存储很大的数据而设计的字符串数据类型，分别采用**二进制**和**字符**方式存储。当BLOB和TEXT值太大时，InnoDB会使用专门的”外部”存储区域来进行存储。原表字段存储指针指向外部存储区域。

  MySQL对BLOB和TEXT列进行排序与其他类型是不同的：它只对列最前`max_sort_length` 字节而不是整个字符串做排序。如果只需要排序前面一小部分字符，则可以减小`max_sort_length` 的配置，或者使用`ORDER BY SUSTRING(column, length)`。

  MySQL不能将BLOB和TEXT列全部长度的字符串进行索引，也不能使用这些索引消除排序。

  ``` mysql
  # 创建表。这里指定max_sort_length为10。blob和text类型不能有默认值
  # 通常在有bolb、text类型的字段单独放在一张表，同时再新增一个hash_value列，用于数据查找。
  create table demo_blob (
  `id` int unsigned auto_increment,
  `content` blob(10),
  `hash_value` char,
  primary key (`id`)
  )engine=InnoDB charset=UTF8;
  
  # 插入数据
  INSERT into demo_blob(content, hash_value) values ('大概撒加好多个洒脱的嘎世界各地呀个撒娇的嘎升级换代撒回家的规划', md5(content)); 
  
  # 查询数据
  select * from flask.demo_blob db where db.hash_value = md5('大概撒加好多个洒脱的嘎世界各地呀个撒娇的嘎升级换代撒回家的规划');
  ```

  

- **使用枚举（ENUM）代替字符串类型**

  可以使用枚举（ENUM）代替字符串类型。很多时候建议使用枚举列代替常用的字符串类型。

  （1）枚举列可以把一些不重复的字符串存储成一个预定义的集合。
  （2）Mysql在存储枚举时非常紧凑，会根据列表值的数量压缩到一到两个字节中。
  （3）Mysql在内部会将每个值在列表中的位置保存为整数，并且在表的.frm文件中保存“数字-字符串”映射关系的“查找表”。

  <font style="color:red">注意：有一个令人吃惊的地方是，枚举字段是按照内部存储的整数而不是定义的字符串进行排序的。</font>

  <font style="color:red">注意：枚举最不好的地方是：字符串列表是固定的，添加或者删除字符串必须使用ALTER TABLE，因此对于一系列未来可能会改变的字符串，使用枚举并不是一个好主意，除非接受只能在列表末尾添加元素。</font>

  <font style="color:red">注意：由于Mysql把每个枚举值保存为整数，并且必须进行查找才能转换为字符串，所以枚举列有一些额外开销。</font>

  ``` mysql
  # 创建表
  create table demo_enum(
  `id` int unsigned auto_increment,
  `sex` enum('男','女'),
  primary key (`id`)
  )engine=InnoDB charset=UTF8;
  
  # 插入数据时，可以插入原始字符，也可以插入enum中字符的位置参数，从1开始
  insert into demo_enum(sex) values ('男'), (2);
  ```

  

#### 日期时间类型

> 数据类型及用法详见 ： http://blog.csdn.net/qq_28602957/article/details/54670699
>
> Mysql有很多类型可以保存日期和时间值，比如YEAR和DATE。
>
> Mysql能存储的最小时间粒度为秒（MariaDB支持微秒级别的事件类型）。但是Mysql也可以使用微秒级别的粒度进行临时运算。
>
> 大部分时间类型都没有替代品，因此没有什么是最佳选择的问题。
>
> 接下来唯一的问题是保存日期和时间的时候需要做什么。

- **DATETIME**
  - （1）这个类型能保存大范围的值，从1001年到9999年，精度为秒。 
  - （2）DATETIME把时间和日期封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关。 
  - （3）DATETIME使用8个字节的存储空间。

- **TIMESTAMP**
  - （1）TIMESTAMP类型保存了从1970年1月1日午夜以来的秒数，它和UNIX时间戳相同。 
  - （2）TIMESTAMP只使用4个字节的存储空间，因此**它的范围比DATETIME小得多**。 
  - （3）TIMESTAMP显示的值依赖时区。

  ``` mysql
  CREATE TABLE demo_time(
  `id` INT PRIMARY KEY,
  `date` TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );
  ```

- **DATETIME和TIMESTAMP的对比:**
  - （1）默认情况下，如果插入时没有指定第一个TIMESTAMP列的值，Mysql则设置这个列的值为当前时间。（这是DATETIME没有的特性）
  - （2）在插入一行记录时，Mysql默认也会更新第一个TIMESTAMP列的值。 
  - （3）TIMESTAMP列默认为NOT NULL，这与其他的数据类型不一样。

**总结**

- （1）除了特殊行为之外，通常也应该尽可能使用TIMESTAMP，因为它比DATETIME空间效率更高。 
- （2）一般来讲不建议把UNIX时间戳保存为整数值，这不会带来任何收益，用整数保存时间戳格式通常不方便处理。 
- （3）如果需存储比秒更小粒度的日期和时间值，可以使用BIGINT类型存储微秒级别的时间戳，或者使用DOUBLE存储秒之后的小数部分，也可以用MariaDB替代Mysql。



#### 位数据类型

> MySQL有少数几种存储类型使用紧凑的位存储数据。所有这些位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型的。

- BIT

  可以使用BIT列在一列中存储一个或多个true/false值。BIT(1)定义了一个包含单个位的字段，BIT(2)存储2个位，依次类推。BIT列的最大长度是64位。

  如果想在一个bit的存储空间中存储一个true/false值，另一个方法是创建一个可以为空的CHAR(0)列。该列可以保存空值(NULL)或者长度为零的字符串(空字符串)。

- SET

  如果需要保存很多true/false 值，可以考虑合并这些列到一个SET 数据类型，它在MySQL 内部是以一系列打包的位的集合来表示的。这样就有效地利用了存储空间，并且MySQL 有像FIND_IN_SET（） 和FIELD（） 这样的函数，方便地在查询中使用。它的主要缺点是改变列的定义的代价较高：需要ALTER TABLE,这对大表来说是非常昂贵的操作。一般来说，也无法在SET 列上通过索引查找。

  **一种替代SET 的方式是使用一个整数包装一系列的位。例如，可以把8 个位包装到一个TINYINT 中，并且按位操作来使用。可以在应用中为每个位定义名称常量来简化这个工作。**

  比起SET,这种办法主要的好处在于可以不使用ALTER TABLE 改变字段代表的”枚举”值，缺点是查询语句更难写，并且更难理解（当第5 个bit 位被设置时是什么意思？）。一些人非常适应这种方式，也有一些人不适应，所以是否采用这种技术取决于个人的偏好。



#### 选择标识符（identifier）

> 为identifier（标识列）选择合适的数据类型非常重要。
>
> 一般来讲更有可能用标识列与其他值进行比较，或者通过标识列寻找其他列。
>
> 当选择标识列的类型时，不仅仅需要考虑存储类型，还需要考虑Mysql对这种类型怎么执行计算和比较。
>
> 一旦选定了一种类型，要确保在所有关联表中都使用同样的类型。
>
> 在可以满足值的范围需求，并且预留未来增长空间的前提下，应该选择最小的数据类型。

- 整数通常是标识列最好的选择，因为它们很快而且可以使用`AUTO_INCREMENT`。
- ENUM和SET是最糟糕的选择了。
- 如果可能也尽可能避免使用字符串作为标识列，因为它们很消耗空间并且通常比数字类慢。



#### 特殊类型数据

某些类型的数据并不直接与内置类型一致。低于**秒级精度的时间戳**就是一个例子。

另一个例子是人们通常使用VARCHAR(15)来存储IP地址。然而，它们实际是32位无符号整数，不是字符串。用小数点将字段分割成四段是为了阅读方便。所以**应该用无符号整数存储IP地址**。MySQL提供`INET_ATON()`和`INET_NTOA()`函数在这两种表示方法之间转换。





## MYSQL精讲

### 变量

- 变量类型

  - 用户变量：以"@"开始，形式为"@变量名"。用户变量跟mysql客户端是绑定的，设置的变量，只对当前用户使用的客户端生效。
  - 全局变量：定义时，以如下两种形式出现，set GLOBAL 变量名 或者 set @@global.变量名，对所有客户端生效。只有具有super权限才可以设置全局变量。
  - 会话变量：是指当前建立会话中的变量，它包含全局变量。修改变量使用 set @@变量名，修改后仅对当前客户端生效。
  - 局部变量：作用范围在begin到end语句块之间。在该语句块里设置的变量。declare语句专门用于定义局部变量。set语句是设置不同类型的变量，包括会话变量和全局变量。

- 变量赋值

  - = 号赋值。= 仅在关键字 set 后面才表示赋值，其他场景均作为 逻辑判断 符号。

    ```mysql
    set @aa = 3;
    ```

  - := 赋值。mysql中，通用的赋值符号。

    ```mysql
    set @bb := 5;
    select @cc := 10;
    ```

    

### 外键

> 1. MySQL中“键”和“索引”的定义相同，所以外键和主键一样也是索引的一种，MySQL会自动为所有表的主键进行索引。外键列也要求必须建立索引，MySQL 4.1.2以后的版本在建立外键时会自动创建索引，但如果在较早的版本则需要显示建立。
>
> 2. 外键可以是一对一的，或者一对多的。
> 3. 外键关系的两个表的列必须是数据类型相似，也就是可以相互转换类型的列，比如int和tinyint可以，而int和char则不可以。
>
> 4. 如果需要更好的性能，并且不需要完整性检查，可以选择使用MyISAM表类型，如果想要在MySQL中根据参照完整性来建立表并且希望在此基础上保持良好的性能，最好选择表结构为InnoDB类型。

语法：

```mysql
# 外键语法在create table 和 alter table 时使用
[CONSTRAINT symbol] FOREIGN KEY [id] (index_col_name, ...)
REFERENCES tbl_name (index_col_name, ...)  # 把references指向的表称为主表
[ON DELETE {RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT}]
[ON UPDATE {RESTRICT | CASCADE | SET NULL | NO ACTION | SET DEFAULT}]

# ON DELETE、ON UPDATE表示事件触发限制，可设参数：

# RESTRICT（限制主表中有关联外键的列的改动）
# CASCADE（跟随外键改动）
# SET NULL（设空值）
# SET DEFAULT（设默认值）
# NO ACTION（无动作，默认的）
```

示例：

```mysql
# 创建主表
create table `dage` (
	`id` int unsigned auto_increment,
	`name` varchar(20) not null,
	primary key (`id`)
)engine=InnoDB default charset=utf8;

# 创建外键表。constraint 相当于给外键取了一个别名，如果不指定，mysql将自动生成一个。
create table `xiaodi` (
	`id` int unsigned auto_increment,
	`name` varchar(20) not null,
	`dage_id` int unsigned not null,  # 外键字段类型要和主表的字段保持一致
	primary key (`id`),
	constraint `fk_xd_dg` foreign key (`dage_id`) references `dage` (`id`) on update cascade on delete restrict
)engine=InnoDB default charset=utf8;


# 插入数据
insert into dage(name) values ('yanguo');
insert into xiaodi(name, dage_id) values('xuzu', 1);

# 根据表创建的外键约束。更新主表的信息时，从表也会跟随更新
update dage set id = 3 where id =1;
mysql> select * from xiaodi;
+----+------+---------+
| id | name | dage_id |
+----+------+---------+
|  1 | xuzu |       3 |
+----+------+---------+
1 row in set (0.00 sec)

# 此时如果删除主表的数据，将会报错。因为外键约束中 on delete 是 restrict
mysql> delete from dage where id = 3;
ERROR 1451 (23000): Cannot delete or update a parent row: a foreign key constraint fails (`demo_01`.`xiaodi`, CONSTRAINT `fk_xd_dg` FOREIGN KEY (`dage_id`) REFERENCES `dage` (`id`) ON UPDATE CASCADE)

# 把外键的约束修改成cascade，就可以删除主表的数据了，但同时也会删除掉外键表中的数据
alter table `xiaodi` drop foreign key fk_xd_dg;
alter table `xiaodi` add constraint `fk_xd_dg` foreign key (`dage_id`) references `dage` (`id`) on update cascade on delete cascade;

mysql> select * from xiaodi;
Empty set (0.00 sec)
```



### 事物

> 事物是数据库管理系统(DBMS)执行过程中的一个逻辑单位（不可再进行分割），由一个有限的数据库操作序列构成（多个DML语句，select语句不包含事物），要不全部成功，要不全部不成功。
>
> 在musql中事物是默认提交的，如果需要控制事物提交，则需要先开启事物，然后手动提交。
>
> start transication;
>
> commit;

四大特性：

- **原子性（Atomicity）**：即事物是执行过程中不可以再分割的一个逻辑单位。

- **一致性（Consistency）**：保证数据的一致性，即事物修改数据前后一定是和事物的修改规则一致的。

- **持久性（Durability）**：持久性就是事物修改数据后，进行持久化保存，不会因为宕机、断电等情况丢失数据。

- **隔离性（Isolation）**：即多个事物之间，操作相同数据对象时，是想互不影响的。要实现事物的隔离，就必须要求事物的执行是串行的；但是串行执行事物，与会严重影响数据库性能。所以很多时候，会选择牺牲部分隔离性，来提升数据库性能，也因此会带来以下一些问题。

  - **脏读：**一个事物读取到了另外一个事物修改但是未提交的数据。
  - **不可重复读：**当事物内相同的记录被检索两次，且两次得到的结果不相同时，称之为不可重复读。
  - **幻读：**在事物执行过程中，另一个事物将新纪录添加到正在读取的事物中时，会发生幻读。在SQL 92 标准中，幻读是指在同一事物中，两次执行检索到的记录条数不一样（新增/减少）；而在MYSQL的标准中，幻读强调第二次检索时，检索到了第一次检索不存在的记录，而把丢失第一次检索记录归到不可重复读。

  > 事物隔离级别：
  >
  > - READ UNCOMMITED（未提交读）：可能产生 脏读、不可重复读、幻读。
  > - READ COMMITED（已提交读）：可能产生 不可重复读、幻读。
  > - REPEATABLE READ（可重复读）：SQL 92 标准中可能产生 幻读；MYSQL 标准中 已基本解决幻读，mysql默认的事物隔离级别。可重复读就是说，同一事物中，前后检索多次的记录是一样的。
  > - SERIALIZABLE（可串行化）：最高隔离性级别，不存在数据不安全的问题，但牺牲了数据库性能。



### 索引

> 索引（Index）是帮助MySQL高效获取数据的数据结构。在数据之外，数据库还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。
>
> **优势：**
>
> - 类似于书籍的目录索引，提高数据的检索效率，降低数据库的IO成本。
> - 通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。
>
> **劣势：**
>
> - 索引本质上也是一张表，该表中保存了主键和索引字段，并指向实体类的记录。因此索引也是要占用空间的，如果索引本身占用空间较大时，还会以索引文件的形式存储到磁盘上。
> - 索引提高了查询效率，但同时也降低了DML语句的执行效率，因为不仅要更新实体表的数据，还需要跟新索引中的字段。



#### 索引结构

索引是在存储引擎层实现的，而不是在服务层实现的。所以每种存储引擎的索引不一定完全相同，也不是所有的存储引擎都支持所有的索引结构的。MySQL目前提供了以下4种索引：

- BTREE索引：最常见的索引类型，大部分存储引擎都支持B树索引。
- HASH索引：只有Memory引擎支持，使用场景简单。
- R-tree索引（空间索引）：MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少，不做特别介绍。
- Full-text索引（全文索引）：也是MyISAM引擎的一个特殊索引类型，InnoDB从Mysql 5.6版本开始支持全文索引。



**MyISAM、InnoDB、Memory三种存储引擎对索引类型的支持**

<table border=1>
  <tr>
    <th  width=100px>索引类型</th>
    <th  width=200px>InnoDB引擎</th>
    <th  width=200px>MyISAM引擎</th>
    <th  width=200px>Memory引擎</th>
  </tr>
  <tr>
    <td>BTREE索引</td>
    <td>支持</td>
    <td>支持</td>
    <td>支持</td>
  </tr>
  <tr>
    <td>hash索引</td>
    <td>不支持</td>
    <td>不支持</td>
    <td>支持</td>
  </tr>
  <tr>
    <td>R-tree索引</td>
    <td>不支持</td>
    <td>支持</td>
    <td>不支持</td>
  </tr>
  <tr>
    <td>Full-text</td>
    <td>5.6 版本之后支持</td>
    <td>支持</td>
    <td>不支持</td>
  </tr>
</table>

我们平常所说的索引，如果没有特别指明，都是指B+树（多路搜索树，并不一定是二叉树）结构组织的索引。其中 聚集索引、符合索引、前缀索引、唯一索引 默认都是使用的 B+树 索引，统称为 索引。

<font style="color:red">Mysql 索引数据结构对经典的B+树进行了优化。在原有的基础上，增加一个指向相邻叶子结点的链表指针，就形成了带有顺序指针的B+树，提高区间访问的性能。</font>



#### 索引分类

- **单值索引：**即一个索引只包含单个列，一个表可以有多个单值索引。
- **唯一索引：**索引列的值必须唯一，但允许有一个或多个空值。
- **复合索引：**包含多个列的索引。



#### 索引语法

> 索引在创建表的时候，可以同时创建，也可以随时增加新的索引。

准备环境：

``` mysql
create database demo_01 default charset=utf8;

use demo_01;

CREATE TABLE `city` (
	`city_id` int(11) not null auto_increment,
	`city_name` varchar(50) not null,
	`country_id` int(11) not null,
	primary key (`city_id`)
)engine=InnoDB default charset=utf8;

CREATE TABLE `country` (
	`country_id` int(11) not null auto_increment,
	`country_name` varchar(100) not null,
	primary key (`country_id`)
)engine=InnoDB default charset=utf8;

INSERT into `city` (`city_id`, `city_name`, `country_id`) values (1, '西安', 1), (2, 'NewYork', 2), (3, '北京', 1), (4, '上海', 1);

INSERT into `country` (`country_id`, `country_name`) values (1, 'China'), (2, 'America'), (3, 'Japan'), (4, 'UK');
```



- 创建索引

  语法：

  ``` mysql
  CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name [USING index_type] ON tbl_name(index_col_name, ...);
  
  index_col_name: column_name[(length)][ASC | DESC]
  index_type: 默认使用BTREE索引结构
  ```

  示例：

  ``` mysql
  mysql> create index idx_city_name on city(city_name);
  Query OK, 0 rows affected (0.12 sec)
  ```

- 查看索引

  语法：

  ``` mysql
  show index from tbl_name;
  ```

  示例：

  ``` mysql
  mysql> show index from city\G;   # \G 的作用是切换一下输出的样式，由默认的横表切换为纵表
  *************************** 1. row ***************************
          Table: city
     Non_unique: 0
       Key_name: PRIMARY
   Seq_in_index: 1
    Column_name: city_id
      Collation: A
    Cardinality: 4
       Sub_part: NULL
         Packed: NULL
           Null:
     Index_type: BTREE
        Comment:
  Index_comment:
  *************************** 2. row ***************************
          Table: city
     Non_unique: 1
       Key_name: idx_city_name
   Seq_in_index: 1
    Column_name: city_name
      Collation: A
    Cardinality: 2
       Sub_part: NULL
         Packed: NULL
           Null:
     Index_type: BTREE
        Comment:
  Index_comment:
  2 rows in set (0.00 sec)
  ```

- 删除索引

  语法：

  ```mysql
  drop index index_name on tbl_name;
  ```

  示例:

  ```mysql
  mysql> drop index idx_city_name on city;
  Query OK, 0 rows affected (0.01 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  ```

- ALTER 索引相关命令

  语法：

  ```mysql
  # 添加主键索引，要求索引值必须是唯一的，且不能为 null
  alter table tbl_name add primary key(column_list);
  # 添加唯一索引，要求索引值必须是唯一的，但是 null 除外，且可以有多个 null 值
  alter table tbl_name add unique index_name(column_list);
  # 添加普通索引
  alter table tbl_name add index index_name(column_list);
  # 添加全文索引
  alter table tbl_name add fulltext index_name(column_list);
  
  # 删除索引
  alter table tbl_name drop index index_name;
  ```

  示例：

  ```mysql
  # 创建唯一索引
  mysql> alter table city add unique idx_city_name(city_name);
  Query OK, 0 rows affected (0.03 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  
  # 删除索引
  mysql> alter table city drop index idx_city_name;
  Query OK, 0 rows affected (0.02 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  ```

#### 索引设计原则

- 对查询频次较高，数据量比较大的表建立索引。

- 索引字段的原则，最佳候选列应当从where子句的条件中提取。如果where子句中的组合比较多，那么应当挑选最常用、过滤效果最好的列的组合。

- 尽量使用唯一索引，区分度越高，使用索引的效率越高。

- 索引可以提升查询数据的效率，但索引的数量不是多多益善，索引越多，维护索引的代价也就越高，尤其对DML语句执行效率影响最大。同时索引过多，mysql也需要从众多索引中选择最优索引，这里也存在性能消耗。

- 使用短索引，索引创建之后同样是存储在磁盘中，因此索引的字段比较短，同样可以提升索引访问的I/O效率，提升总体的性能。

- 利用最左前缀，N个列组合而成的组合索引，那么相当于创建了N个索引，如果查询时where子句中使用了组成该索引的前几个字段，那么这条查询SQL可以利用组合索引提升查询效率。

  ```mysql
  # 创建复合索引
  create index idx_name_email_status ON tbl_seller(name, email, status);
  
  # 查询时使用下面的where条件组合时，将使用索引。原理就是最左索引。
  	name;
  	name, email;
  	name, email, status;  
  ```



### 视图

> ​		视图(View)是一种虚拟存在的表。视图并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用时动态生成的。通俗的讲，视图就是一条select语句执行后返回的结果集。所以我们在创建视图的时候，主要工作就落在创建这条SQL查询语句上。
>
> 视图相对于普通的表有以下三点优势：
>
> - 简单：使用视图的用户完全不需要关心后面对应的表的结构、关联条件、筛选条件，对用户来说已经是过滤好的复合条件的结果集。
> - 安全：使用视图的用户只能访问他们被允许查询的结果集。对表的权限管理并不能限制到某个行某个列，但是通过视图可以简单实现。
> - 数据独立：一旦视图的结构确定了，可以屏蔽表结构变化对用户的影响，原表增加列对视图没有影响；原表修改列名，则可以通过修改视图来解决，不会造成对方问者的影响。

#### 操作视图

语法：

```mysql
# 创建视图语法
CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION]

# 修改视图语法
ALTER [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement [WITH [CASCADED | LOCAL] CHECK OPTION]

# 选项说明：
# WITH [CASCADED | LOCAL] CHECK OPTION  决定了是否允许更新数据使记录不再满足视图的条件。
# 	LOCAL：只要满足本视图的条件就可以更新
# 	CASCADED：必须满足多有针对该视图的所有视图的条件才可以更新，默认值

# 查看视图
show tables;
show create view view_name;  # 查看创建视图的详情

# 删除视图
DROP VIEW [IF EXISTS] view_name [, view_name] ...[RESTRICT | CASCADED]
```

示例：

```mysql
# 创建视图，修改视图类似
CREATE view view_city_country as select c.*, t.country_name from city c, country t where c.country_id = t.country_id; 

# 视图是一个虚拟的表，所以操作视图的方式和操作普通的表是一样的
mysql> select * from view_city_country;

# 对视图数据的更新会同步更新到原表数据，不建议这样操作。
UPDATE view_city_country set city_name = '西安市' where city_id = 1;

# 查看视图
mysql> show tables;
+-------------------+
| Tables_in_demo_01 |
+-------------------+
| city              |
| country           |
| view_city_country |
+-------------------+
3 rows in set (0.01 sec)

mysql> show create view view_city_country\G;
*************************** 1. row ***************************
                View: view_city_country
         Create View: CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`%` SQL SECURITY DEFINER VIEW `view_city_country` AS select `c`.`city_id` AS `city_id`,`c`.`city_name` AS `city_name`,`c`.`country_id` AS `country_id`,`t`.`country_name` AS `country_name` from (`city` `c` join `country` `t`) where (`c`.`country_id` = `t`.`country_id`)
character_set_client: utf8mb4
collation_connection: utf8mb4_general_ci

# 删除视图
mysql> drop view if exists view_city_country;
Query OK, 0 rows affected (0.02 sec)
```



### 存储过程和函数

> ​		存储过程和函数是 事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程和函数可以简化应用开发人员的很多工作，减少数据在数据库和应用之间的传输，对于提高数据处理的效率是有好处的。
>
> ​		存储过程和函数的区别在于函数必须有返回值，而存储过程没有。
>
> ​		函数：是一个有返回值的过程；
>
> ​		过程：是一个没有返回值的函数；

#### 存储过程

- 创建存储过程

  语法：

  ```mysql
  CREATE PROCEDURE procedure_name(proc_parameter[, ...])
  begin
  	-- SQL 语句
  end;
  ```

  示例：

  ```mysql
  delimiter $  # 设置mysql命令结束符为$。那么默认的 ; 将只是一个普通的分隔符，mysql解释器不会将其作为命令结束标识。
  
  create procedure proc_demo()
  begin
  	SELECT 'hello world';
  end$  # 当前创建存储过程命令结束
  
  delimiter ;
  ```

  **tips：**

  ​		DELIMITER  关键字用来申明SQL语句的分隔符，告诉MySQL解释器该段命令是否已经结束，mysql是否可以开始执行了。默认情况下，delimiter 是英文分号 ; 。

- 调用存储过程

  ```mysql
  call procedure_name();
  ```

- 查看存储过程

  ```mysql
  # 查看db_name数据库中的所有存储过程
  select name from mysql.proc where db='db_name'; 
  
  mysql> SELECT name from mysql.proc where db='demo_01';  # proc就是mysql中保存存储过程表，
  +-----------+
  | name      |
  +-----------+
  | proc_demo |
  +-----------+
  1 row in set (0.00 sec)
  
  # 查看存储过程的状态信息
  show procedure status;
  
  # 查看某个存储过程的定义
  show create procedure proc_name \G;
  
  mysql> show create procedure proc_demo \G;
  *************************** 1. row ***************************
             Procedure: proc_demo
              sql_mode: ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION
      Create Procedure: CREATE DEFINER=`root`@`%` PROCEDURE `proc_demo`()
  begin
  	SELECT 'hello world';
  end
  character_set_client: utf8mb4
  collation_connection: utf8mb4_general_ci
    Database Collation: utf8_general_ci
  1 row in set (0.00 sec)
  ```

- 删除存储过程

  ```mysql
  DROP PROCEDURE [IF EXISTS] proc_name;
  ```



#### 存储过程语法

> 存储过程是可以编程的，意味着可以使用变量、表达式、控制结构 来完成比较复杂的功能。

##### 变量

- **DECLARE**

  通过DECLARE可以定义一个局部变量，该变量的作用范围只能在 begin...end 块中。

  ```mysql
  DECLARE var_name[, ...] type [DEFAULT value]
  ```

  示例：

  ``` mysql
  delimiter $
  
  create procedure proc_test1()
  begin
  	declare num int default 10;   # 定义变量 num ，默认值为 10
  	SELECT CONCAT('this num value is:', num) 'other name';   # concat() 函数用于拼接两个字符串
  end$
  
  delimiter ;
  
  
  mysql> call proc_test1;
  +----------------------+
  | other name           |
  +----------------------+
  | this num value is:10 |
  +----------------------+
  ```

- **SET**

  直接赋值使用SET，可以赋值常量或者表达式。

  ```mysql
  SET var_name = expr [, var_name = expr] ...
  ```

  示例：

  ```mysql
  delimiter $
  
  create procedure proc_test2()
  begin
  	declare name char(20);
  	set name = 'NewYork';   # 为变量赋值。如果赋值语句不是在 SET 后面，那么赋值连接符应使用 :=
  	SELECT name 'city'; 
  end$
  
  delimiter ;
  
  mysql> call proc_test2;
  +---------+
  | city    |
  +---------+
  | NewYork |
  +---------+
  1 row in set (0.00 sec)
  ```

  还可以通过 select ... into 变量名 进行赋值：

  ```mysql
  delimiter $
  
  create procedure proc_test4()
  begin
  	declare city_num int;
  	SELECT COUNT(*) into city_num from city;   # 将查询结果赋值给变量
  	SELECT city_num;
  end$
  
  delimiter ;
  
  mysql> call proc_test4;
  +----------+
  | city_num |
  +----------+
  |        4 |
  +----------+
  ```



##### **if 条件判断**

语法：

```mysql
if condition_express then statement_list
		[elseif condition_express then statement_list] ...
		[else statement_list]
end if;
```

示例：

```mysql
delimiter $

create procedure proc_test9()
begin
	declare height int default 175;
	declare description char(20);
	if height >= 180 then
		set description = 'pritty girl';
	elseif height < 180 and height >= 170 then 
		set description = 'good girl';
	else
		set description = 'cute girl';
	end if;
	select CONCAT(description, 'height is :', height) description; 
end$

delimiter ;

mysql> call proc_test9;
+-------------------------+
| description             |
+-------------------------+
| good girlheight is :175 |
+-------------------------+
1 row in set (0.00 sec)
```



##### **传递参数**

语法：

```mysql
create procedure procedure_name([in/out/inout] 参数名 参数类型, ...)

in: 该参数可以作为输入，也就是需要调用方传入值，是默认参数类型
out: 该参数作为输出，也就是该参数可以作为返回值
inout: 既可以作为输入参数，也可以作为输出参数
```

示例一：IN-输入

```mysql
# 根据定义的身高变量，判断当前身高所属的身材类型
delimiter $

create procedure proc_test10(in height int)
begin
	declare description char(20);
	if height >= 180 then
		set description = 'pritty girl';
	elseif height < 180 and height >= 170 then 
		set description = 'good girl';
	else
		set description = 'cute girl';
	end if;
	select CONCAT(description, 'height is :', height) description; 
end$

delimiter ;

mysql> call proc_test10(175);  # 调用存储过程时，传入参数
+-------------------------+
| description             |
+-------------------------+
| good girlheight is :175 |
+-------------------------+
1 row in set (0.00 sec)
```

示例二：OUT-输出

```mysql
# 根据定义的身高变量，同时输出身材类型
delimiter $

create procedure proc_test11(in height int, out description char(40))
begin
	if height >= 180 then
		set description = 'pritty girl';
	elseif height < 180 and height >= 170 then 
		set description = 'good girl';
	else
		set description = 'cute girl';
	end if;
end$

delimiter ;

mysql> call proc_test11(182, @description);  # 存储过程的返回值，需要在调用时指定一个变量来接收。这里使用的是用户变量。
Query OK, 0 rows affected (0.00 sec)

mysql> select @description;  # mysql中的变量可以直接select查看
+--------------+
| @description |
+--------------+
| pritty girl  |
+--------------+
1 row in set (0.00 sec)
```



##### **case 语法**

语法：

```mysql
# 方式一
CASE case_value
	WHEN when_value THEN statement_list
	[WHEN when_value THEN statement_list] ...
	[ELSE statement_list]
END CASE;

# 方式二
CASE
	WHEN check_condition THEN statement_list
	[WHEN check_condition THEN statement_list] ...
	[ELSE statement_list]
END CASE;
```

示例：

```mysql
delimiter $

create procedure proc_test12(mon int)  # 存储过程参数 默认是IN类型
begin
	declare season varchar(16);
	case
		when mon >=1 and mon <= 3 THEN 
			set season = 'First Season';
		when mon >=4 and mon <= 6 THEN 
			set season = 'Second Season';
		when mon >=7 and mon <= 9 THEN 
			set season = 'Third Season';
		else 
			set season = 'Forth Season';
	end case;
	SELECT season;
end$

delimiter ;

mysql> call proc_test12(3);
+--------------+
| season       |
+--------------+
| First Season |
+--------------+
1 row in set (0.00 sec)
```



##### **while 循环**

语法：

```mysql
while check_condition do
	statement_list
end while;
```

示例：

```mysql
delimiter $ 

create procedure proc_test13(num int)
begin
	declare total int default 0;
	declare origin int default 1;
	while origin <= num do
		set total = total + origin;
		set origin = origin + 1;
	end while;
	SELECT total;
end$

delimiter ;

mysql> call proc_test13(100);
+-------+
| total |
+-------+
|  5050 |
+-------+
1 row in set (0.00 sec)
```



##### **repeat 循环**

语法：

```mysql
REPEAT
	statement_list
	UNTIL check_condition  # 这里不能加;,否则将不满足语法结构
END REPEAT;
```

示例：

```mysql
delimiter $ 

create procedure proc_test14(num int)
begin
	declare total int default 0;
	repeat
		set total = total + num;
		set num = num - 1;
	until num = 0
	end repeat;
	SELECT total;
end$

delimiter ;

mysql> call proc_test14(100);
+-------+
| total |
+-------+
|  5050 |
+-------+
1 row in set (0.00 sec)
```



##### **loop 循环**

> LOOP 实现简单的循环，推出循环的条件需要使用其他的语句定义，通常可以使用LEAVE语句实现。

语法：

```mysql
[label:] LOOP  # 可以为循环起一个别名
	statement_list
END LOOP [label];
```

示例：

```mysql
delimiter $

create procedure proc_test15(num int)
begin
	declare total int default 0;
	c:loop
		set total = total + num;
		set num = num - 1;
		if num = 0 then
			leave c;  # 借助leave结束loop循环
		end if;
	end loop c;
	SELECT total;
end$

delimiter ;
```



##### **游标/光标**

> 游标是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环处理。游标的使用包括 申明、OPEN、FETCH、CLOSE 四种操作。

语法：

```mysql
# 申明游标
DECLARE cursor_name CURSOR FOR select_statement;

# OPEN 游标。fetch 之前需要先打开
OPEN cursor_name;

# FETCH 游标。fetch 游标就是从结果集从上自下获取每一行数据的过程，fetch一次取一行，当取完最后一行后，继续fetch将触发ERROR
# fetch到的每一行数据，需要用变量来接收每一列的值
FETCH cursor_name INTO var_name [, var_name, ...]

# CLOSE 游标
CLOSE cursor_name;
```

示例：

```mysql
delimiter $

create procedure proc_test16()

begin
	declare id int(11);
	declare name varchar(50);	
	declare flag tinyint default 1;

	declare city_cursor cursor for select c.city_id, c.city_name from city c;
	declare exit err_handler for not found set flag = 0;   # 定义一个exit类型变量，当fetch结束时捕获error，并设置flag=0

	open city_cursor;

	repeat
		fetch city_cursor into id, name;
		select CONCAT('id is:', id,', name is:', name) info; 
		until flag = 0
	end repeat;

	close city_cursor;
		
end$

delimiter ;

mysql> call proc_test16();
+----------------------+
| info                 |
+----------------------+
| id is:1, name is:西安市 |
+----------------------+
1 row in set (0.00 sec)

+--------------------------+
| info                     |
+--------------------------+
| id is:2, name is:NewYork |
+--------------------------+
1 row in set (0.00 sec)

+---------------------+
| info                |
+---------------------+
| id is:3, name is:北京 |
+---------------------+
1 row in set (0.00 sec)

+---------------------+
| info                |
+---------------------+
| id is:4, name is:上海 |
+---------------------+
1 row in set (0.00 sec)

Query OK, 0 rows affected (0.00 sec)存储函数
```



#### 存储函数

语法：

```mysql
# 创建存储函数
CREATE FUNCTION function_name([param type ...])
RETURNS type
BEGIN
	...
END;

# 调用存储函数
SELECT function_name(param);

# 删除存储函数
DROP FUNCTION function_name;
```

示例：

```mysql
delimiter $

create function func1(countryId int)
returns int
begin   # begin...end之间的语法和procedure是一样的
	declare num int;
	select count(*) into num from city where country_id = countryId;
	return num;
end$

delimiter ;

mysql> select func1(1);
+----------+
| func1(1) |
+----------+
|        3 |
+----------+
```





### 触发器

> 触发器是与表有关的数据库对象，指在 insert/update/delete 之前或之后，触发并执行触发器中定义的SQL语句。触发器的这种特性可以应用在数据库确保数据的完整性、日志记录、数据校验等操作中。
>
> 使用别名 old 和 new 来引用触发器中发生变化的行记录内容。mysql目前还只支持行级触发，不支持语句级触发。
>
> old: 表示修改前的行对象，可以通过 . 调用行的字段；
>
> new: 表示修改后的行对象；

语法：

```mysql
# 创建触发器
create trigger trigger_name
before/after  insert/update/delete
on tbl_name
[for each row]  # 表明是行级触发
begin
	statement_list
end;

# 查看触发器
show triggers;

# 删除触发器
drop trigger [schema_name.]trigger_name;  # 如果没有指定schema_name，则默认是当前数据库
```

示例：

``` mysql
# 需求：利用触发器，记录对city表的操作日志

# 创建一个city_logs日志记录表
create table `city_logs` (
	`id` int unsigned auto_increment,
	`operate` enum('insert', 'update', 'delete') comment '操作类型',
	`operate_time` timestamp default CURRENT_TIMESTAMP comment '操作时间',
	`operate_id` int not null comment '操作表ID',
	`oprare_params` varchar(100) comment '操作参数',
	primary key (`id`)
)engine=InnoDB default charset=utf8;

# 创建触发器，这里用update操作做演示
delimiter $

create trigger city_update_trigger
after update 
on city
for each row
BEGIN 
	insert into city_logs(operate, operate_id, operate_params) values ('update', new.city_id, concat('操作前的城市名：', old.city_name, ', 修改后的城市名称是：', new.city_name));
END$

delimiter ;

# 修改city表中的数据
update city set city_name = 'Huashengdun' where city_id = 2;

# 查看日志记录
mysql> select * from city_logs;
+----+---------+---------------------+------------+----------------------------------------+
| id | operate | operate_time        | operate_id | operate_params                         |
+----+---------+---------------------+------------+----------------------------------------+
|  1 | update  | 2021-10-17 07:13:25 |          2 | 操作前的城市名：NewYork, 修改后的城市名称是：Huashengdun |
+----+---------+---------------------+------------+----------------------------------------+
1 row in set (0.00 sec)
```





## SQL 优化的步骤

### 1. 查看SQL执行统计值

命令：

```mysql
# 统计参数查询
show [session | global] status like 'Com_______';  # 直接show status有太多状态信息，这里用like匹配一下我们需要的。

# session 表示会话级的状态信息，即当前链接相关的。不指定时，作为默认值
# global 表示全局的状态信息，即所有连接的汇总(自上次数据库启动至今)，分析SQL时，global会用的比较多

mysql> show global status like 'Com_______';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| Com_binlog    | 0     |
| Com_commit    | 1     |
| Com_delete    | 20    |
| Com_insert    | 20    |
| Com_repair    | 0     |
| Com_revoke    | 0     |
| Com_select    | 2006  |  # 不仅仅是统计DQL语句，还包括 错误查询 + 权限检查查询等。
| Com_signal    | 0     |
| Com_update    | 18    |
| Com_xa_end    | 0     |
+---------------+-------+
10 rows in set (0.00 sec)  


# InnoDB 统计参数查询，按行统计
show [session | global] status like 'InnoDB_rows_%';

mysql> show global status like 'InnoDB_rows_%';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| Innodb_rows_deleted  | 18    |
| Innodb_rows_inserted | 8276  |
| Innodb_rows_read     | 69893 |  
| Innodb_rows_updated  | 20    |  # update 操作时，除了update的统计值，select、insert也会同步增加一次操作。
+----------------------+-------+
4 rows in set (0.00 sec)
```

**拓展**

update语句执行逻辑：

- 查询要修改的行，先查找内存，如果没有则从磁盘中读入内存，然后返回行数据；
- 修改行的字段，保存为新的行；
- 将新的行插入回内存，更新原来的数据；
- 写入redo log 处于prepare阶段，写入bin log ，提交事务处于commit状态。



### 2. 定位低效率执行SQL

- 慢日志查询

  通过查询慢日志定位那些执行效率较低的SQL语句。当指定 --log-slow-queries=file_name 启动mysql后，mysqld会记录所有执行时间超过 long_query_time 秒的SQL语句日志文件。

  ```mysql
  mysql> show variables like '%long_query%';   # 默认值是10s。
  +-----------------+-----------+
  | Variable_name   | Value     |
  +-----------------+-----------+
  | long_query_time | 10.000000 |
  +-----------------+-----------+
  1 row in set (0.00 sec)
  
  mysql> show variables like '%slow_query_log%';   # 慢日志记录默认关闭
  +---------------------+--------------------------------------+
  | Variable_name       | Value                                |
  +---------------------+--------------------------------------+
  | slow_query_log      | OFF                                  |
  | slow_query_log_file | /var/lib/mysql/3d84bd4ee18b-slow.log |
  +---------------------+--------------------------------------+
  2 rows in set (0.00 sec)
  
  mysql> set global slow_query_log = ON;  # 打开慢日志记录
  Query OK, 0 rows affected (0.01 sec)
  
  # MySQL中 long_query_time 参数用于控制慢查询的阀值，也就是说当一个SQL的执行时间超过这个值的时候会就被记录到慢查询文件中去。
  # long_query_time 是属于 global 和 session 级的，就是说这个变量的值在创建会话时就确定了。换名话说，当我们执行 set global long_query_time = xxx 时并不会在当前session生效。而在新建会话中可以看到已经设置成功。
  
  mysql> set global long_query_time = 3;
  Query OK, 0 rows affected (0.00 sec)
  
  ### 制造一个4s的慢查询，并查看日志
  mysql> select sleep(4);
  +----------+
  | sleep(4) |
  +----------+
  |        0 |
  +----------+
  1 row in set (4.00 sec)
  
  root@3d84bd4ee18b:/var/lib/mysql# cat 3d84bd4ee18b-slow.log
  # Time: 2021-10-18T07:01:02.582787Z
  # User@Host: root[root] @ localhost []  Id:    23
  # Query_time: 4.000170  Lock_time: 0.000000 Rows_sent: 1  Rows_examined: 0
  SET timestamp=1634540462;
  select sleep(4);
  
  ### 制造一个2s的慢查询，并查看日志
  mysql> select sleep(2);
  +----------+
  | sleep(2) |
  +----------+
  |        0 |
  +----------+
  1 row in set (2.00 sec)  # 此时slow日志没有记录这条记录
  
  ### 补充：
  # 将MySQL慢查询日志写入表的的设置为：set global log_output='TABLE';
  # 和慢查询相关的还有一个参数是 log_queries_not_using_indexes ，用来设置是否记录没有使用索引的查询。
  ```

  

- show processlist

  慢日志查询是在查询结束后才记录日志，所以如果想在执行效率出现问题的时候立即定位问题，就可以使用 show processlist 命令。该命令可以查看当前Mysql正在运行的进程，包括进程的状态、是否锁表等，可以实时的查看SQL的执行情况，同时对一些锁表操作进行优化。

  ``` mysql
  mysql> show processlist;  # 查询时，id为 11的连接，正在执行query，该条操作在查询时已经执行了8s
  +----+------+-----------------------+---------+---------+------+-------------------+------------------------------------------------------------------------------------------------------+
  | Id | User | Host                  | db      | Command | Time | State             | Info                                                                                                 |
  +----+------+-----------------------+---------+---------+------+-------------------+------------------------------------------------------------------------------------------------------+
  |  3 | root | localhost             | demo_01 | Sleep   | 7297 |                   | NULL                                                                                                 |
  | 10 | root | 183.223.222.157:57423 | NULL    | Sleep   | 4054 |                   | NULL                                                                                                 |
  | 11 | root | 183.223.222.157:57436 | demo_01 | Query   |    8 | Sending to client | /* ApplicationName=DBeaver 21.0.0 - SQLEditor <Script-5.sql> */ select @row_num := @row_num + 1 num, |
  | 12 | root | localhost             | demo_01 | Sleep   | 2552 |                   | NULL                                                                                                 |
  | 14 | root | localhost             | demo_01 | Query   |    0 | starting          | show processlist                                                                                     |
  +----+------+-----------------------+---------+---------+------+-------------------+------------------------------------------------------------------------------------------------------+
  5 rows in set (0.00 sec)
  
  # Id：用户连接mysql时系统分配的‘connection_id’，可以使用函数 connection_id()查看。select connection_id();
  # user： 当前用户
  # host：用户连接的来源IP和端口
  # db：当前进程目前连接的数据库名
  # command：当前链接正在执行的命令。一般为 sleep、query、connect 等
  # time：这个状态持续的时间，状态时s
  # state：显示当前链接的SQL语句的状态。描述的时SQL语句在执行中的某一个状态，一个SQL语句，一查询为例。可能需要经过copying to tmp table, sorting result, sending data 等状态
  # info：显示执行的SQL语句，是判断问题语句的重要依据。如果是客户端链接，还会显示客户端信息。
  ```

  

### 3. explain 分析执行计划

通过以上步骤查询到效率低的SQL语句后，可以通过EXPLAIN或者DESC命令 获取 mysql 是如何执行SELECT语句的信息，包括在SELECT语句执行过程中 表如何连接和连接的顺序。

示例：

```mysql
mysql> explain select * from city;
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------
| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra 
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------
|  1 | SIMPLE      | city  | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    6 |   100.00 | NULL 
+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+------
1 row in set, 1 warning (0.00 sec)
```

> 字段含义：
>
> - id：select查询的序列号，是一组数字。
> - select_type：表示select的类型，常见的取值有 SIMPALE、PRIMARY、UNION、SUBQUERY等。
> - table：输出结果集的表。
> - type：表的连接类型。
> - possible_keys：表示查询时，可能使用的索引。
> - key：表示实际使用的索引
> - key_len：索引字段的长度
> - rows：扫描行的数量
> - extra：执行情况的说明和描述



- **环境准备**

  ```mysql
  # 创建角色表
  create table `t_role` (
  	`id` varchar(32) not null,
  	`role_name` varchar(255) default null,
  	`role_code` varchar(255) default null,
  	`description` varchar(255) default null,
  	primary key (`id`),
  	unique key `unique_role_name` (`role_name`)
  )engine=InnoDB default charset=utf8;
  
  # 创建用户表
  create table `t_user` (
  	`id` varchar(32) not null,
  	`username` varchar(45) not null,
  	`password` varchar(96) not null,
  	`name` varchar(45) not null,
  	primary key (`id`),
  	unique key `unique_username` (`username`)
  )engine=InnoDB default charset=utf8;
  
  # 创建用户角色关联表
  create table `user_role` (
  	`id` int(11) not null auto_increment,
  	`user_id` varchar(32) default null,
  	`role_id` varchar(32) default null,
  	primary key (`id`),
  	key `fk_user_id` (`user_id`),
  	key `fk_role_id` (`role_id`),
  	constraint `fk_user_id` foreign key (`role_id`) references `t_role` (`id`) on delete no action on update no action,
  	constraint `fk_role_id` foreign key (`user_id`) references `t_user` (`id`) on delete no action on update no action
  )engine=InnoDB default charset=utf8;
  
  # 插入用户表数据
  insert into `t_user` (`id`, `username`, `password`, `name`) values (1, 'super', 'zj123456', '超级管理员'),(2, 'admin', 'zj123456', '系统管理员'),(3, 'tester', 'zj123456', '测试人员'),(4, 'stu1', 'zj123456', '学生1'),(5, 'stu2', 'zj123456', '学生2'),(6, 't1', 'zj123456', '老师1');
  
  # 插入角色表数据
  insert into `t_role` (`id`, `role_name`, `role_code`, `description`) values (5, '学生', 'student', '学生'),(7, '老师', 'teacher', '老师'),(8, '教学管理员', 'teachmanager', '教学管理员'),(9, '管理员', 'admin', '管理员'),(10, '超级管理员', 'super', '超级管理员');
  
  # 插入关联表数据
  insert into `user_role` (`user_id`, `role_id`) values (1, 5), (1, 7), (2, 8), (3, 9), (4, 8), (5, 10);
  ```

  

#### **explain 之 id**

表示的是查询过程中执行select子句或者操作表的顺序，数字越大优先级越高，数字相同则自上而下顺序执行。

示例：

``` mysql
# id相同时表的操作顺序自上而下
mysql> explain select * from t_role r, t_user u, user_role ur where r.id = ur.role_id and u.id = ur.user_id;
+----+-------------+-------+------------+--------+-----------------------+---------+---------+--------------------+------+----------+----------------------------------------------------+
| id | select_type | table | partitions | type   | possible_keys         | key     | key_len | ref                | rows | filtered | Extra                                              |
+----+-------------+-------+------------+--------+-----------------------+---------+---------+--------------------+------+----------+----------------------------------------------------+
|  1 | SIMPLE      | r     | NULL       | ALL    | PRIMARY               | NULL    | NULL    | NULL               |    5 |   100.00 | NULL                                               |
|  1 | SIMPLE      | ur    | NULL       | ALL    | fk_user_id,fk_role_id | NULL    | NULL    | NULL               |    6 |    20.00 | Using where; Using join buffer (Block Nested Loop) |
|  1 | SIMPLE      | u     | NULL       | eq_ref | PRIMARY               | PRIMARY | 98      | demo_01.ur.user_id |    1 |   100.00 | NULL                                               |
+----+-------------+-------+------------+--------+-----------------------+---------+---------+--------------------+------+----------+----------------------------------------------------+
3 rows in set, 1 warning (0.01 sec)

# id不同时，值越大优先级越高
mysql> explain select * from t_role where id = (select role_id from user_role where user_id = (select id from t_user where username = 'stu1'));
+----+-------------+-----------+------------+-------+-----------------+-----------------+---------+-------+------+----------+-------------+
| id | select_type | table     | partitions | type  | possible_keys   | key             | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-----------+------------+-------+-----------------+-----------------+---------+-------+------+----------+-------------+
|  1 | PRIMARY     | t_role    | NULL       | const | PRIMARY         | PRIMARY         | 98      | const |    1 |   100.00 | NULL        |
|  2 | SUBQUERY    | user_role | NULL       | ref   | fk_user_id      | fk_user_id      | 99      | const |    1 |   100.00 | Using where |
|  3 | SUBQUERY    | t_user    | NULL       | const | unique_username | unique_username | 137     | const |    1 |   100.00 | Using index |
+----+-------------+-----------+------------+-------+-----------------+-----------------+---------+-------+------+----------+-------------+
3 rows in set, 1 warning (0.00 sec)
```

#### **explain 之 select_type**

表示SELECT的类型，常见的取值如下表：

<table boder=1>
  <tr>
    <th>select_type</th>
    <th>含义</th>
  </tr>
  <tr>
  	<td>SIMPLE</td>
    <td>简单的select查询，查询中不包含子查询或者UNION</td>
  </tr>
  <tr>
  	<td>PRIMARY</td>
    <td>查询中若包含任何复杂的子查询，最外层查询标记为该标识</td>
  </tr>
  <tr>
  	<td>SUBQUERY</td>
    <td>在select或where子句中包含了子查询</td>
  </tr>
  <tr>
  	<td>DERIVED</td>
    <td>在from列表中包含的子查询，被标记为DERIVED（衍生）mysql会递归执行这些子查询，把结果放在临时表中</td>
  </tr>
  <tr>
  	<td>UNION</td>
    <td>若第二个select出现在UNION之后，该查询标记为UNION；若UNION包含在from子句的查询中，外层select将被标记为DRUIVED</td>
  </tr>
  <tr>
  	<td>UNION RESULT</td>
    <td>从UNION表获取结果的select</td>
  </tr>
</table>

示例：

```mysql
mysql> explain select * from t_role;
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------+
|  1 | SIMPLE      | t_role | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | NULL  |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from t_role where id = (select role_id from user_role where id = 1);
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table     | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | PRIMARY     | t_role    | NULL       | const | PRIMARY       | PRIMARY | 98      | const |    1 |   100.00 | NULL  |
|  2 | SUBQUERY    | user_role | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-----------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
2 rows in set, 1 warning (0.01 sec)

```

#### **explain 之 table**

展示本条查询是从哪一张表查询的

#### **explain 之 type**

type表示查询的访问类型，是比较重要的一个指标，可取值为：

<table border=1>
  <tr>
  	<th>type</th>
    <th>含义</th>
  </tr>
  <tr>
  	<td>null</td>
    <td>mysql不访问任何表、索引，直接返回结果</td>
  </tr>
  <tr>
  	<td>system</td>
    <td>表只有一条记录，这是const类型的特例，一般不会出现</td>
  </tr>
  <tr>
  	<td>const</td>
    <td>标识通过索引一次就找到了，const用于比较primary key和unique key索引。因为只匹配一行数据，所以很快。例如：将主键置于where表中，mysql就能将该查询转换成一个常量。const用于将 主键 或 唯一键 索引的所有部分与常量值进行比较</td>
  </tr>
  <tr>
  	<td>eq_ref</td>
    <td>类似ref，区别在于使用的是唯一索引，使用主键的关联查询，关联查询出的记录只有一条。常见于主键或唯一索引的扫描。</td>
  </tr>
  <tr>
  	<td>ref</td>
    <td>非唯一索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问</td>
  </tr>
  <tr>
  	<td>range</td>
    <td>只检索给定返回的行，使用一个索引来选择行。where之后出现between、<、>、in 等操作</、></td>
  </tr>
  <tr>
  	<td>all</td>
    <td>遍历全表以找到匹配的行</td>
  </tr>
  <tr>
  	<td>index</td>
    <td>index和all的区别为 index 类型只是遍历了索引树，通常比all快，all是遍历数据文件</td>
  </tr>
</table>

结果值从最好到最坏依次是：

```mysql
null > system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > all

# 一般来说，我们需要保证查询至少达到range级别，最好达到ref。
```

示例：

```mysql
mysql> explain select * from t_user where username = 'stu1';
+----+-------------+--------+------------+-------+-----------------+-----------------+---------+-------+------+----------+-------+
| id | select_type | table  | partitions | type  | possible_keys   | key             | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------+------------+-------+-----------------+-----------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | t_user | NULL       | const | unique_username | unique_username | 137     | const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+-------+-----------------+-----------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select * from t_user u, t_role r where u.id = r.id;
+----+-------------+-------+------------+--------+---------------+---------+---------+--------------+------+----------+-------+
| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref          | rows | filtered | Extra |
+----+-------------+-------+------------+--------+---------------+---------+---------+--------------+------+----------+-------+
|  1 | SIMPLE      | r     | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL         |    5 |   100.00 | NULL  |
|  1 | SIMPLE      | u     | NULL       | eq_ref | PRIMARY       | PRIMARY | 98      | demo_01.r.id |    1 |   100.00 | NULL  |
+----+-------------+-------+------------+--------+---------------+---------+---------+--------------+------+----------+-------+
2 rows in set, 1 warning (0.01 sec)

mysql> explain select * from t_user where name = 'a';
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | t_user | NULL       | ref  | index_name    | index_name | 137     | const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+------+---------------+------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

#### **explain 之 key**

- possible_keys：展示可能应用到当前查询的索引，一个或多个。
- key：实际使用的索引，如果为null，则没有使用索引。
- key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度。在不损失精度的前提下，长度与短越好。



#### **explain 之 rows**

当前查询扫描行的数量



#### **explain 之 extra**

其他的额外的执行计划信息，在该列展示。

<table border=1>
  <tr>
  	<th>extra</th>
    <th>含义</th>
  </tr>
  <tr>
  	<td>using filesort</td>
    <td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序读取，称为“文件排序”，效率较低</td>
  </tr>
  <tr>
  	<td>using temporary</td>
    <td>使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于 order by 和 group by, 效率低</td>
  </tr>
  <tr>
  	<td>using index</td>
    <td>表示相应的select操作使用了覆盖索引，效率高</td>
  </tr>
  <tr>
  	<td>using where</td>
    <td>表示有可能需要扫描 非索引 的列，但是一旦有可用的索引字段，将优先扫描索引字段</td>
  </tr>
  <tr>
  	<td>using index condition</td>
    <td>表示查询字段走了索引，但在查询到数据后，还需要再次回表查询其余的筛选条件</td>
  </tr>
</table>

示例：

```mysql
mysql> explain select id from t_user;
+----+-------------+--------+------------+-------+---------------+-----------------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type  | possible_keys | key             | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+-------+---------------+-----------------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | t_user | NULL       | index | NULL          | unique_username | 137     | NULL |    6 |   100.00 | Using index |
+----+-------------+--------+------------+-------+---------------+-----------------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

mysql> explain select role_code from t_role group by role_code;
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                           |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
|  1 | SIMPLE      | t_role | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    5 |   100.00 | Using temporary; Using filesort |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+---------------------------------+
1 row in set, 1 warning (0.00 sec)
```



### 4. show profile 分析SQL耗时

mysql从5.0.37版本开始增加了对 show profiles 和show profile 的支持。这两条命了能帮助我们分析SQL语句详细的时间消耗。

通过 have_profiling 参数，查看当前mysql是否支持 profile：

```mysql
mysql> select @@have_profiling;  # have_profiling是系统变量。以 @@变量名 修改只在当前会话生效；以 @@global.变量名修改 则在全局生效
+------------------+
| @@have_profiling |
+------------------+
| YES              |
+------------------+
1 row in set, 1 warning (0.00 sec)
```

默认情况下 profiling 是关闭的，需要手动开启：

```mysql
mysql> select @@profiling;
+-------------+
| @@profiling |
+-------------+
|           0 |
+-------------+
1 row in set, 1 warning (0.01 sec)

# 手动开启
mysql> set @@profiling = 1;
Query OK, 0 rows affected, 1 warning (0.00 sec)
```

在执行一些操作后，就可以通过 show profiles 来查看各个语句的耗时：

```mysql
mysql> show profiles;
+----------+------------+-----------------------------------------+
| Query_ID | Duration   | Query                                   |
+----------+------------+-----------------------------------------+
|        1 | 0.00488300 | select @@profiling                      |
|        2 | 0.00006325 | show tables                             |
|        3 | 0.00014350 | SELECT DATABASE()                       |
|        4 | 0.00968975 | show databases                          |
|        5 | 0.00097775 | show tables                             |
|        6 | 0.00031950 | show tables                             |
|        7 | 0.06016650 | select count(*) from wanda              |
|        8 | 0.00026625 | select * from t_user                    |
|        9 | 0.09366200 | select * from wanda limit 10001, 205781 |
+----------+------------+-----------------------------------------+
9 rows in set, 1 warning (0.00 sec)
```

通过 show profile for query query_id 来查看该SQL执行过程中每个线程的状态和消耗时间：

```mysql
mysql> show profile for query 9;
+----------------------+----------+
| Status               | Duration |
+----------------------+----------+
| starting             | 0.000061 |
| checking permissions | 0.000009 |
| Opening tables       | 0.000018 |
| init                 | 0.000018 |
| System lock          | 0.000008 |
| optimizing           | 0.000005 |
| statistics           | 0.000012 |
| preparing            | 0.000022 |
| executing            | 0.000004 |
| Sending data         | 0.093436 |  # sending data 表示线程开始访问数据并返回客户端的整个过程，期间还涉及到大量的磁盘
| end                  | 0.000017 |  # 读取操作，所以往往 sending data 是耗时最长的。	
| query end            | 0.000011 |
| closing tables       | 0.000010 |
| freeing items        | 0.000016 |
| cleaning up          | 0.000016 |
+----------------------+----------+
15 rows in set, 1 warning (0.01 sec)
```

在获取到最消耗时间的线程状态后，mysql还支持进一步选择 all、cpu、block io、context switch、page faults等明细类型，查看mysql在哪些资源上花费的时间。例如：查看cpu的耗费时间：

```mysql
mysql> show profile cpu for query 9;
+----------------------+----------+----------+------------+
| Status               | Duration | CPU_user | CPU_system |
+----------------------+----------+----------+------------+
| starting             | 0.000061 | 0.000033 |   0.000021 |
| checking permissions | 0.000009 | 0.000005 |   0.000004 |
| Opening tables       | 0.000018 | 0.000011 |   0.000007 |
| init                 | 0.000018 | 0.000010 |   0.000007 |
| System lock          | 0.000008 | 0.000005 |   0.000003 |
| optimizing           | 0.000005 | 0.000003 |   0.000002 |
| statistics           | 0.000012 | 0.000008 |   0.000005 |
| preparing            | 0.000022 | 0.000013 |   0.000009 |
| executing            | 0.000004 | 0.000003 |   0.000002 |
| Sending data         | 0.093436 | 0.069628 |   0.000000 |
| end                  | 0.000017 | 0.000010 |   0.000000 |
| query end            | 0.000011 | 0.000011 |   0.000000 |
| closing tables       | 0.000010 | 0.000010 |   0.000000 |
| freeing items        | 0.000016 | 0.000015 |   0.000000 |
| cleaning up          | 0.000016 | 0.000016 |   0.000000 |
+----------------------+----------+----------+------------+
15 rows in set, 1 warning (0.00 sec)
```



### 5. trace 分析优化器执行计划

mysql 5.6 提供了对SQL的trace追踪，通过trace文件能够进一步了解为什么优化器选择了A计划，而不是B计划。

打开trace：

```mysql
mysql> set optimizer_trace="enabled=on",end_markers_in_json=on;  # 打开跟踪，并设置格式为json
Query OK, 0 rows affected (0.00 sec)

mysql> set optimizer_trace_max_mem_size=1000000;  # 设置trace最大能使用的内存大小
Query OK, 0 rows affected (0.00 sec)
```

执行SQL语句，并检查系统表 information_schema.optimizer_trace 就可以知道mysql是如何执行SQL的：

```mysql
mysql> select * from t_user where id < 5;

mysql> select * from information_schema.optimizer_trace \G;
*************************** 1. row ***************************
                            QUERY: select * from t_user where id < 5
                            TRACE: {
  "steps": [
    {
      "join_preparation": {
        "select#": 1,
        "steps": [
          {
            "expanded_query": "/* select#1 */ select `t_user`.`id` AS `id`,`t_user`.`username` AS `username`,`t_user`.`password` AS `password`,`t_user`.`name` AS `name` from `t_user` where (`t_user`.`id` < 5)"
          }
        ] /* steps */
      } /* join_preparation */
    },
    {
      "join_optimization": {
        "select#": 1,
        "steps": [
          {
            "condition_processing": {
              "condition": "WHERE",
              "original_condition": "(`t_user`.`id` < 5)",
          ...
       "join_execution": {
        "select#": 1,
        "steps": [
        ] /* steps */
      } /* join_execution */
    }
  ] /* steps */
```





## 索引的使用

索引是数据库优化最常用也是最重要的手段之一，通过索引通常能借绝大多数的数据库性能问题。

### 避免索引失效

#### 环境准备

```mysql
create table `seller`(
	`sellerid` varchar(100),
	`name` varchar(100),
	`nickname` varchar(50),
	`password` varchar(60),
	`status` varchar(1),
	`address` varchar(100),
	`createtime` timestamp default current_timestamp,
	primary key (`sellerid`)
)engine=InnoDB default charset=utf8;

insert into `seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`) values 
('1', 'baidu', 'baidu technology company', 'zj123456', '1', 'beijing'),
('2', 'ali', 'alibaba technology company', 'zj123456', '1', 'beijing'),
('3', 'google', 'google technology company', 'zj123456', '1', 'beijing'),
('4', 'didi', 'didi technology company', 'zj123456', '1', 'beijing'),
('5', 'meituan', 'meituan technology company', 'zj123456', '1', 'beijing'),
('6', 'huawei', 'huawei company', 'zj123456', '1', 'chengdu'),
('7', 'bytedance', 'bytedance company', 'zj123456', '1', 'beijing'),
('8', 'qcloud', 'qcloud technology company', 'zj123456', '1', 'beijing'),
('9', 'jingdong', 'jingdong transfer company', 'zj123456', '1', 'beijing');

# 创建一个联合索引
alter table `seller` add index idx_name_nick_addr(`name`, `nickname`, `address`);
```



#### 1. 全值匹配

全值匹配，对索引中所有列都指定具体值。该情况下，索引生效，执行效率高。

```mysql
mysql> explain select * from seller where name = 'baidu' and nickname = 'baidu technology company' and address = 'beijing';
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys      | key                | key_len | ref               | rows | filtered | Extra |
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------------+------+----------+-------+
|  1 | SIMPLE      | seller | NULL       | ref  | idx_name_nick_addr | idx_name_nick_addr | 759     | const,const,const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```



#### 2. 最左前缀法则

如果索引包含了多列，要遵守最左前缀法则。指的是查询从索引的最左则开始，且不跳过中间的列。如果where条件中不包含最左侧的列，那么查询将不使用索引；如果跳过中间的列，那么将只使用跳过列之前的列的索引。

说明：where条件后的索引字段是没有先后顺序限制的。

- 符合最左前缀法则，走索引

  ```mysql
  mysql> explain select * from seller where name = 'baidu';
  +----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------+
  | id | select_type | table  | partitions | type | possible_keys      | key                | key_len | ref   | rows | filtered | Extra |
  +----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------+
  |  1 | SIMPLE      | seller | NULL       | ref  | idx_name_nick_addr | idx_name_nick_addr | 303     | const |    1 |   100.00 | NULL  |
  +----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------+
  1 row in set, 1 warning (0.00 sec)
  
  mysql> explain select * from seller where name = 'baidu' and nickname = 'baidu technology company';
  +----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------+------+----------+-------+
  | id | select_type | table  | partitions | type | possible_keys      | key                | key_len | ref         | rows | filtered | Extra |
  +----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------+------+----------+-------+
  |  1 | SIMPLE      | seller | NULL       | ref  | idx_name_nick_addr | idx_name_nick_addr | 456     | const,const |    1 |   100.00 | NULL  |
  +----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------+------+----------+-------+
  1 row in set, 1 warning (0.00 sec)
  
  mysql> explain select * from seller where address = 'beijing' and name = 'baidu' and nickname = 'baidu technology company';
  +----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------------+------+----------+-------+
  | id | select_type | table  | partitions | type | possible_keys      | key                | key_len | ref               | rows | filtered | Extra |
  +----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------------+------+----------+-------+
  |  1 | SIMPLE      | seller | NULL       | ref  | idx_name_nick_addr | idx_name_nick_addr | 759     | const,const,const |    1 |   100.00 | NULL  |
  +----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------------+------+----------+-------+
  1 row in set, 1 warning (0.00 sec)
  ```

- 违反最左前缀法则，不走索引

  ```mysql
  mysql> explain select * from seller where address = 'beijing' and nickname = 'baidu technology company';
  +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
  | id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
  +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
  |  1 | SIMPLE      | seller | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    9 |    11.11 | Using where |
  +----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
  1 row in set, 1 warning (0.00 sec)   # type类型是all，走全表扫描。
  
  mysql> explain select * from seller where address = 'beijing' and name = 'baidu';
  +----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-----------------------+
  | id | select_type | table  | partitions | type | possible_keys      | key                | key_len | ref   | rows | filtered | Extra                 |
  +----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-----------------------+
  |  1 | SIMPLE      | seller | NULL       | ref  | idx_name_nick_addr | idx_name_nick_addr | 303     | const |    1 |    11.11 | Using index condition |
  +----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-----------------------+
  1 row in set, 1 warning (0.00 sec)  # 跳过了中间列nickname。通过key_len可看到只使用了name字段的索引，从extra字段也可以看到，address字段没有使用索引。
  ```



#### 3. 范围查询右边的列，不走索引

```mysql
mysql> explain select * from seller where name = 'xiaomi' and status = '1' and nickname = 'baidu technology company';
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys      | key                | key_len | ref         | rows | filtered | Extra       |
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------+------+----------+-------------+
|  1 | SIMPLE      | seller | NULL       | ref  | idx_name_nick_addr | idx_name_nick_addr | 456     | const,const |    1 |    11.11 | Using where |
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)  # 此时走了 name 和 nickname 的索引


mysql> explain select * from seller where name = 'xiaomi' and status <= '1' and nickname = 'baidu technology company';
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys      | key                | key_len | ref         | rows | filtered | Extra       |
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------+------+----------+-------------+
|  1 | SIMPLE      | seller | NULL       | ref  | idx_name_nick_addr | idx_name_nick_addr | 456     | const,const |    1 |    33.33 | Using where |
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)  # 此时仍然走了两个列的索引。****此项暂时保留，可能新版本已经支持****
```



#### 4. 在索引列上进行运算操作，不走索引

```mysql
mysql> explain select * from seller where name = 'google';
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys      | key                | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | seller | NULL       | ref  | idx_name_nick_addr | idx_name_nick_addr | 303     | const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)   # name字段走索引

mysql> explain select * from seller where substring(name, 4, 3) = 'gle';   # mysql中字符串索引从1开始，这里截取3个
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | seller | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    9 |   100.00 | Using where |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)   # 此时不走索引
```



#### 5. 字符串不加单引号，会造成索引失效

```mysql
mysql> explain select * from seller where sellerid = "5";
+----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | seller | NULL       | const | PRIMARY       | PRIMARY | 302     | const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)  # 主键类型是varchar，走主键索引


mysql> explain select * from seller where sellerid = 5;
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | seller | NULL       | ALL  | PRIMARY       | NULL | NULL    | NULL |    9 |    11.11 | Using where |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 3 warnings (0.00 sec)  # 此时mysql内部查询优化器会将int 5 转成 char 5，造成索引失效。
```



#### 6. 尽量使用覆盖索引，避免 select * 

尽量使用覆盖索引（索引列完全包含查询列），减少 select *。

```mysql
mysql> explain select * from seller where name = 'baidu';
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys      | key                | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | seller | NULL       | ref  | idx_name_nick_addr | idx_name_nick_addr | 303     | const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)  # select * 时也使用索引，但查询字段包含了非索引字段

mysql> explain select name, nickname, address from seller where name = 'baidu';
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys      | key                | key_len | ref   | rows | filtered | Extra       |
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------------+
|  1 | SIMPLE      | seller | NULL       | ref  | idx_name_nick_addr | idx_name_nick_addr | 303     | const |    1 |   100.00 | Using index |
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)  # 此时extra的值是 using index ，效率更高
```



#### 7. 用 or 分隔开的多个索引字段，都将失效

```mysql
mysql> explain select * from seller where name = 'baidu' and nickname = 'beijing';
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys      | key                | key_len | ref         | rows | filtered | Extra |
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | seller | NULL       | ref  | idx_name_nick_addr | idx_name_nick_addr | 456     | const,const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+------+--------------------+--------------------+---------+-------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)  # 正常走索引


mysql> explain select * from seller where name = 'baidu' or nickname = 'beijing';
+----+-------------+--------+------------+------+--------------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys      | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+------+--------------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | seller | NULL       | ALL  | idx_name_nick_addr | NULL | NULL    | NULL |    9 |    20.99 | Using where |
+----+-------------+--------+------------+------+--------------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)  # 通过 possible_key 和 key 可以看到，索引全部失效
```



#### 8. 以%开头的LIKE模糊查询，索引失效。

如果仅仅是以尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。

```mysql
mysql> explain select * from seller where name like 'technology%';
+----+-------------+--------+------------+-------+--------------------+--------------------+---------+------+------+----------+-----------------------+
| id | select_type | table  | partitions | type  | possible_keys      | key                | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+--------+------------+-------+--------------------+--------------------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | seller | NULL       | range | idx_name_nick_addr | idx_name_nick_addr | 303     | NULL |    1 |   100.00 | Using index condition |
+----+-------------+--------+------------+-------+--------------------+--------------------+---------+------+------+----------+-----------------------+
1 row in set, 1 warning (0.00 sec)  # 尾部模糊匹配，索引生效

mysql> explain select * from seller where name like '%technology';
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | seller | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    9 |    11.11 | Using where |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)  # 头部模糊匹配，索引失效
```

由于头部模糊匹配，使用场景比较多，要解决这个问题，就是在此基础上使用 覆盖索引：

```mysql
mysql> explain select name, nickname from seller where name like '%technology';
+----+-------------+--------+------------+-------+---------------+--------------------+---------+------+------+----------+--------------------------+
| id | select_type | table  | partitions | type  | possible_keys | key                | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+--------+------------+-------+---------------+--------------------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | seller | NULL       | index | NULL          | idx_name_nick_addr | 759     | NULL |    9 |    11.11 | Using where; Using index |
+----+-------------+--------+------------+-------+---------------+--------------------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
```



#### 9. 如果mysql评估使用索引比全表扫描更慢，则不使用索引

```mysql
# 为 address 列再单独创建一个单列索引
alter table seller add index ind_address(`address`);

# ---------explain----------
mysql> explain select * from seller where address = 'beijing';
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | seller | NULL       | ALL  | ind_address   | NULL | NULL    | NULL |    9 |    88.89 | Using where |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)  # 此时不走索引，因为address为 beijing 时，全表扫描更快

mysql> explain select * from seller where address = 'chengdu';
+----+-------------+--------+------------+------+---------------+-------------+---------+-------+------+----------+-------+
| id | select_type | table  | partitions | type | possible_keys | key         | key_len | ref   | rows | filtered | Extra |
+----+-------------+--------+------------+------+---------------+-------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | seller | NULL       | ref  | ind_address   | ind_address | 303     | const |    1 |   100.00 | NULL  |
+----+-------------+--------+------------+------+---------------+-------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)  #  此时走索引
```



#### 10. is null 和 is not null 有时索引也会失效

当字段中为 null 的记录比例较高时，is null 作为条件时，索引将会失效；is not null 会走索引。反之亦然。

其原理同第九条，当mysql检查到全表扫描比走索引更快时，那么就不会走索引。



#### 11. in走索引，not in 不走索引

其实这个也好理解，索引基于B+树实现。使用 in 时，只需要取出值挨个走一遍索引即可；但是 not in 需要判断每个值是否在集合中，所以需要走全表扫描。

```mysql
mysql> explain select * from seller where sellerid in ('1', '3', '6');
+----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | seller | NULL       | range | PRIMARY       | PRIMARY | 302     | NULL |    3 |   100.00 | Using where |
+----+-------------+--------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)

mysql> explain select * from seller where sellerid not in ('1', '3', '6');
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table  | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | seller | NULL       | ALL  | PRIMARY       | NULL | NULL    | NULL |    9 |    77.78 | Using where |
+----+-------------+--------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```



#### 12. 单列索引 和 复合索引

尽量使用复合索引，而少使用单列索引。

复核索引：复合索引创建后，在满足最左前缀原则的情况下，会对多个字段都走索引。

单列索引：对多列都创建单列索引，当这些字段同时参与过滤时，数据库会选择一个最优索引来使用，并不会使用全部索引。所谓最优索引，即在这些索引中，该索引的辨识度最高，换句话说就是该索引需要扫描的行最少。





### 查看索引使用情况

- 查看当前表中有哪些索引

  ```mysql
  mysql> show index from seller;
  +--------+------------+--------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
  | Table  | Non_unique | Key_name           | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
  +--------+------------+--------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
  | seller |          0 | PRIMARY            |            1 | sellerid    | A         |           9 |     NULL | NULL   |      | BTREE      |         |               |
  | seller |          1 | idx_name_nick_addr |            1 | name        | A         |           9 |     NULL | NULL   | YES  | BTREE      |         |               |
  | seller |          1 | idx_name_nick_addr |            2 | nickname    | A         |           9 |     NULL | NULL   | YES  | BTREE      |         |               |
  | seller |          1 | idx_name_nick_addr |            3 | address     | A         |           9 |     NULL | NULL   | YES  | BTREE      |         |               |
  | seller |          1 | ind_address        |            1 | address     | A         |           2 |     NULL | NULL   | YES  | BTREE      |         |               |
  +--------+------------+--------------------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
  5 rows in set (0.01 sec)
  ```



- 查看索引的使用情况

  ```mysql
  mysql> show status like 'Handler_read%';  # 查看当前会话
  +-----------------------+-------+
  | Variable_name         | Value |
  +-----------------------+-------+
  | Handler_read_first    | 3     |
  | Handler_read_key      | 3     |
  | Handler_read_last     | 0     |
  | Handler_read_next     | 0     |
  | Handler_read_prev     | 0     |
  | Handler_read_rnd      | 0     |
  | Handler_read_rnd_next | 66    |
  +-----------------------+-------+
  7 rows in set (0.01 sec)
  
  mysql> show global status like 'Handler_read%';  # 查看全局
  +-----------------------+---------+
  | Variable_name         | Value   |
  +-----------------------+---------+
  | Handler_read_first    | 153     |
  | Handler_read_key      | 109     |
  | Handler_read_last     | 0       |
  | Handler_read_next     | 3281    |
  | Handler_read_prev     | 0       |
  | Handler_read_rnd      | 19      |
  | Handler_read_rnd_next | 2643937 |
  +-----------------------+---------+
  7 rows in set (0.01 sec)
  ```

  分析这几个值，我们可以查看当前索引的使用情况：

  - Handler_read_first：索引中第一条被读的次数。如果较高，它表示服务器正执行大量全索引扫描；例如，SELECT col1 FROM foo，假定col1有索引（这个值越低越好）。
  - Handler_read_key：如果索引正在工作，这个值代表一个行被索引值读的次数，如果值越低，表示索引得到的性能改善不高，因为索引不经常使用（这个值越高越好）。
  - Handler_read_next ：按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加。
  - Handler_read_prev：按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY ... DESC。
  - Handler_read_rnd ：根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键。这个值较高，意味着运行效率低，应该建立索引来补救。
  - Handler_read_rnd_next：在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。
    











## 常见问题解答

### 一、如何排查数据库慢的原因

### 二、 如何优化慢查询语句

### 三、SELECT 查询语句中各子句的执行顺序

SQL 查询的大致语法结构如下：

``` sql
# 语句前的序号表示子句执行的先后顺序
(5)SELECT DISTINCT <select_list>                     
(1)FROM <left_table> <join_type> JOIN <right_table> ON <on_predicate>
(2)WHERE <where_predicate>
(3)GROUP BY <group_by_specification>
(4)HAVING <having_predicate>
(6)ORDER BY <order_by_list>
(7)LIMIT n, m

# 具体的关键字执行顺序如下，这些步骤执行时，每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。
# 这些虚拟表对调用者（客户端应用程序或者外部查询）不可用。只是最后一步生成的表才会返回给调用者。
# 如果没有在查询中指定某一子句，将跳过相应的步骤。
FROM
ON 
JOIN 
WHERE 
GROUP BY 
HAVING 
SELECT
DISTINCT 
ORDER BY 
LIMIT
```

**执行步骤详解：**

- **一、FROM阶段**

  FROM阶段标识出查询的来源表，并处理表运算符。在涉及到联接运算的查询中（各种JOIN），主要有以下几个步骤：

  - **求笛卡尔积**。不论是什么类型的联接运算，首先都是执行交叉连接（CROSS JOIN），求笛卡儿积（Cartesian product），生成虚拟表VT1-J1。
  - **ON筛选器**。 这个阶段对上个步骤生成的VT1-J1进行筛选，根据ON子句中出现的谓词进行筛选，让谓词取值为true的行通过了考验，插入到VT1-J2。
  - **添加外部行**。如果指定了OUTER JOIN，如LEFT OUTER JOIN、RIGHT OUTER JOIN，还需要将VT1-J2中没有找到匹配的行，作为外部行添加到VT1-J2中，生成VT1-J3。如果FROM子句包含两个以上表，则对上一个连接生成的结果表VT1-J3和下一个表重复依次执行3个步骤，直到处理完所有的表为止。

  经过以上步骤，FROM阶段就完成了。

- **二、WHERE阶段**

  WHERE阶段是根据<where_predicate>中条件对VT1中的行进行筛选，让条件成立的行才会插入到VT2中。**此时数据还没有分组，所以不能在WHERE中出现对统计的过滤。**

- **三、GROUP BY阶段**

  GROUP阶段按照指定的列名列表，将VT2中的行进行分组，生成VT3。最后每个分组只有一行。**在GROUP BY阶段，数据库认为两个NULL值是相等的，因此会将NULL值分到同一个分组中。**

- **四、HAVING阶段**

  该阶段根据HAVING子句中出现的谓词对VT3的分组进行筛选，并将符合条件的组插入到VT4中。**COUNT(expr) 会返回expr不为NULL的行数，count(1)、count(\*)会返回包括NULL值在内的所有数量。**

- **五、SELECT阶段**

  这个阶段是投影的过程，处理SELECT子句提到的元素，产生VT5。这个步骤一般按下列顺序进行：

  - 计算SELECT列表中的表达式，生成VT5-1。
  - 若有DISTINCT，则删除VT5-1中的重复行，生成VT5-2。

- **六、ORDER BY阶段**

  根据ORDER BY子句中指定的列表字段，对VT5-2中的行，进行排序，生成VT6。**如果不指定排序，数据并非总是按照主键顺序进行排序的。NULL被视为最小值。**

- **七、LIMIT阶段**

  取出指定行的记录，产生虚拟表VT7，并返回给查询用户。**LIMIT n, m的效率是十分低的，一般可以通过在WHERE条件中指定范围来优化 \**WHERE\** id > ? limit 10。**


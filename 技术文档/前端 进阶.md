# 综合类

## 一、前端jsonp跨域方案原理

**背景：**

由于浏览器同源策略的限制，非同源下的请求，都会产生跨域问题，jsonp即是为了解决这个问题出现的一种简便解决方案。

**同源策略即：同一协议，同一域名，同一端口号。当其中一个不满足时，我们的请求即会发生跨域问题。**

**举个简单的例子：**

​	http://www.abc.com:3000到https://www.abc.com:3000的请求会出现跨域（域名、端口相同但协议不同）
​	http://www.abc.com:3000到http://www.abc.com:3001的请求会出现跨域（域名、协议相同但端口不同）
​	http://www.abc.com:3000到http://www.def.com:3000的请求会出现跨域（域名不同）



**JSONP跨域原理：**

-  **Jsonp(JSON with Padding)** 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。

- 我们注意到，script标签的src还是img标签的src，或者说link标签的href他们没有被同源策略所限制。jsonp就是使用同源策略这一“漏洞”，实现的跨域请求。

- JSONP就是利用了sscript标签的src属性发起的跨域请求，由于script标签的作用是用来执行src指定的js代码，那么我们可以跟后端协商一个函数名，后端将要返回的数据作为函数的参数，一起返回给前端，前端事先定义好该函数，这样就完成了跨域请求。



**JSONP的缺点：**

- 首先，它没有关于JSONP调用的错误处理，一旦回调函数调用失败，浏览器会以静默失败的方式处理。
- 其次，它只支持GET请求，这是由于该技术本身的特性所决定的。因此，对于一些需要对安全性有要求的跨域请求，JSONP的使用需要谨慎一点了。
- JSONP不支持用async:false的方法设置同步。



**JSONP使用举例：**

 - **跨域执行远端的服务器中的js代码**

   apache服务器中的remote.js  

   > apache静态文件路径：/var/www/html/
   >
   > 执行远端的js文件，或者回调函数等需要把资源当作脚本运行的，只能用script标签，否则将不会按照脚本去执行

   ``` js
   alert("我是远程文件");
   ```

   本地html文件jsonp.html

   ``` html
   <!DOCTYPE html>
   <html xmlns="http://www.w3.org/1999/xhtml">
   <head>
       <title> JSONP </title>
       <!--charset 解决文本乱码-->
       <script charset="UTF-8" type="text/javascript" src="http://121.4.47.229/jsonp/remote.js"></script>
   </head>
   <body>
       来了老弟
   </body>
   </html>
   ```

- **远端的js也可以调用本地的脚本函数**

  remote.js

  ``` js
  handleFunc({"result": "我在远端入参"});
  ```

  jsonp.html

  ``` html
  <!DOCTYPE html>
  <html xmlns="http://www.w3.org/1999/xhtml">
  
  <head >
      <meta charset="UTF-8">
      <title> JSONP </title>
      <script type="text/javascript">
          var handleFunc = function(data) {
          alert("本地文件被远程js调用了。远程入参：" + data.result);
          }
      </script>
      <script charset="UTF-8" type="text/javascript" src="http://121.4.47.229/jsonp/remote.js"></script>
  </head>
  <body>
  来了老弟
  </body>
  </html>
  ```

- **服务器动态的生成js代码**

  本地jsonp.html文件

  ``` html
  <!DOCTYPE html>
  <html xmlns="http://www.w3.org/1999/xhtml">
  
  <head>
      <meta charset="UTF-8">
      <title> JSONP </title>
      <script type="text/javascript">
          var flightHandler = function(data) {
            if (data.price){
               alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
            }else{
              alert(data);
            }
          }
          var url = "http://127.0.0.1:5000/jsonp?code=CA199202&callback=flightHandler";
          
          // 创建一个script标签
          var script = document.createElement('script');
          
          // 设置标签属性
          script.setAttribute('src', url);
        	script.setAttribute('charset', "UTF-8");
        	script.setAttribute('type', "text/javascript");
        
        	// 把标签添加到head中
        	document.getElementsByTagName('head')[0].appendChild(script);
      </script>
  </head>
  <body>
  来了老弟
  </body>
  </html>
  ```

  服务端文件demo.py

  > 这里使用flask快速实现一个API，返回值前端作为js代码执行

  ``` python
  import json
  
  from flask import Flask, request
  
  app = Flask(__name__)
  
  
  @app.route('/jsonp', methods=['GET'])
  def index():
      func = request.args.get('callback')
      flight_name = request.args.get('code')
  
      # 航班信息
      flight = {
          "CA199202": {
              'price': 1200,
              'tickets': 37
          },
          "SA6532K": {
              'price': 900,
              'tickets': 60
          }
      }
  
      if flight.get(flight_name):
          # 以json字符串形式返回js脚本
          return func + "(" + json.dumps(flight.get(flight_name)) + ")"
      else:
          return func + "('无航班信息')"
  
  
  if __name__ == '__main__':
      app.run()
  
  ```

- **扩展**

  > Vue前端跨域插件：[Vue-jsonp](https://www.npmjs.com/package/vue-jsonp)
  >
  > 跨域问题，前端通过jsonp方式可以解决；后端服务器也可以配置请求白名单等方式解决。



## 二、OPTIONS 请求

- 背景

  > 出于安全考虑，并不是所有域名访问后端服务都可以。在正式跨域之前，浏览器会根据需要发起一次预检(也就是option请求)，用来让服务端返回允许的方法(如get、post)，被跨域访问的Origin(来源或者域)，还有是否需要Credentials(认证信息)等。

- 简单请求

  - 简单请求条件
    - 方式只能是：GET、POST、HEAD
    - HTTP请求头限制这几种字段：Accept、Accept-Language、Content-Language、Content-Type、Last-Event-ID
    - Content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain
  - **对于简单请求，浏览器直接请求，会在请求头信息中，增加一个origin字段，来说明本次请求来自哪个源（协议+域名+端口）。服务器根据这个值，来决定是否同意该请求，服务器返回的响应会多几个头信息字段。**
    - Access-Control-Allow-Origin：该字段是必须的，* 表示接受任意域名的请求，还可以指定域名，如www.baidu.com
    - Access-Control-Allow-Credentials：该字段可选，是个布尔值，表示是否可以携带cookie。（注意：如果Access-Control-Allow-Origin字段设置*，此字段设为true无效）
    - Access-Control-Allow-Headers：该字段可选，里面可以获取Cache-Control、Content-Type、Expires等，如果想要拿到其他字段，就可以在这个字段中指定。

- 复杂请求

  - **非简单请求是对那种对服务器有特殊要求的请求，比如请求方式是PUT或者DELETE，或者Content-Type字段类型是application/json。都会在正式通信之前，增加一次HTTP请求，称之为预检。浏览器会先询问服务器，当前网页所在域名是否在服务器的许可名单之中，服务器允许之后，浏览器会发出正式的XMLHttpRequest请求，否则会报错。**
    - 与检测的请求方式就是options。
    - options 请求不会携带 cookie 和 请求参数 等信息。

 - 总结

   > options 请求就是预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。





# CSS类

##  一、 CSS选择器优先级及判定标准

### 1. 优先级分级

1. **!important**

   ```css
   .foo {
     color:red !important
   }
   ```

   !important是顶级优先级，唯一推荐使用它的场景为`忽略JS脚本设置的样式，使js设置样式无效`。对于其他场景都没有使用它的理由，`切勿滥用`

2. **style属性内联样式**

   ```html
   <span style="color: red;">内联样式</span>
   ```

3. **ID选择器**

   ```css
   #id {
     color:red
   }
   ```

4. **类选择器**

   ```css
   .foo {
     color:red
   }
   /* disabled状态的标签设置为灰色 */
   [disabled]{
     color: grey
   }
   /* 伪类选择器和类选择器同级 */
   p:hover {
     color:blue
   }
   ```

5. **标签选择器**

   ```css
   body {
     background: white
   }
   ```

6. **通配选择器，选择符和逻辑组合伪类**

   ```css
   * {
     color:red
   }
   :not() {
     color:blue
   }
   /*
   通配选择器统一指*
   
   选择符包括+，-，~，空格和||
   
   逻辑组合伪类包括:not()，:is()，:where()等，这些伪类本身并不影响CSS优先级，影响优先级的是()里的选择器
   */
   ```



### 2. 优先级计算

除开!important和style属性内联样式（因为一个是第一顶级的优先级，另一个是写在HTML标签属性上的第二顶级优先级），在CSS样式中写的选择器样式的优先级满足以下计算规则：

- 每出现一个`ID选择器`，优先级数值`+100`
- 每出现一个`class、属性（href、rel、src等） 或 伪类选择器`，优先级数值`+10`
- 每出现一个`标签选择器`，优先级数值`+1`
- 每出现一个`通配选择器，选择符和逻辑组合伪类`，优先级数值`+0`
- 继承的CSS样式优先级为0
- 若两个选择器最终优先级计算数值相等，则后渲染的选择器优先级更高（**后渲染是相对整个HTML文档的CSS样式渲染顺序来讲的，并非单个CSS文件）**



示例：

```css
/* 优先级：1+0+10 = 11

	根据给定属性的值选择元素。
  语法：[attr] [attr=value] [attr~=value] [attr|=value] [attr^=value] [attr$=value] [attr*=value] [autoplay]
	示例表示：rel属性不是nofollow的a标签样式
*/
a:not([rel=nofollow]) {
}

/* 优先级：1+10+0+10 = 21
	示例表示：body标签中，有foo类，且没有dir属性的标签样式
*/
body .foo:not([dir]){
}
body .foo:is(:hover) {
}

/* 优先级：100+10+1 = 111 */
#foo .bar p {}
```



**增加优先级的方法**

实际开发调节样式时，难免会遇到需要增加CSS选择器优先级去匹配样式的场景，很多人是采取增加CSS样式嵌套来增加优先级数值的做法，如下：

```css
/* 原优先级 */
.foo {}

/* 增加优先级 */
.father .foo {}
```

但是这种做法增加了CSS样式与HTML结构的耦合度，降低了可维护性，推荐如下做法：

```css
/* 重复选择器自身即可 */
.foo .foo {}
```



**优先级注意事项**

- **CSS选择器优先级与DOM元素的层级位置没有关系**

  ```css
  body .foo {
    color: red
  }
  html .foo {
    color:blue
  }
  ```

  这里虽然第二个选择器在第一个选择器渲染后，但有人会考虑到body是html的子元素，距离.foo元素更近，所以应该是红色。但是DOM层级距离是对CSS选择器优先级没有任何影响的，所以按照`优先级数值相等，后渲染优先`的原则，.foo元素是蓝色。

- **选择器优先级越级现象**

  ```css
  #text {
    color:red
  }
  .text {
    color:blue
  }
  ```

  ```html
  <span id="text" class="text">颜色</span>
  ```

  根据id选择器 优先级大于class选择器的原则可知应该是红色。但是如果是下面这种情况呢？

  ```css
      /*如果有256个.text组合而成的选择器*/
      .text.text.text.text...{
          color:blue
      }
  ```

  有人认为class选择器优先级数值为10，如果同时256个，那肯定比只有一个id的id选择器优先级高！

  **实际上，在过去大多浏览器确实是这样的，FireFox浏览器早年的源码表示class类名以8字节字符串存储，所能容纳的最大值为255，超过就会溢出到ID选择器区域。**

  **但是后来`除了IE浏览器`，其他浏览器都修改了策略——`再多的选择器优先级也无法超过比它更高一级的选择器`。**

  **所以这里的文字颜色依然是红色。**





## 二、position 的属性值

> CSS position属性用于指定一个元素在文档中的定位方式。top、right、bottom、left 属性则决定了该元素的最终位置。
>
> position 取值有：static、relative、absolute、fixed、sticky、inherit

然后来看看什么是文档流(normal flow)，下面是 [www.w3.org](https://www.w3.org/TR/CSS21/visuren.html#) 的描述：

> **Normal flow**
>
> Boxes in the normal flow belong to a formatting context, which may be block or inline, but not both simultaneously. [Block-level](https://www.w3.org/TR/CSS21/visuren.html#block-level) boxes participate in a [block formatting](https://www.w3.org/TR/CSS21/visuren.html#block-formatting) context. [Inline-level boxes](https://www.w3.org/TR/CSS21/visuren.html#inline-level) participate in an [inline formatting](https://www.w3.org/TR/CSS21/visuren.html#inline-formatting) context.

理解 normal flow：

1. normal flow直译为常规流、正常流，国内不知何原因大多译为文档流；
2. 窗体自上而下分成一行一行，并在每行中按从左至右的顺序排放元素；
3. 每个非浮动块级元素都独占一行， 浮动元素则按规定浮在行的一端，若当前行容不下，则另起新行再浮动；
4. 内联元素也不会独占一行，几乎所有元素(包括块级，内联和列表元素）均可生成子行，用于摆放子元素；
5. 有三种情况将使得元素脱离normal flow而存在，分别是 float，absolute ，fixed，但是在IE6中浮动元素也存在于normal flow中。



### position: static

MDN的描述：

> 该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top、right、bottom、left 属性无效。

对元素设置 position: static，可以覆盖 position其他布局行为设置。**static 是元素的默认值**，这就是元素出现在常规文档流中的原因。

```html
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>CSS-position-static</title>
 6     <link rel="stylesheet" href="https://cdn.bootcss.com/normalize/8.0.0/normalize.css">
 7     <style>
 8         .container{
 9             background-color: #868686;
10             width: 100%;
11             height: 300px;
12         }
13         .content{
14             background-color: yellow;
15             width: 100px;
16             height: 100px;
17             position: static;
18             left: 10px;/* 这个left没有起作用 */
19         }
20     </style>
21 </head>
22 <body>
23     <div class="container">
24         <div class="content">    
25         </div>
26     </div>
27 </body>
28 </html>
```

对 content 的 position 设定 static 后，left就失效了，而元素（content）就以正常的 normal flow 形式呈现。



### position: relative

MDN的描述：

> 该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。

相对于normal flow中的原位置来定位。

```html
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <meta name="viewport" content="width=device-width, initial-scale=1.0">
 6     <meta http-equiv="X-UA-Compatible" content="ie=edge">
 7     <title>CSS-position-relative</title>  
 8     <link rel="stylesheet" href="https://cdn.bootcss.com/normalize/8.0.0/normalize.css">
 9     <style>
10             .container{
11                 background-color: #868686;
12                 width: 100%;
13                 height: 300px;
14             }
15             .content_0{
16                 background-color: yellow;
17                 width: 100px;
18                 height: 100px;               
19             }
20             .content_1{
21                 background-color: red;
22                 width: 100px;
23                 height: 100px;
24                 position: relative;/* 这里使用了relative，此时没有指定偏移量，所以还是正常的出现在 normal flow*/            
25             }
26             .content_2{
27                 background-color: black;
28                 width: 100px;
29                 height: 100px;               
30             }
31         </style>
32     </head>
33     <body>
34         <div class="container">
35             <div class="content_0">    
36             </div>
37             <div class="content_1">    
38             </div>
39             <div class="content_2">    
40             </div>
41         </div>   
42 </body>
43 </html>
```

为content_1添加偏移量后，可以看到相对于自身原来的位置发生了偏移。

```html
1 .content_1{
2                 background-color: red;
3                 width: 100px;
4                 height: 100px;
5                 position: relative;/* 这里使用了relative  */
6                 left: 20px;/* 这里设置了left和top */
7                 top: 20px;            
8             }
```



### position: absolute

MDN的描述：

> 不为元素预留空间（即脱离 normal flow），通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margin），且不会与其他边距合并。

生成绝对定位的元素，其位置相对于 最近一级、 position 不是 static 定位的 父级元素 进行定位，会脱离normal flow。

**注意：是非static的父级元素**。

```html
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <meta name="viewport" content="width=device-width, initial-scale=1.0">
 6     <meta http-equiv="X-UA-Compatible" content="ie=edge">
 7     <title>CSS-position-static</title>
 8     <link rel="stylesheet" href="https://cdn.bootcss.com/normalize/8.0.0/normalize.css">
 9     <style>
10         .container{
11             background-color: #868686;
12             width: 100%;
13             height: 300px;
14             margin-top: 50px;
15         }
16         .content{
17             background-color: red;
18             width: 100px;
19             height: 100px;
20             position: absolute;
21             top: 10px;
22         }
23     </style>
24 </head>
25 <body>
26     <div class="container">
27         <div class="content">    
28         </div>
29     </div>
30 </body>
31 </html>
```

因为 content 的父元素 container 没有设置 position，默认为 static，所以找到的第一个父元素是 body（<body></body>），可以看成是元素（content）相对于 body 向下移动10px。



### position: fixed

MDN的描述

> 不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。

fixed相对于window固定，滚动浏览器窗口并不会使其移动，会脱离normal flow。

```html
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <meta name="viewport" content="width=device-width, initial-scale=1.0">
 6     <meta http-equiv="X-UA-Compatible" content="ie=edge">
 7     <title>CSS-position-static</title>
 8     <link rel="stylesheet" href="https://cdn.bootcss.com/normalize/8.0.0/normalize.css">
 9     <style>
10         .container{
11             background-color: #868686;
12             width: 100%;
13             height: 1000px;
14         }
15         .content{
16             background-color: yellow;
17             width: 100px;
18             height: 100px;
19             position: fixed;/* 这里使用了fixed */
20         }
21     </style>
22 </head>
23 <body>
24     <div class="container">
25         <div class="content">    
26         </div>
27     </div>
28 </body>
29 </html>
```



### position: sticky

MDN的描述

> 盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table`时`），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky对 table元素的效果与 position: relative 相同。

因为各大浏览器对于sticky的兼容问题，而且JS也可以实现这个功能，在这里就不进行深入了，了解一下就好。



### position: inherit

[w3school.com](http://www.w3school.com.cn/cssref/pr_class_position.asp)的 描述：

> 规定应该从父元素继承 position 属性的值。





## 三、理解display和visibility

### display

display 控制元素的显示类型和可见性。

| 值                 | 描述                                                         |
| :----------------- | ------------------------------------------------------------ |
| none               | 此元素不会被显示。隐藏元素，将其从文档流中完全删除，不会占用文档流中的位置。 |
| block              | 此元素将显示为块级元素，此元素前后会带有换行符。             |
| inline             | 默认。此元素会被显示为内联元素，元素前后没有换行符。设置为inline的元素会忽略任何width、height、margin-top 和 margin-bottom 设置；但 padding-top 和 padding-bottom 会越界进入相邻元素的区域，而不是局限于该元素本身的空间。 |
| inline-block       | 行内块元素（CSS2.1 新增的值）。元素前后没有换行符，但此时可使 inline 忽略的空间属性生效。 |
| list-item          | 此元素会作为列表显示。<li> 标签 display 的默认值。           |
| run-in             | 此元素会根据上下文作为块级元素或内联元素显示。               |
| table              | 此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。 |
| inline-table       | 此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。 |
| table-row-group    | 此元素会作为一个或多个行的分组来显示（类似 <tbody>）。       |
| table-header-group | 此元素会作为一个或多个行的分组来显示（类似 <thead>）。       |
| table-footer-group | 此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。       |
| table-row          | 此元素会作为一个表格行显示（类似 <tr>）。                    |
| table-column-group | 此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。    |
| table-column       | 此元素会作为一个单元格列显示（类似 <col>）                   |
| table-cell         | 此元素会作为一个表格单元格显示（类似 <td> 和 <th>）          |
| table-caption      | 此元素会作为一个表格标题显示（类似 <caption>）               |
| inherit            | 规定应该从父元素继承 display 属性的值。                      |



### visibility

visibility 属性规定元素是否可见。

**提示：**即使不可见的元素也会占据页面上的空间。请使用 "display" 属性来创建不占据页面空间的不可见元素。

| 值       | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| visible  | 默认值。元素是可见的。                                       |
| hidden   | 元素是不可见的。与 display:none 的区别是，visibility:hidden 元素虽然不可见，但仍在文档流中占据位置空间。 |
| collapse | 当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 "hidden"。 |
| inherit  | 规定应该从父元素继承 visibility 属性的值。                   |



## 四、CSS中选择器的优先级关系

### 1. CSS三大特性

- **继承：**即子类元素继承父类的样式;

- **优先级：**是指不同类别样式的权重比较;

- **层叠：**是说当数量相同时，通过层叠(后者覆盖前者)的样式。



### 2. CSS选择符

1. 标签选择器(如：body,div,p,ul,li)

2. 类选择器(如：class="head",class="head_logo")
3. ID选择器(如：id="name",id="name_txt")
4. 全局选择器(如：*号)
5. 组合选择器(如：.head .head_logo,注意两选择器用空格键分开)
6. 后代选择器 (如：#head .nav ul li 从父集到子孙集的选择器)
7. 群组选择器 div,span,img {color:Red} 即具有相同样式的标签分组显示
8. 继承选择器(如：div p,注意两选择器用空格键分开)
9. 伪类选择器(如：链接样式，a元素的伪类，4种不同的状态：link、visited、active、hover。以 a:link 表示)
10. 字符串匹配的属性选择符(^ $ *三种，分别对应开始、结尾、包含)
11. 子选择器 (如：div>p ,带大于号>)
12. CSS 相邻兄弟选择器器 (如：h1+p,带加号+)



### 3. CSS 选择器的优先级关系

见 本章 第一小节：一、 CSS选择器优先级及判定标准



### 4. CSS 选择器的解析原则

郑重声明：**CSS选择器定位DOM元素是从右往左的方向，这样的好处是尽早的过滤掉一些无关的样式规则和元素 。**



### 5. 简洁、高效的CSS

所谓高效就是让浏览器查找更少的元素标签来确定匹配的style元素。

1. 不要在ID选择器前使用标签名

   解释：ID选择是唯一的，加上标签名相当于画蛇添足了，没必要。

2. 不要在类选择器前使用标签名

   解释：如果没有相同的名字出现就是没必要，但是如果存在多个相同名字的类选择器则有必要添加标签名防止混淆如：

   ```css
   p.colclass {color：red;} 
   span.colclass {color:red;}
   ```

3. 尽量少使用层级关系

   ```css
   #divclass p.colclass {color:red;}
   /* 修改为 */
   .colclass {color:red;}
   ```

4. 使用类选择器代替层级关系（如上） 





## 五、CSS隐藏元素的方式

### 1.display:none

不为被隐藏的对象保留其物理空间，即该对象在页面上彻底消失，通俗来说就是看不见也摸不到。具体表现如下：

> 1.DOM结构，浏览器不会渲染display:none的元素，不占据空间；
>  2.事件监听：无法进行DOM事件监听；
>  3.性能：动态改变此属性会引起重排，性能较差；
>  4.继承：不会被子元素继承，毕竟子类也不会渲染；
>  5.transition：transition不支持display。



### 2.visibility: hidden

使对象在网页上不可见，但该对象在网页上所占的空间没有改变，通俗来说就是看不见但摸得到。具体表现如下：

> 1.DOM结构：被渲染，但是被隐藏，会占据空间；
>  2.事件监听：无法进行DOM事件监听；
>  3.性能：动态改变此属性会引起重绘，性能较高；
>  4.继承：会被子元素继承，子元素可以通过设置visibility:visible来取消隐藏；
>  5.transition：visibility会立即显示，隐藏时会延时。



### 3.opacity: 0

与visibility: hidden相似，使对象在网页上不可见，但该对象在网页上所占的空间没有改变，但是可以进行DOM事件监听，visibility：hidden不可以，通俗来说就是看不见但是摸得着。具体表现如下：

> 1.DOM结构：透明度为100%，元素被隐藏，会占据空间；
>  2.事件监听：可以进行DOM事件监听；
>  3.性能：提升为合成层，不会引起重绘，性能较高；
>  4.继承：会被子元素继承，子元素并不能通过opacity:1来取消隐藏；
>  5.transition：opacity可以延迟显示和隐藏。



### 4.隐藏元素的其他方法

#### position

position:absolute 设置元素的position与left，top，bottom，right等，将元素移出至可视区域外，它不会影响布局，能够让元素保持可操作性，在读屏软件上可以被识别。

#### transform

transform:rotatex(90deg)或 transform:rotateY(90deg)，与opacity: 0相似，但无法进行事件监听。

#### 通过z-index隐藏







## 六、图片懒加载的原理

### 懒加载的定义

懒加载是一种设计模式，被运用在软件设计和网页设计当中，对于网页界面，其特征为用户透过鼠标，滚动浏览页面，直到页面下方时，就会自动加载更多内容。



### 懒加载的优势

1. 首先它能提升用户的体验，试想一下，如果打开页面的时候就将页面上所有的图片全部获取加载，如果图片数量较大，对于用户来说简直就是灾难，会出现卡顿现象，影响用户体验。
2. 有选择性地请求图片，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。



### 懒加载的原理

**页面在浏览器中打开，img标签的src属性会自动请求其图片地址，实现懒加载先使用自定义属性(例:data-src)来保存图片地址，避免img的自动加载。然后js监听父元素的scroll事件，当此图片出现在可视区域后，js再把自定义src设置为图片src，实现懒加载。**



示例：

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title> LazyLoad </title>
    <style>
        #xz {
            height: 20em;
            width: 30em;
            border: 1px solid black;
            overflow: auto;
        }
        #title {
            height: 40em;
            width: 30em;
        }
        #xz:is(:hover) {
            color: red
        }
    </style>
</head>
<body>
<div id="xz">
    <p id="title">
        啦啦啦我是卖报的小行家
    </p>
    <img width="200" height="150" id="img" src="#" alt="demo" data-src="./ElasticSearch/20211101155841.jpg">
</div>
<script type="text/javascript">
    var view = document.getElementById("xz");
    var img = document.getElementById("img");

    // 真实回调Handler
    function lazyLoad() {
        if (img.getAttribute("src") == "#") {
            var clientHeight = view.clientHeight;
            var scrollTop = view.scrollTop;

            // offsetTop 表示当前元素到父级元素顶部的距离
            // clientHeight 表示元素可视区域高度
            // scrollTop 表示滚动出可视区域的高度
            if (img.offsetTop < clientHeight + scrollTop){
                    img.src = img.getAttribute("data-src");  // 属性 data-src 直接通过 .data-src 调用，-将被识别成运算符
                }
        }
    }

    // 节流函数
  	// 由于是监听scroll事件，回调回被频繁触发，增加一个节流函数。
  	// 去抖相比较节流函数要稍微简单一点，去抖是让函数延迟执行，而节流比去抖多了一个在一定时间内必须要执行一次。
    function throttle(func, delay, time) {
      let timeout;
      let starttime = new Date();

      return function() {
        // 获取this对象、入参，传递给func
        let context = this;
        let args = Array.prototype.slice.call(arguments);

        let currenttime = new Date();

        // 清除延时器
        clearTimeout(timeout);

        // 判断触发时间
        if (currenttime - starttime >= time) {
          func(context, args);
          starttime = currenttime;
        } else {
          timeout = setTimeout(function() {
            func(context, args);
          }, delay);
        }
      };
    }

    // 监听事件
    view.addEventListener("scroll", throttle(lazyLoad, 1000, 3000));
</script>
</body>
</html>
```



## 七、CSS3 增加了哪些新特性



## 八、浮动元素引起的问题和解决办法



## 九、CSS3中flexbox的作用及应用场景



## 十、如何用伪类实现一个上三角



# JS类

## 一、怎么判断两个对象相等



## 二、数组相关的操作方法



## 三、JS中常见的DOM操作API



## 四、什么是闭包



## 五、解释事件冒泡和事件捕获



## 六、JS如何实现重载和多态



## 七、深拷贝的原理是什么



## 八、JS中实现继承的方式



## 九、深入理解this关键字



## 十、call、applay、bind的区别



# Vue类

## 一、vue中computed和watch的区别



## 二、深入理解vue中的插槽



## 三、vue中路由的使用步骤



## 四、vue的生命周期



## 五、深入理解 MVC、MVVM



## 六、vue双向绑定的原理



## 七、vue实现父组件向子组件传递数据



## 八、vue中如何自定义一个过滤器



## 九、如何开发一个vue插件



## 十、vue中如何实现给样式添加作用域，其实现原理是什么


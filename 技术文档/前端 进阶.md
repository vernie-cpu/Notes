## 一、前端jsonp跨域方案原理

**背景：**

由于浏览器同源策略的限制，非同源下的请求，都会产生跨域问题，jsonp即是为了解决这个问题出现的一种简便解决方案。

**同源策略即：同一协议，同一域名，同一端口号。当其中一个不满足时，我们的请求即会发生跨域问题。**

**举个简单的例子：**

​	http://www.abc.com:3000到https://www.abc.com:3000的请求会出现跨域（域名、端口相同但协议不同）
​	http://www.abc.com:3000到http://www.abc.com:3001的请求会出现跨域（域名、协议相同但端口不同）
​	http://www.abc.com:3000到http://www.def.com:3000的请求会出现跨域（域名不同）



**JSONP跨域原理：**

-  **Jsonp(JSON with Padding)** 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。

- 我们注意到，script标签的src还是img标签的src，或者说link标签的href他们没有被同源策略所限制。jsonp就是使用同源策略这一“漏洞”，实现的跨域请求。

- JSONP就是利用了sscript标签的src属性发起的跨域请求，由于script标签的作用是用来执行src指定的js代码，那么我们可以跟后端协商一个函数名，后端将要返回的数据作为函数的参数，一起返回给前端，前端事先定义好该函数，这样就完成了跨域请求。



**JSONP的缺点：**

- 首先，它没有关于JSONP调用的错误处理，一旦回调函数调用失败，浏览器会以静默失败的方式处理。
- 其次，它只支持GET请求，这是由于该技术本身的特性所决定的。因此，对于一些需要对安全性有要求的跨域请求，JSONP的使用需要谨慎一点了。
- JSONP不支持用async:false的方法设置同步。



**JSONP使用举例：**

 - **跨域执行远端的服务器中的js代码**

   apache服务器中的remote.js  

   > apache静态文件路径：/var/www/html/
   >
   > 执行远端的js文件，或者回调函数等需要把资源当作脚本运行的，只能用script标签，否则将不会按照脚本去执行

   ``` js
   alert("我是远程文件");
   ```

   本地html文件jsonp.html

   ``` html
   <!DOCTYPE html>
   <html xmlns="http://www.w3.org/1999/xhtml">
   <head>
       <title> JSONP </title>
       <!--charset 解决文本乱码-->
       <script charset="UTF-8" type="text/javascript" src="http://121.4.47.229/jsonp/remote.js"></script>
   </head>
   <body>
       来了老弟
   </body>
   </html>
   ```

- **远端的js也可以调用本地的脚本函数**

  remote.js

  ``` js
  handleFunc({"result": "我在远端入参"});
  ```

  jsonp.html

  ``` html
  <!DOCTYPE html>
  <html xmlns="http://www.w3.org/1999/xhtml">
  
  <head >
      <meta charset="UTF-8">
      <title> JSONP </title>
      <script type="text/javascript">
          var handleFunc = function(data) {
          alert("本地文件被远程js调用了。远程入参：" + data.result);
          }
      </script>
      <script charset="UTF-8" type="text/javascript" src="http://121.4.47.229/jsonp/remote.js"></script>
  </head>
  <body>
  来了老弟
  </body>
  </html>
  ```

- **服务器动态的生成js代码**

  本地jsonp.html文件

  ``` html
  <!DOCTYPE html>
  <html xmlns="http://www.w3.org/1999/xhtml">
  
  <head>
      <meta charset="UTF-8">
      <title> JSONP </title>
      <script type="text/javascript">
          var flightHandler = function(data) {
            if (data.price){
               alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
            }else{
              alert(data);
            }
          }
          var url = "http://127.0.0.1:5000/jsonp?code=CA199202&callback=flightHandler";
          
          // 创建一个script标签
          var script = document.createElement('script');
          
          // 设置标签属性
          script.setAttribute('src', url);
        	script.setAttribute('charset', "UTF-8");
        	script.setAttribute('type', "text/javascript");
        
        	// 把标签添加到head中
        	document.getElementsByTagName('head')[0].appendChild(script);
      </script>
  </head>
  <body>
  来了老弟
  </body>
  </html>
  ```

  服务端文件demo.py

  > 这里使用flask快速实现一个API，返回值前端作为js代码执行

  ``` python
  import json
  
  from flask import Flask, request
  
  app = Flask(__name__)
  
  
  @app.route('/jsonp', methods=['GET'])
  def index():
      func = request.args.get('callback')
      flight_name = request.args.get('code')
  
      # 航班信息
      flight = {
          "CA199202": {
              'price': 1200,
              'tickets': 37
          },
          "SA6532K": {
              'price': 900,
              'tickets': 60
          }
      }
  
      if flight.get(flight_name):
          # 以json字符串形式返回js脚本
          return func + "(" + json.dumps(flight.get(flight_name)) + ")"
      else:
          return func + "('无航班信息')"
  
  
  if __name__ == '__main__':
      app.run()
  
  ```

- **扩展**

  > Vue前端跨域插件：[Vue-jsonp](https://www.npmjs.com/package/vue-jsonp)
  >
  > 跨域问题，前端通过jsonp方式可以解决；后端服务器也可以配置请求白名单等方式解决。



## 二、OPTIONS 请求

- 背景

  > 出于安全考虑，并不是所有域名访问后端服务都可以。在正式跨域之前，浏览器会根据需要发起一次预检(也就是option请求)，用来让服务端返回允许的方法(如get、post)，被跨域访问的Origin(来源或者域)，还有是否需要Credentials(认证信息)等。

- 简单请求

  - 简单请求条件
    - 方式只能是：GET、POST、HEAD
    - HTTP请求头限制这几种字段：Accept、Accept-Language、Content-Language、Content-Type、Last-Event-ID
    - Content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain
  - **对于简单请求，浏览器直接请求，会在请求头信息中，增加一个origin字段，来说明本次请求来自哪个源（协议+域名+端口）。服务器根据这个值，来决定是否同意该请求，服务器返回的响应会多几个头信息字段。**
    - Access-Control-Allow-Origin：该字段是必须的，* 表示接受任意域名的请求，还可以指定域名，如www.baidu.com
    - Access-Control-Allow-Credentials：该字段可选，是个布尔值，表示是否可以携带cookie。（注意：如果Access-Control-Allow-Origin字段设置*，此字段设为true无效）
    - Access-Control-Allow-Headers：该字段可选，里面可以获取Cache-Control、Content-Type、Expires等，如果想要拿到其他字段，就可以在这个字段中指定。

- 复杂请求

  - **非简单请求是对那种对服务器有特殊要求的请求，比如请求方式是PUT或者DELETE，或者Content-Type字段类型是application/json。都会在正式通信之前，增加一次HTTP请求，称之为预检。浏览器会先询问服务器，当前网页所在域名是否在服务器的许可名单之中，服务器允许之后，浏览器会发出正式的XMLHttpRequest请求，否则会报错。**
    - 与检测的请求方式就是options。
    - options 请求不会携带 cookie 和 请求参数 等信息。

 - 总结

   > options 请求就是预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。

## 一、前端jsonp跨域方案原理

**背景：**

由于浏览器同源策略的限制，非同源下的请求，都会产生跨域问题，jsonp即是为了解决这个问题出现的一种简便解决方案。

**同源策略即：同一协议，同一域名，同一端口号。当其中一个不满足时，我们的请求即会发生跨域问题。**

**举个简单的例子：**

​	http://www.abc.com:3000到https://www.abc.com:3000的请求会出现跨域（域名、端口相同但协议不同）
​	http://www.abc.com:3000到http://www.abc.com:3001的请求会出现跨域（域名、协议相同但端口不同）
​	http://www.abc.com:3000到http://www.def.com:3000的请求会出现跨域（域名不同）



**JSONP跨域原理：**

-  **Jsonp(JSON with Padding)** 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。

- 我们注意到，script标签的src还是img标签的src，或者说link标签的href他们没有被同源策略所限制。jsonp就是使用同源策略这一“漏洞”，实现的跨域请求。

- JSONP就是利用了sscript标签的src属性发起的跨域请求，由于script标签的作用是用来执行src指定的js代码，那么我们可以跟后端协商一个函数名，后端将要返回的数据作为函数的参数，一起返回给前端，前端事先定义好该函数，这样就完成了跨域请求。



**JSONP的缺点：**

- 首先，它没有关于JSONP调用的错误处理，一旦回调函数调用失败，浏览器会以静默失败的方式处理。
- 其次，它只支持GET请求，这是由于该技术本身的特性所决定的。因此，对于一些需要对安全性有要求的跨域请求，JSONP的使用需要谨慎一点了。
- JSONP不支持用async:false的方法设置同步。



**JSONP使用举例：**

 - **跨域执行远端的服务器中的js代码**

   apache服务器中的remote.js  

   > apache静态文件路径：/var/www/html/
   >
   > 执行远端的js文件，或者回调函数等需要把资源当作脚本运行的，只能用script标签，否则将不会按照脚本去执行

   ``` js
   alert("我是远程文件");
   ```

   本地html文件jsonp.html

   ``` html
   <!DOCTYPE html>
   <html xmlns="http://www.w3.org/1999/xhtml">
   <head>
       <title> JSONP </title>
       <!--charset 解决文本乱码-->
       <script charset="UTF-8" type="text/javascript" src="http://121.4.47.229/jsonp/remote.js"></script>
   </head>
   <body>
       来了老弟
   </body>
   </html>
   ```

- **远端的js也可以调用本地的脚本函数**

  remote.js

  ``` js
  handleFunc({"result": "我在远端入参"});
  ```

  jsonp.html

  ``` html
  <!DOCTYPE html>
  <html xmlns="http://www.w3.org/1999/xhtml">
  
  <head >
      <meta charset="UTF-8">
      <title> JSONP </title>
      <script type="text/javascript">
          var handleFunc = function(data) {
          alert("本地文件被远程js调用了。远程入参：" + data.result);
          }
      </script>
      <script charset="UTF-8" type="text/javascript" src="http://121.4.47.229/jsonp/remote.js"></script>
  </head>
  <body>
  来了老弟
  </body>
  </html>
  ```

- **服务器动态的生成js代码**

  本地jsonp.html文件

  ``` html
  <!DOCTYPE html>
  <html xmlns="http://www.w3.org/1999/xhtml">
  
  <head>
      <meta charset="UTF-8">
      <title> JSONP </title>
      <script type="text/javascript">
          var flightHandler = function(data) {
            if (data.price){
               alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
            }else{
              alert(data);
            }
          }
          var url = "http://127.0.0.1:5000/jsonp?code=CA199202&callback=flightHandler";
          
          // 创建一个script标签
          var script = document.createElement('script');
          
          // 设置标签属性
          script.setAttribute('src', url);
        	script.setAttribute('charset', "UTF-8");
        	script.setAttribute('type', "text/javascript");
        
        	// 把标签添加到head中
        	document.getElementsByTagName('head')[0].appendChild(script);
      </script>
  </head>
  <body>
  来了老弟
  </body>
  </html>
  ```

  服务端文件demo.py

  > 这里使用flask快速实现一个API，返回值前端作为js代码执行

  ``` python
  import json
  
  from flask import Flask, request
  
  app = Flask(__name__)
  
  
  @app.route('/jsonp', methods=['GET'])
  def index():
      func = request.args.get('callback')
      flight_name = request.args.get('code')
  
      # 航班信息
      flight = {
          "CA199202": {
              'price': 1200,
              'tickets': 37
          },
          "SA6532K": {
              'price': 900,
              'tickets': 60
          }
      }
  
      if flight.get(flight_name):
          # 以json字符串形式返回js脚本
          return func + "(" + json.dumps(flight.get(flight_name)) + ")"
      else:
          return func + "('无航班信息')"
  
  
  if __name__ == '__main__':
      app.run()
  
  ```

- **扩展**

  > Vue前端跨域插件：[Vue-jsonp](https://www.npmjs.com/package/vue-jsonp)
  >
  > 跨域问题，前端通过jsonp方式可以解决；后端服务器也可以配置请求白名单等方式解决。






# 综合类

## 一、前端jsonp跨域方案原理

**背景：**

由于浏览器同源策略的限制，非同源下的请求，都会产生跨域问题，jsonp即是为了解决这个问题出现的一种简便解决方案。

**同源策略即：同一协议，同一域名，同一端口号。当其中一个不满足时，我们的请求即会发生跨域问题。**

**举个简单的例子：**

​	http://www.abc.com:3000到https://www.abc.com:3000的请求会出现跨域（域名、端口相同但协议不同）
​	http://www.abc.com:3000到http://www.abc.com:3001的请求会出现跨域（域名、协议相同但端口不同）
​	http://www.abc.com:3000到http://www.def.com:3000的请求会出现跨域（域名不同）



**JSONP跨域原理：**

-  **Jsonp(JSON with Padding)** 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。

- 我们注意到，script标签的src还是img标签的src，或者说link标签的href他们没有被同源策略所限制。jsonp就是使用同源策略这一“漏洞”，实现的跨域请求。

- JSONP就是利用了sscript标签的src属性发起的跨域请求，由于script标签的作用是用来执行src指定的js代码，那么我们可以跟后端协商一个函数名，后端将要返回的数据作为函数的参数，一起返回给前端，前端事先定义好该函数，这样就完成了跨域请求。



**JSONP的缺点：**

- 首先，它没有关于JSONP调用的错误处理，一旦回调函数调用失败，浏览器会以静默失败的方式处理。
- 其次，它只支持GET请求，这是由于该技术本身的特性所决定的。因此，对于一些需要对安全性有要求的跨域请求，JSONP的使用需要谨慎一点了。
- JSONP不支持用async:false的方法设置同步。



**JSONP使用举例：**

 - **跨域执行远端的服务器中的js代码**

   apache服务器中的remote.js  

   > apache静态文件路径：/var/www/html/
   >
   > 执行远端的js文件，或者回调函数等需要把资源当作脚本运行的，只能用script标签，否则将不会按照脚本去执行

   ``` js
   alert("我是远程文件");
   ```

   本地html文件jsonp.html

   ``` html
   <!DOCTYPE html>
   <html xmlns="http://www.w3.org/1999/xhtml">
   <head>
       <title> JSONP </title>
       <!--charset 解决文本乱码-->
       <script charset="UTF-8" type="text/javascript" src="http://121.4.47.229/jsonp/remote.js"></script>
   </head>
   <body>
       来了老弟
   </body>
   </html>
   ```

- **远端的js也可以调用本地的脚本函数**

  remote.js

  ``` js
  handleFunc({"result": "我在远端入参"});
  ```

  jsonp.html

  ``` html
  <!DOCTYPE html>
  <html xmlns="http://www.w3.org/1999/xhtml">
  
  <head >
      <meta charset="UTF-8">
      <title> JSONP </title>
      <script type="text/javascript">
          var handleFunc = function(data) {
          alert("本地文件被远程js调用了。远程入参：" + data.result);
          }
      </script>
      <script charset="UTF-8" type="text/javascript" src="http://121.4.47.229/jsonp/remote.js"></script>
  </head>
  <body>
  来了老弟
  </body>
  </html>
  ```

- **服务器动态的生成js代码**

  本地jsonp.html文件

  ``` html
  <!DOCTYPE html>
  <html xmlns="http://www.w3.org/1999/xhtml">
  
  <head>
      <meta charset="UTF-8">
      <title> JSONP </title>
      <script type="text/javascript">
          var flightHandler = function(data) {
            if (data.price){
               alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。');
            }else{
              alert(data);
            }
          }
          var url = "http://127.0.0.1:5000/jsonp?code=CA199202&callback=flightHandler";
          
          // 创建一个script标签
          var script = document.createElement('script');
          
          // 设置标签属性
          script.setAttribute('src', url);
        	script.setAttribute('charset', "UTF-8");
        	script.setAttribute('type', "text/javascript");
        
        	// 把标签添加到head中
        	document.getElementsByTagName('head')[0].appendChild(script);
      </script>
  </head>
  <body>
  来了老弟
  </body>
  </html>
  ```

  服务端文件demo.py

  > 这里使用flask快速实现一个API，返回值前端作为js代码执行

  ``` python
  import json
  
  from flask import Flask, request
  
  app = Flask(__name__)
  
  
  @app.route('/jsonp', methods=['GET'])
  def index():
      func = request.args.get('callback')
      flight_name = request.args.get('code')
  
      # 航班信息
      flight = {
          "CA199202": {
              'price': 1200,
              'tickets': 37
          },
          "SA6532K": {
              'price': 900,
              'tickets': 60
          }
      }
  
      if flight.get(flight_name):
          # 以json字符串形式返回js脚本
          return func + "(" + json.dumps(flight.get(flight_name)) + ")"
      else:
          return func + "('无航班信息')"
  
  
  if __name__ == '__main__':
      app.run()
  
  ```

- **扩展**

  > Vue前端跨域插件：[Vue-jsonp](https://www.npmjs.com/package/vue-jsonp)
  >
  > 跨域问题，前端通过jsonp方式可以解决；后端服务器也可以配置请求白名单等方式解决。



## 二、OPTIONS 请求

- 背景

  > 出于安全考虑，并不是所有域名访问后端服务都可以。在正式跨域之前，浏览器会根据需要发起一次预检(也就是option请求)，用来让服务端返回允许的方法(如get、post)，被跨域访问的Origin(来源或者域)，还有是否需要Credentials(认证信息)等。

- 简单请求

  - 简单请求条件
    - 方式只能是：GET、POST、HEAD
    - HTTP请求头限制这几种字段：Accept、Accept-Language、Content-Language、Content-Type、Last-Event-ID
    - Content-type只能取：application/x-www-form-urlencoded、multipart/form-data、text/plain
  - **对于简单请求，浏览器直接请求，会在请求头信息中，增加一个origin字段，来说明本次请求来自哪个源（协议+域名+端口）。服务器根据这个值，来决定是否同意该请求，服务器返回的响应会多几个头信息字段。**
    - Access-Control-Allow-Origin：该字段是必须的，* 表示接受任意域名的请求，还可以指定域名，如www.baidu.com
    - Access-Control-Allow-Credentials：该字段可选，是个布尔值，表示是否可以携带cookie。（注意：如果Access-Control-Allow-Origin字段设置*，此字段设为true无效）
    - Access-Control-Allow-Headers：该字段可选，里面可以获取Cache-Control、Content-Type、Expires等，如果想要拿到其他字段，就可以在这个字段中指定。

- 复杂请求

  - **非简单请求是对那种对服务器有特殊要求的请求，比如请求方式是PUT或者DELETE，或者Content-Type字段类型是application/json。都会在正式通信之前，增加一次HTTP请求，称之为预检。浏览器会先询问服务器，当前网页所在域名是否在服务器的许可名单之中，服务器允许之后，浏览器会发出正式的XMLHttpRequest请求，否则会报错。**
    - 与检测的请求方式就是options。
    - options 请求不会携带 cookie 和 请求参数 等信息。

 - 总结

   > options 请求就是预检请求，可用于检测服务器允许的 http 方法。当发起跨域请求时，由于安全原因，触发一定条件时浏览器会在正式请求之前自动先发起 OPTIONS 请求，即 CORS 预检请求，服务器若接受该跨域请求，浏览器才继续发起正式请求。





# CSS类

##  一、 CSS选择器优先级及判定标准

### 1. 优先级分级

1. **!important**

   ```css
   .foo {
     color:red !important
   }
   ```

   !important是顶级优先级，唯一推荐使用它的场景为`忽略JS脚本设置的样式，使js设置样式无效`。对于其他场景都没有使用它的理由，`切勿滥用`

2. **style属性内联样式**

   ```html
   <span style="color: red;">内联样式</span>
   ```

3. **ID选择器**

   ```css
   #id {
     color:red
   }
   ```

4. **类选择器**

   ```css
   .foo {
     color:red
   }
   /* disabled状态的标签设置为灰色 */
   [disabled]{
     color: grey
   }
   /* 伪类选择器和类选择器同级 */
   p:hover {
     color:blue
   }
   ```

5. **标签选择器**

   ```css
   body {
     background: white
   }
   ```

6. **通配选择器，选择符和逻辑组合伪类**

   ```css
   * {
     color:red
   }
   :not() {
     color:blue
   }
   /*
   通配选择器统一指*
   
   选择符包括+，-，~，空格和||
   
   逻辑组合伪类包括:not()，:is()，:where()等，这些伪类本身并不影响CSS优先级，影响优先级的是()里的选择器
   */
   ```



### 2. 优先级计算

除开!important和style属性内联样式（因为一个是第一顶级的优先级，另一个是写在HTML标签属性上的第二顶级优先级），在CSS样式中写的选择器样式的优先级满足以下计算规则：

- 每出现一个`ID选择器`，优先级数值`+100`
- 每出现一个`class、属性（href、rel、src等） 或 伪类选择器`，优先级数值`+10`
- 每出现一个`标签选择器`，优先级数值`+1`
- 每出现一个`通配选择器，选择符和逻辑组合伪类`，优先级数值`+0`
- 继承的CSS样式优先级为0
- 若两个选择器最终优先级计算数值相等，则后渲染的选择器优先级更高（**后渲染是相对整个HTML文档的CSS样式渲染顺序来讲的，并非单个CSS文件）**



示例：

```css
/* 优先级：1+0+10 = 11

	根据给定属性的值选择元素。
  语法：[attr] [attr=value] [attr~=value] [attr|=value] [attr^=value] [attr$=value] [attr*=value] [autoplay]
	示例表示：rel属性不是nofollow的a标签样式
*/
a:not([rel=nofollow]) {
}

/* 优先级：1+10+0+10 = 21
	示例表示：body标签中，有foo类，且没有dir属性的标签样式
*/
body .foo:not([dir]){
}
body .foo:is(:hover) {
}

/* 优先级：100+10+1 = 111 */
#foo .bar p {}
```



**增加优先级的方法**

实际开发调节样式时，难免会遇到需要增加CSS选择器优先级去匹配样式的场景，很多人是采取增加CSS样式嵌套来增加优先级数值的做法，如下：

```css
/* 原优先级 */
.foo {}

/* 增加优先级 */
.father .foo {}
```

但是这种做法增加了CSS样式与HTML结构的耦合度，降低了可维护性，推荐如下做法：

```css
/* 重复选择器自身即可 */
.foo .foo {}
```



**优先级注意事项**

- **CSS选择器优先级与DOM元素的层级位置没有关系**

  ```css
  body .foo {
    color: red
  }
  html .foo {
    color:blue
  }
  ```

  这里虽然第二个选择器在第一个选择器渲染后，但有人会考虑到body是html的子元素，距离.foo元素更近，所以应该是红色。但是DOM层级距离是对CSS选择器优先级没有任何影响的，所以按照`优先级数值相等，后渲染优先`的原则，.foo元素是蓝色。

- **选择器优先级越级现象**

  ```css
  #text {
    color:red
  }
  .text {
    color:blue
  }
  ```

  ```html
  <span id="text" class="text">颜色</span>
  ```

  根据id选择器 优先级大于class选择器的原则可知应该是红色。但是如果是下面这种情况呢？

  ```css
      /*如果有256个.text组合而成的选择器*/
      .text.text.text.text...{
          color:blue
      }
  ```

  有人认为class选择器优先级数值为10，如果同时256个，那肯定比只有一个id的id选择器优先级高！

  **实际上，在过去大多浏览器确实是这样的，FireFox浏览器早年的源码表示class类名以8字节字符串存储，所能容纳的最大值为255，超过就会溢出到ID选择器区域。**

  **但是后来`除了IE浏览器`，其他浏览器都修改了策略——`再多的选择器优先级也无法超过比它更高一级的选择器`。**

  **所以这里的文字颜色依然是红色。**





## 二、position 的属性值

> CSS position属性用于指定一个元素在文档中的定位方式。top、right、bottom、left 属性则决定了该元素的最终位置。
>
> position 取值有：static、relative、absolute、fixed、sticky、inherit

然后来看看什么是文档流(normal flow)，下面是 [www.w3.org](https://www.w3.org/TR/CSS21/visuren.html#) 的描述：

> **Normal flow**
>
> Boxes in the normal flow belong to a formatting context, which may be block or inline, but not both simultaneously. [Block-level](https://www.w3.org/TR/CSS21/visuren.html#block-level) boxes participate in a [block formatting](https://www.w3.org/TR/CSS21/visuren.html#block-formatting) context. [Inline-level boxes](https://www.w3.org/TR/CSS21/visuren.html#inline-level) participate in an [inline formatting](https://www.w3.org/TR/CSS21/visuren.html#inline-formatting) context.

理解 normal flow：

1. normal flow直译为常规流、正常流，国内不知何原因大多译为文档流；
2. 窗体自上而下分成一行一行，并在每行中按从左至右的顺序排放元素；
3. 每个非浮动块级元素都独占一行， 浮动元素则按规定浮在行的一端，若当前行容不下，则另起新行再浮动；
4. 内联元素也不会独占一行，几乎所有元素(包括块级，内联和列表元素）均可生成子行，用于摆放子元素；
5. 有三种情况将使得元素脱离normal flow而存在，分别是 float，absolute ，fixed，但是在IE6中浮动元素也存在于normal flow中。



### position: static

MDN的描述：

> 该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top、right、bottom、left 属性无效。

对元素设置 position: static，可以覆盖 position其他布局行为设置。**static 是元素的默认值**，这就是元素出现在常规文档流中的原因。

```html
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <title>CSS-position-static</title>
 6     <link rel="stylesheet" href="https://cdn.bootcss.com/normalize/8.0.0/normalize.css">
 7     <style>
 8         .container{
 9             background-color: #868686;
10             width: 100%;
11             height: 300px;
12         }
13         .content{
14             background-color: yellow;
15             width: 100px;
16             height: 100px;
17             position: static;
18             left: 10px;/* 这个left没有起作用 */
19         }
20     </style>
21 </head>
22 <body>
23     <div class="container">
24         <div class="content">    
25         </div>
26     </div>
27 </body>
28 </html>
```

对 content 的 position 设定 static 后，left就失效了，而元素（content）就以正常的 normal flow 形式呈现。



### position: relative

MDN的描述：

> 该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）。position:relative 对 table-*-group, table-row, table-column, table-cell, table-caption 元素无效。

相对于normal flow中的原位置来定位。

```html
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <meta name="viewport" content="width=device-width, initial-scale=1.0">
 6     <meta http-equiv="X-UA-Compatible" content="ie=edge">
 7     <title>CSS-position-relative</title>  
 8     <link rel="stylesheet" href="https://cdn.bootcss.com/normalize/8.0.0/normalize.css">
 9     <style>
10             .container{
11                 background-color: #868686;
12                 width: 100%;
13                 height: 300px;
14             }
15             .content_0{
16                 background-color: yellow;
17                 width: 100px;
18                 height: 100px;               
19             }
20             .content_1{
21                 background-color: red;
22                 width: 100px;
23                 height: 100px;
24                 position: relative;/* 这里使用了relative，此时没有指定偏移量，所以还是正常的出现在 normal flow*/            
25             }
26             .content_2{
27                 background-color: black;
28                 width: 100px;
29                 height: 100px;               
30             }
31         </style>
32     </head>
33     <body>
34         <div class="container">
35             <div class="content_0">    
36             </div>
37             <div class="content_1">    
38             </div>
39             <div class="content_2">    
40             </div>
41         </div>   
42 </body>
43 </html>
```

为content_1添加偏移量后，可以看到相对于自身原来的位置发生了偏移。

```html
1 .content_1{
2                 background-color: red;
3                 width: 100px;
4                 height: 100px;
5                 position: relative;/* 这里使用了relative  */
6                 left: 20px;/* 这里设置了left和top */
7                 top: 20px;            
8             }
```



### position: absolute

MDN的描述：

> 不为元素预留空间（即脱离 normal flow），通过指定元素相对于最近的非 static 定位祖先元素的偏移，来确定元素位置。绝对定位的元素可以设置外边距（margin），且不会与其他边距合并。

生成绝对定位的元素，其位置相对于 最近一级、 position 不是 static 定位的 父级元素 进行定位，会脱离normal flow。

**注意：是非static的父级元素**。

```html
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <meta name="viewport" content="width=device-width, initial-scale=1.0">
 6     <meta http-equiv="X-UA-Compatible" content="ie=edge">
 7     <title>CSS-position-static</title>
 8     <link rel="stylesheet" href="https://cdn.bootcss.com/normalize/8.0.0/normalize.css">
 9     <style>
10         .container{
11             background-color: #868686;
12             width: 100%;
13             height: 300px;
14             margin-top: 50px;
15         }
16         .content{
17             background-color: red;
18             width: 100px;
19             height: 100px;
20             position: absolute;
21             top: 10px;
22         }
23     </style>
24 </head>
25 <body>
26     <div class="container">
27         <div class="content">    
28         </div>
29     </div>
30 </body>
31 </html>
```

因为 content 的父元素 container 没有设置 position，默认为 static，所以找到的第一个父元素是 body（<body></body>），可以看成是元素（content）相对于 body 向下移动10px。



### position: fixed

MDN的描述

> 不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。

fixed相对于window固定，滚动浏览器窗口并不会使其移动，会脱离normal flow。

```html
 1 <!DOCTYPE html>
 2 <html lang="en">
 3 <head>
 4     <meta charset="UTF-8">
 5     <meta name="viewport" content="width=device-width, initial-scale=1.0">
 6     <meta http-equiv="X-UA-Compatible" content="ie=edge">
 7     <title>CSS-position-static</title>
 8     <link rel="stylesheet" href="https://cdn.bootcss.com/normalize/8.0.0/normalize.css">
 9     <style>
10         .container{
11             background-color: #868686;
12             width: 100%;
13             height: 1000px;
14         }
15         .content{
16             background-color: yellow;
17             width: 100px;
18             height: 100px;
19             position: fixed;/* 这里使用了fixed */
20         }
21     </style>
22 </head>
23 <body>
24     <div class="container">
25         <div class="content">    
26         </div>
27     </div>
28 </body>
29 </html>
```



### position: sticky

MDN的描述

> 盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table`时`），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky对 table元素的效果与 position: relative 相同。

因为各大浏览器对于sticky的兼容问题，而且JS也可以实现这个功能，在这里就不进行深入了，了解一下就好。



### position: inherit

[w3school.com](http://www.w3school.com.cn/cssref/pr_class_position.asp)的 描述：

> 规定应该从父元素继承 position 属性的值。





## 三、理解display和visibility

### display

display 控制元素的显示类型和可见性。

| 值                 | 描述                                                         |
| :----------------- | ------------------------------------------------------------ |
| none               | 此元素不会被显示。隐藏元素，将其从文档流中完全删除，不会占用文档流中的位置。 |
| block              | 此元素将显示为块级元素，此元素前后会带有换行符。             |
| inline             | 默认。此元素会被显示为内联元素，元素前后没有换行符。设置为inline的元素会忽略任何width、height、margin-top 和 margin-bottom 设置；但 padding-top 和 padding-bottom 会越界进入相邻元素的区域，而不是局限于该元素本身的空间。 |
| inline-block       | 行内块元素（CSS2.1 新增的值）。元素前后没有换行符，但此时可使 inline 忽略的空间属性生效。 |
| list-item          | 此元素会作为列表显示。<li> 标签 display 的默认值。           |
| run-in             | 此元素会根据上下文作为块级元素或内联元素显示。               |
| table              | 此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。 |
| inline-table       | 此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。 |
| table-row-group    | 此元素会作为一个或多个行的分组来显示（类似 <tbody>）。       |
| table-header-group | 此元素会作为一个或多个行的分组来显示（类似 <thead>）。       |
| table-footer-group | 此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。       |
| table-row          | 此元素会作为一个表格行显示（类似 <tr>）。                    |
| table-column-group | 此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。    |
| table-column       | 此元素会作为一个单元格列显示（类似 <col>）                   |
| table-cell         | 此元素会作为一个表格单元格显示（类似 <td> 和 <th>）          |
| table-caption      | 此元素会作为一个表格标题显示（类似 <caption>）               |
| inherit            | 规定应该从父元素继承 display 属性的值。                      |



### visibility

visibility 属性规定元素是否可见。

**提示：**即使不可见的元素也会占据页面上的空间。请使用 "display" 属性来创建不占据页面空间的不可见元素。

| 值       | 描述                                                         |
| :------- | :----------------------------------------------------------- |
| visible  | 默认值。元素是可见的。                                       |
| hidden   | 元素是不可见的。与 display:none 的区别是，visibility:hidden 元素虽然不可见，但仍在文档流中占据位置空间。 |
| collapse | 当在表格元素中使用时，此值可删除一行或一列，但是它不会影响表格的布局。被行或列占据的空间会留给其他内容使用。如果此值被用在其他的元素上，会呈现为 "hidden"。 |
| inherit  | 规定应该从父元素继承 visibility 属性的值。                   |



## 四、CSS中选择器的优先级关系

### 1. CSS三大特性

- **继承：**即子类元素继承父类的样式;

- **优先级：**是指不同类别样式的权重比较;

- **层叠：**是说当数量相同时，通过层叠(后者覆盖前者)的样式。



### 2. CSS选择符

1. 标签选择器(如：body,div,p,ul,li)

2. 类选择器(如：class="head",class="head_logo")
3. ID选择器(如：id="name",id="name_txt")
4. 全局选择器(如：*号)
5. 组合选择器(如：.head .head_logo,注意两选择器用空格键分开)
6. 后代选择器 (如：#head .nav ul li 从父集到子孙集的选择器)
7. 群组选择器 div,span,img {color:Red} 即具有相同样式的标签分组显示
8. 继承选择器(如：div p,注意两选择器用空格键分开)
9. 伪类选择器(如：链接样式，a元素的伪类，4种不同的状态：link、visited、active、hover。以 a:link 表示)
10. 字符串匹配的属性选择符(^ $ *三种，分别对应开始、结尾、包含)
11. 子选择器 (如：div>p ,带大于号>)
12. CSS 相邻兄弟选择器器 (如：h1+p,带加号+)



### 3. CSS 选择器的优先级关系

见 本章 第一小节：一、 CSS选择器优先级及判定标准



### 4. CSS 选择器的解析原则

郑重声明：**CSS选择器定位DOM元素是从右往左的方向，这样的好处是尽早的过滤掉一些无关的样式规则和元素 。**



### 5. 简洁、高效的CSS

所谓高效就是让浏览器查找更少的元素标签来确定匹配的style元素。

1. 不要在ID选择器前使用标签名

   解释：ID选择是唯一的，加上标签名相当于画蛇添足了，没必要。

2. 不要在类选择器前使用标签名

   解释：如果没有相同的名字出现就是没必要，但是如果存在多个相同名字的类选择器则有必要添加标签名防止混淆如：

   ```css
   p.colclass {color：red;} 
   span.colclass {color:red;}
   ```

3. 尽量少使用层级关系

   ```css
   #divclass p.colclass {color:red;}
   /* 修改为 */
   .colclass {color:red;}
   ```

4. 使用类选择器代替层级关系（如上） 





## 五、CSS隐藏元素的方式

### 1.display:none

不为被隐藏的对象保留其物理空间，即该对象在页面上彻底消失，通俗来说就是看不见也摸不到。具体表现如下：

> 1.DOM结构，浏览器不会渲染display:none的元素，不占据空间；
>  2.事件监听：无法进行DOM事件监听；
>  3.性能：动态改变此属性会引起重排，性能较差；
>  4.继承：不会被子元素继承，毕竟子类也不会渲染；
>  5.transition：transition不支持display。



### 2.visibility: hidden

使对象在网页上不可见，但该对象在网页上所占的空间没有改变，通俗来说就是看不见但摸得到。具体表现如下：

> 1.DOM结构：被渲染，但是被隐藏，会占据空间；
>  2.事件监听：无法进行DOM事件监听；
>  3.性能：动态改变此属性会引起重绘，性能较高；
>  4.继承：会被子元素继承，子元素可以通过设置visibility:visible来取消隐藏；
>  5.transition：visibility会立即显示，隐藏时会延时。



### 3.opacity: 0

与visibility: hidden相似，使对象在网页上不可见，但该对象在网页上所占的空间没有改变，但是可以进行DOM事件监听，visibility：hidden不可以，通俗来说就是看不见但是摸得着。具体表现如下：

> 1.DOM结构：透明度为100%，元素被隐藏，会占据空间；
>  2.事件监听：可以进行DOM事件监听；
>  3.性能：提升为合成层，不会引起重绘，性能较高；
>  4.继承：会被子元素继承，子元素并不能通过opacity:1来取消隐藏；
>  5.transition：opacity可以延迟显示和隐藏。



### 4.隐藏元素的其他方法

#### position

position:absolute 设置元素的position与left，top，bottom，right等，将元素移出至可视区域外，它不会影响布局，能够让元素保持可操作性，在读屏软件上可以被识别。

#### transform

transform:rotatex(90deg)或 transform:rotateY(90deg)，与opacity: 0相似，但无法进行事件监听。

#### 通过z-index隐藏







## 六、图片懒加载的原理

### 懒加载的定义

懒加载是一种设计模式，被运用在软件设计和网页设计当中，对于网页界面，其特征为用户透过鼠标，滚动浏览页面，直到页面下方时，就会自动加载更多内容。



### 懒加载的优势

1. 首先它能提升用户的体验，试想一下，如果打开页面的时候就将页面上所有的图片全部获取加载，如果图片数量较大，对于用户来说简直就是灾难，会出现卡顿现象，影响用户体验。
2. 有选择性地请求图片，这样能明显减少了服务器的压力和流量，也能够减小浏览器的负担。



### 懒加载的原理

**页面在浏览器中打开，img标签的src属性会自动请求其图片地址，实现懒加载先使用自定义属性(例:data-src)来保存图片地址，避免img的自动加载。然后js监听父元素的scroll事件，当此图片出现在可视区域后，js再把自定义src设置为图片src，实现懒加载。**



示例：

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title> LazyLoad </title>
    <style>
        #xz {
            height: 20em;
            width: 30em;
            border: 1px solid black;
            overflow: auto;
        }
        #title {
            height: 40em;
            width: 30em;
        }
        #xz:is(:hover) {
            color: red
        }
    </style>
</head>
<body>
<div id="xz">
    <p id="title">
        啦啦啦我是卖报的小行家
    </p>
    <img width="200" height="150" id="img" src="#" alt="demo" data-src="./ElasticSearch/20211101155841.jpg">
</div>
<script type="text/javascript">
    var view = document.getElementById("xz");
    var img = document.getElementById("img");

    // 真实回调Handler
    function lazyLoad() {
        if (img.getAttribute("src") == "#") {
            var clientHeight = view.clientHeight;
            var scrollTop = view.scrollTop;

            // offsetTop 表示当前元素到父级元素顶部的距离
            // clientHeight 表示元素可视区域高度
            // scrollTop 表示滚动出可视区域的高度
            if (img.offsetTop < clientHeight + scrollTop){
                    img.src = img.getAttribute("data-src");  // 属性 data-src 直接通过 .data-src 调用，-将被识别成运算符
                }
        }
    }

    // 节流函数
  	// 由于是监听scroll事件，回调回被频繁触发，增加一个节流函数。
  	// 去抖相比较节流函数要稍微简单一点，去抖是让函数延迟执行，而节流比去抖多了一个在一定时间内必须要执行一次。
    function throttle(func, delay, time) {
      let timeout;
      let starttime = new Date();

      return function() {
        // 获取this对象、入参，传递给func
        let context = this;
        let args = Array.prototype.slice.call(arguments);

        let currenttime = new Date();

        // 清除延时器
        clearTimeout(timeout);

        // 判断触发时间
        if (currenttime - starttime >= time) {
          func(context, args);
          starttime = currenttime;
        } else {
          timeout = setTimeout(function() {
            func(context, args);
          }, delay);
        }
      };
    }

    // 监听事件
    view.addEventListener("scroll", throttle(lazyLoad, 1000, 3000));
</script>
</body>
</html>
```



## 七、CSS3 增加了哪些新特性

参见W3C教程：http://home.ustc.edu.cn/~xie1993/css3/css3-backgrounds.html





## 八、浮动元素引起的问题和解决办法

### 1. 父元素高度塌陷

> 如果子元素设置了浮动，而父元素没有设置高度，则父元素不会被自动撑开

**解决办法：**

1. **给父元素设置宽高属性**

   - 缺点：
     无法自适应后面添加的元素，即后面用其他方式添加的元素也会出现父元素无法自动撑开的情况。

2. **给父元素设置 overflow：hidden**

   - 缺点：
     内容增多的时候容易造成不会自动换行导致内容被隐藏掉，无法显示要溢出的元素。

3. **内墙法: 在父元素内部最后一个浮动元素的后边添加一个块元素，并给它设置清除浮动属性 clear:both**

   > clear属性，字面意思就是清除，那么both,就是清除浮动元素对我左右两边的影响。

   - 缺点：
     1. 代码冗余，如果出现多处浮动要写多个空盒子，增加了文件的大小。
     2. 使用本方法会出现设置margin值异常，空盒子两边的margin会被无效化。

4. **用伪元素的方式给父元素后面添加一个元素并设置清除属性 clear:both**

   > 内墙法是在浮动元素的后面加一个空的 块级元素 (通常是div),并且该元素设置 clear:both； 属性。
   >
   > 那么正好在css3的属性用法中整好有个选择器也完全符合这个用法，伪元素选择器。它就像伪类一样，让伪元素添加了选择器，但不是描述特殊的状态，允许为元素的 某些部分设置样式 。
   >
   > ```css
   > p::after {
   >   /* P::after{} 一定要有 content。表示在p元素内部的最后添加内容 */
   >   content: "...";
   > }
   > ```
   >
   > 表示在p标签元素的最后面添加样式，同时这也正好符合内墙法的用法。

   伪元素注意事项：

   - 这些伪元素 要配合content属性一起使用
   - 这些伪元素 不会出现在DOM中，所以不能通过js来操作，仅仅是在 CSS 渲染层加入
   - 这些伪元素 的特效通常要使用:hover伪类样式来激活

   

   示例：

   ```html
   <!DOCTYPE html>
   <html>
   <head>
       <meta charset="UTF-8">
       <title> LazyLoad </title>
       <style>
           #xz {
               border: 1px solid black;
           }
           #title {
               height: 20em;
               width: 15em;
               float: left;
           }
           #xz:is(:hover) {
               color: red
           }
           .clearfix:after {
               content: '';  # 在父元素的最后添加一个空字符
               display: block; # 内墙法要求元素是块级，因为 行内元素会忽略掉 margin、padding 等属性。
               clear: both; # 清除浮动元素的影响，关键所在。
           }
       </style>
   </head>
   <body>
   <div id="xz" class="clearfix">
       <p id="title">
           啦啦啦我是卖报的小行家
       </p>
   </div>
   <script type="text/javascript">
   </script>
   </body>
   </html>
   ```

   

### 2. 同一行内的元素浮动属性导致布局问题

> 同一行内的多个元素，要么都设置浮动，要么都不设置。否则会导致布局错乱。

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title> LazyLoad </title>
    <style>
        .blue {
          	<-- float: left; -->
            height: 10em;
            width: 10em;
            background: blue;
        }
        .green {
            float: left;
            height: 10em;
            width: 10em;
            background: green;
        }
    </style>
</head>
<body>
<div style="height: 10em; width: 50em; border: 2px solid black;">
    <span class="blue">blue</span><span class="green">green</span>
</div>
</body>
</html>
```



## 九、CSS3中Flex Box的作用及应用场景

CSS3 弹性盒（ Flexible Box 或 flexbox），是一种当页面需要适应不同的屏幕大小以及设备类型时确保元素拥有恰当的行为的布局方式。

引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间。



### CSS3 弹性盒子内容

弹性盒子由弹性容器(Flex container)和弹性子元素(Flex item)组成。

弹性容器通过设置 display 属性的值为 flex 或 inline-flex将其定义为弹性容器。

弹性容器内包含了一个或多个弹性子元素。

**注意：** 

- 弹性容器外及弹性子元素内是正常渲染的。弹性盒子只定义了弹性子元素如何在弹性容器内布局。

- 弹性子元素通常在弹性盒子内一行显示。默认情况每个容器只有一行。

**示例：**

```html
<!DOCTYPE html>
<html>
<head>
<style>
.flex-container {
    <!-- -webkit-/-moz- 前缀表示特定浏览器前缀，-webkit-指Opera或Chrome或Safari，-moz- 指firefox -->
    display: -webkit-flex;
    display: flex;
    width: 400px;
    height: 250px;
    background-color: lightgrey;
}

.flex-item {
    background-color: cornflowerblue;
    width: 100px;
    height: 100px;
    margin: 10px;
}
</style>
</head>
<body>

<div class="flex-container">
  <div class="flex-item">flex item 1</div>
  <div class="flex-item">flex item 2</div>
  <div class="flex-item">flex item 3</div>
</div>

</body>
</html>
```

如果我们设置`body`的 `direction` 属性为 `rtl` (right-to-left),弹性子元素的排列方式也会改变，页面布局也跟着改变:

```css
body {
    direction: rtl;
}
 
.flex-container {
    display: -webkit-flex;
    display: flex;
    width: 400px;
    height: 250px;
    background-color: lightgrey;
}
 
.flex-item {
    background-color: cornflowerblue;
    width: 100px;
    height: 100px;
    margin: 10px;
}
```



### CSS3 弹性盒子属性

下表列出了在弹性盒子中常用到的属性:

教程：https://www.runoob.com/css3/css3-flexbox.html

| 属性                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [display](https://www.runoob.com/cssref/pr-class-display.html) | 指定 HTML 元素盒子类型。                                     |
| [flex-direction](https://www.runoob.com/cssref/css3-pr-flex-direction.html) | 指定了弹性容器中子元素的排列方式                             |
| [justify-content](https://www.runoob.com/cssref/css3-pr-justify-content.html) | 设置弹性盒子元素在主轴（横轴）方向上的对齐方式。             |
| [align-items](https://www.runoob.com/cssref/css3-pr-align-items.html) | 设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式。             |
| [flex-wrap](https://www.runoob.com/cssref/css3-pr-flex-wrap.html) | 设置弹性盒子的子元素超出父容器时是否换行。                   |
| [align-content](https://www.runoob.com/cssref/css3-pr-align-content.html) | 修改 flex-wrap 属性的行为，类似 align-items, 但不是设置子元素对齐，而是设置行对齐 |
| [flex-flow](https://www.runoob.com/cssref/css3-pr-flex-flow.html) | flex-direction 和 flex-wrap 的简写                           |
| [order](https://www.runoob.com/cssref/css3-pr-order.html)    | 设置弹性盒子的子元素排列顺序。                               |
| [align-self](https://www.runoob.com/cssref/css3-pr-align-self.html) | 在弹性子元素上使用。覆盖容器的 align-items 属性。            |
| [flex](https://www.runoob.com/cssref/css3-pr-flex.html)      | 设置弹性盒子的子元素如何分配空间。                           |





## 十、用伪类实现一个上三角

### **实心三角**

```html
<!DOCTYPE html>
<html>
<head>
    <style type="text/css">
  .turn_left,.turn_top {
    height: 100px;
    width: 150px;
    border-radius: 10px;
    background-color: grey;
    position: relative;
    float: left;
    margin: 50px 50px;
  }

  .turn_left:before {
    content: "";
    width: 0px;
    height: 0px;
    border-top: 10px solid transparent;
    border-bottom: 10px solid transparent;
    border-right: 10px solid red;
    position: absolute;
    top: 40px;
    left: -10px;
  }

  .turn_top:before {
    content: "";
    width: 0px;
    height: 0px;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-bottom: 10px solid red;
    position: absolute;
    top: -10px;
    left: 65px;
  }
    </style>
</head>
<body>
<div>
    <div class="turn_left"></div>
    <div class="turn_top"></div>
</div>
</body>
</html>
```



### **空心三角**

> 本质就是在实心三角的基础上，再做一个小 1px 的白色三角覆盖住实心三角。

```html
<!DOCTYPE html>
<html>
<head>
    <style type="text/css">
  .turn_top {
    height: 100px;
    width: 150px;
    border-radius: 10px;
    border: 1px solid #000000;
    position: relative;
    float: left;
    margin: 50px 50px;
  }

  .turn_top:before {
    content: "";
    width: 0px;
    height: 0px;
    border-left: 10px solid transparent;
    border-right: 10px solid transparent;
    border-bottom: 10px solid black;
    position: absolute;
    top: -10px;
    left: 65px;
  }
  .turn_top:after {
    content: "";
    width: 0px;
    height: 0px;
    border-left: 9px solid transparent;
    border-right: 9px solid transparent;
    border-bottom: 9px solid white;
    position: absolute;
    top: -9px;
    left: 66px;
  }
    </style>
</head>
<body>
<div>
    <div class="turn_top"></div>
</div>
</body>
</html>
```



### 总结

​		**三角形往哪个方向，那个方向无需设置border，而相反方向设置border颜色，相邻两边的border设为透明。**这样就可实现各个方向的三角形。实心三角形利用CSS中的伪元素（：before）实现，再利用border的transparent属性即可达到效果。而空心三角形是在空心三角形的基础上再加上伪元素（：after）实现。伪元素（：before）实现的是一个实心的三角形，伪元素（：after）实现的是空心的三角形，进而把实心的三角形覆盖，利用绝对定位的top与left的差值绝对了三角形线的粗细而达到如图的效果。





# JS类

## 一、怎么判断两个对象相等

> 两个Object类型对象，即使拥有相同属性、相同值，当使用 == 或 === 进行比较时，也不认为他们相等。这是因为他们是通过 **引用 **比较的，不像基本类型是通过 值 比较的。
>
> 所谓 引用，就是 对象 保存在内存中的地址。我们的变量就是指向这个内存地址的，当我们使用这个变量时，就是通过 变量 找到对象在内存中暴怒的地址，然后再通过内存地址取出 对象 做运算。
>
> 所以，当两个 对象 比较时，实际上就比较的是 内存中的地址，即便两个对象拥有 相同属性、相同值，内存地址也是不一样的，所以判定结果为 false。当两个变量指向同一对象时，此时两个对象比较是相等的，因为 内存地址 是一样的。

**实现对象比较方法**

```js
function deepCompareObject(x, y) {
  // 判断入参是不是都是对象
  if (typeof x !== "object" || typeof y !== "object"){
    throw new TypeError("type is required that parameter is instance of Object!");
  }

  // 指向同一对象时，返回true
  if (x === y) {
    return true
  }

  // 判断x、y的属性数量
  if (Object.keys(x).length != Object.keys(y).length) {
    return false
  }

  // 取出对象x中的所有属性的值，依次和y中的值比较
  for (let prop in x) {
    if (y.hasOwnProperty(prop)) {
      if (typeof x[prop] === "object") {
        if (typeof y[prop] !== "object" || !deepCompareObject(x[prop], y[prop])) {
          return false
        }
      }else if (x[prop] !== y[prop]){
        return false
      }
    }else{
      return false
    }
  }
  return true
};
```



## 二、数组相关的操作方法

### 创建数组

- 方法一：通过`new`运算符创建一个数组构造函数。

```js
var arr = new Array();
```

- 方法二：通过方括号直接创建直接量数组。

```js
var arr = [1,2,3];
```



### 数组赋值

- 方法一：通过下标添加元素。

```js
var arr = new Array();
arr[0] = 'kwan';
arr[1] = 18;
```

- 方法二：通过`array`的`push`方法来添加。



### 基础函数

#### 1. join()

功能：将数组中所有元素都转化为字符串并连接在一起。原数组不改变，返回拼接后的字符串

入参：传入 string 类型的链接字符

```js
    var a = ["a", "b", "c", "d", "ee"]
    var b = a.join("") // 分隔符 ""
```



#### 2.  reverse()

功能：将数组中的元素颠倒顺序。就地修改，同时也将修改后的数组返回

```js
    var a = ["a", "b", "c", "d", "ee"]
    a.reverse()
```



#### 3. concat()

功能：数组拼接的功能 ，返回新数组，原数组不受影响。

```js
    var a = ["a", "b", "c", "d", "ee"]
    var b = [1, 2, 3]
    var c = a.concat(b)
```



#### 4.slice()

截取数组生成新数组，原数组不受影响。

**返回的数组包含第一个参数指定的位置，但不含第二个参数指定位置之间的所有元素。**

**如果为负数，表示相对于数组中最后一个元素的位置。例如：-1 表示数组最后一个元素；-2 表示数组倒数第二个元素。**

**如果只有一个参数，表示从参数位置开始一直取到数组末尾。**

```js
var aa = [1,2,3,4,5,6];
console.log(aa.slice(2)); //[3,4,5,6]
console.log(aa.slice(2,8)); //[3,4,5,6] 超过最大长度，只显示到最后结果
console.log(aa.slice(2,5)); //[3,4,5]
console.log(aa.slice(2,-1)); //[3,4,5] 相对于倒数第一个之前
console.log(aa.slice(2,-2)); //[3,4] 相对于倒数第二个之前
console.log(aa.slice(3)); //[4,5,6] 一个参数从第三个到最后
console.log(aa.slice(-2));//[5,6] 一个参数负值从倒数第二个到最后
```



#### 5. splice()

功能：从数组中删除元素、插入元素 或者同时完成这两种操作。

输入：第一个参数为指定插入或删除的起始位置，第二个参数为要删除的个数。之后的参数表示需要插入到数组中的元素 。如果只有一个参数，默认删除参数后边的所有元素。

输出：返回一个由删除元素组成的数组。

 注意：新建了一个数组，并修改了原数组。

```js
var aa = [1,2,3,4,5,6];
console.log(aa.splice(4)); //[5,6]  返回删除后的数组。起始位置包含在删除元素中
aa; // [1,2,3,4]
console.log(aa.splice(2,2)); //[3,4] 从第二位起删除两个元素
aa; //[1,2]
console.log(aa.splice(1,0,7,8)); //[]从第一位起删除0个元素，添加7,8到原数组。原来位置的元素往后迁移
aa;//[1,7,8,2]
```



#### 6. push()

在数组末尾添加一个或多个元素，并返回新数组长度。

```js
    var a = ["a", "b", "c", "d", "ee"]
    var count = a.push("new_one", "new_two")
    console.log(count) // 7
    console.log(a) // ["a", "b", "c", "d", "ee", "new_one", "new_two"]
```



#### 7. pop()

从数组末尾删除1个元素(删且只删除1个), 并返回 被删除的元素。



#### 8. shift()

在数组开始添加一个或多个元素，并返回新数组长度。



#### 9. unshift()

在数组开始删除一个元素(删且只删除1个),并返回 被删除的元素



#### 10. toString()和toLocaleString()

将数组的每个元素转化为字符串，并且返回用逗号分隔的字符串列表。功能类似join()。

```js
    var a = ["a", "b", "c", "d", "ee"]
    var b = a.toString()
    var c = a.toLocaleString()
    console.log(typeof b) //string
    console.log(typeof c) //string
    console.log(b) // a,b,c,d,ee
```



#### 11. indexOf()和lastIndexOf()

**indexOf: **从数组的开头（位置 0）开始向后查找。返回查找项的索引值，没找到返回-1。
**lastIndexOf:** 从数组的末尾开始向前查找。返回查找项的索引值(索引值永远是正序的索引值)，没找到返回-1。

参数：要查找的项 和（可选的）表示查找起点位置的索引。



### 高阶函数

#### 1. sort()

默认情况下sort()方法没有传比较函数的话，默认按字母升序，如果不是元素不是字符串的话，会调用toString()方法将元素转化为字符串的Unicode(万国码)位点，然后再比较字符。所以用默认方法排序 数值 是有问题的。

sort 方法是就地排序，修改原数组。同时将修改后的原数组返回。

```js
var a = [1, 2, 5, 16, 11, 8, 10, 13]
a.sort()
console.log(a)  // [1, 10, 11, 13, 16, 2, 5, 8]

a.sort((a, b) => {
  return a-b; // 升序
})

a.sort((a, b) => {
  return b-a; // 降序
})
```



#### 2. forEach()

从头至尾遍历数组，为每个元素回调指定函数。
传入一个回调函数，回调函数时为其传入三个参数：数组元素、元素的索引、数组本身。

```js
var a = [1, 2, 5, 16]
a.forEach((item, index, array) => {
  console.log(item);
  console.log(index);
  console.log(array);
})
```



#### 3. map()

调用的数组的遍历每一个元素传递给指定的回调函数，并返回一个新数组 ，不修改原数组。

```js
var arr = [2,3,4,5,6];
var bb= arr.map(function(x){
  return x*x;
});
console.log(bb); // [4, 9, 16, 25, 36]
```



#### 4. filter()

过滤功能，数组中的每一项回调给定函数，返回满足过滤条件组成的数组。

```js
var a = [1,2,3,4,5,6,3,1];
a.filter(function(v,i,self){
  return self.indexOf(v) == i;
});
//[1, 2, 3, 4, 5, 6]
```



#### 5. every()和some()

every() 判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。
some() 判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。

```js
var arr = [1, 2, 3, 4, 5, 6];
arr.every(x=>x>0);//return true;
arr.every(x=>x>5);//return false;
arr.some(x=>x>5);//return true;
```



#### 6. reduce()和reduceRight()

reduce() 两个参数：函数和递归的初始值。从数组的第一项开始，逐个遍历到最后。
reduceRight() 从数组的最后一项开始，向前遍历到第一项。

```js
//可以用reduce快速求数组之和
var arr=[1,2,3,4];
arr.reduce(function(a,b){
  return a+b;
}); //10
```



## 三、JS中常见的DOM操作API

### DOM

D（document）O（object）M（model） 文档对象模型。

> DOM（文档对象模型）是HTML和XML文档的编程接口。它提供了对文档的结构化的表述，并定义一种方式可以使从程序中对该结构进行访问，从而改变文档的结构、样式和内容。DOM将文档解析为一个由节点和对象（包含属性和方法的对象）组成的结构集合。

DOM就是一种想象的树形结构，它的作用是将网页转为一个 JavaScript 对象，从而可以用脚本进行各种操作（比如增删内容）。



### NODE

DOM 的最小组成单位叫做节点（node）。文档的树形结构（DOM 树），就是由各种不同类型的节点组成。

节点主要有7种类型：

- `Document`：整个文档树的根节点
- `Document`：doctype标签节点，如`<!DOCTYPE html>`
- `Element`：网页的各种`Html`标签，比如`<body><div>`等
- `Attribute`：网页元素的属性
- `Text`：标签之间或者标签包含的文本
- `Comment`：注释
- `DocunmentFragment`：文档的片段



**DOM树有3种层级结构：**

- 父节点关系（parentNode）：直接的上级节点
- 子节点关系(childNodes)：直接的下级节点
- 兄弟关系(sibling)：拥有同一个父节点的同级节点



### Node API

#### 属性

##### Node.prototype.nodeType

> `nodeType`属性返回一个整数值，表示节点的类型。

数值和结点类型的映射关系：

`Node.ELEMENT_NODE`：1

`Node.ATTRIBUTE_NODE`：2

`Node.TEXT_NODE`：3

`Node.COMMENT_NODE`：8

`Node.DOCUMENT_NODE`：9

`Node.DOCUMENT_TYPE_NODE`：10

`Node.DOCUMENT_FRAGMENT_NODE`：11



##### Node.prototype.nodeName

> `nodeName`属性返回节点名称

注：在元素节点中，返回名称基本都是大写，只有`<svg>`标签返回的是小写。



##### Node.prototype.nodeValue

> `nodeValue`属性返回一个字符串，表示当前节点本身的文本值，该属性可读写。

只有文本节点（text）、注释节点（comment）和属性节点（attr）有文本值，因此这三类节点的`nodeValue`可以返回结果，其他类型的节点一律返回`null`。



##### Node.prototype.textContent

> `textContent`返回节点及后代节点的文本 ，即获取文本。

这里和`innerText`一起讲：

早期并没有获取文本的API ，导致编码很繁琐，所以后来IE自己添加了一个API就是`innerText`，然后火狐和opera也推出了`textContent`

两者的区别：

- `textContent`会获取所有元素的内容，包括`<script>`和`<style>`元素，然而`innerText`不会获取这些内容。
- `innerText`可以意识到样式，它不会返回样式为`display:none`也就是隐藏的文本，而`textContent`会。
- 由于`innerText`会意识到样式，也就是会受样式的影响，因此会触发重排（reflow)导致性能低，而`textContent`不会。
- 与`textContent`不同， 在 Internet Explorer (对于小于等于 IE11 的版本) 中对`innerText`进行修改， 不仅会移除当前元素的子节点，而且还会永久性地破坏所有后代文本节点（所以不可能将节点再次插入到任何其他元素或同一元素中)。



##### Node.prototype.nextSibling

> `Node.nextSibling`属性返回紧跟在当前节点后面的第一个同级节点。如果当前节点后面没有同级节点，则返回`null`。

值得注意的是，该属性还包括文本节点和注释节点（``）。因此如果当前节点后面有空格或者回车，该属性会返回一个文本节点，内容为空格或回车。

`document.body.nextSibling`返回了文本节点或者注释节点，而我们需要获得是元素节点， 也可以用`document.prototype.nextElementSibling`直接获取该节点后面最接近的同级元素节点。



##### Node.prototype.previousSibling

> `previousSibling`属性返回当前节点前面的、距离最近的一个同级节点。如果当前节点前面没有同级节点，则返回`null`。

`Node.prototype.previousElementSibling` 前一个同级元素节点。



##### Node.prototype.firstChild，Node.prototype.firstElementChild

> `firstChild`属性返回当前节点的第一个子节点，如果当前节点没有子节点，则返回`null`。
> `firstElementChild`属性返回当前节点的第一个元素节点。



##### Node.prototype.lastChild，Node.prototype.lastElementChild

> `lastChild`属性返回当前节点的最后一个子节点，如果当前节点没有子节点，则返回`null`。
> `lastElementChild`属性返回当前节点的最后一个元素节点。



##### Node.prototype.childNodes

> `childNodes`属性返回一个**类似数组**的对象（`NodeList`集合），成员包括当前节点的所有子节点。

值得注意的是，除了元素节点，`childNodes`属性的返回值还包括文本节点和注释节点。如果当前节点不包括任何子节点，则返回一个空的`NodeList`集合。由于`NodeList`对象是一个动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。



##### Node.prototype.children

> `children`属性返回一个类似数组的对象（HTMLCollection）,成员包括当前节点的所有子元素节点。

值得注意的是，这里就不会返回文本节点和注释节点了，它只会返回元素节点。由于`HTMLCollection`集合是动态集合，一旦子节点发生变化，立刻会反映在返回结果之中。

小tips : `Nodelist` 和 `HTMLCollection` 集合的区别

1. `NodeList`可以包含各种类型的节点，`HTMLCollection`只能包含 HTML 元素节点.
2. `NodeList` 实例可能是动态集合，也可能是静态集合。目前，只有`Node.childNodes`返回的是一个动态集合，其他的`NodeList` 都是静态集合。而`HTMLCollection`实例都是动态集合，节点的变化会实时反映在集合中.
3. 与`NodeList`接口不同，`HTMLCollection`没有`forEach`方法，只能使用`for`循环遍历。



#### 方法

##### Node.prototype.appendChild()

> `appendChild`方法就是接受一个节点对象作为参数，将其作为最后一个子节点，插入到当前节点 。该方法的返回值就是插入的子节点。

注意：

1. 如果参数节点是 DOM已经存在的节点，`appendChild`方法会将其从原来的位置移动到新位置。

2. 如果`appendChild`方法的参数是`DocumentFragment`节点，那么插入的是`DocumentFragment`的所有子节点，而不是`DocumentFragment`节点本身。返回值是一个空的`DocumentFragment` 。



##### Node.prototype.hasChildNodes()

> `hasChildNodes`方法返回一个布尔值，表示当前节点是否有子节点。

注意：子节点包括所有类型的节点，并不仅仅是元素节点。哪怕节点只包含一个空格，`hasChildNodes`方法也会返回`true`

判断一个节点是否有子节点，有以下3种方法：

1、node.hasChildNodes()

2、node.firstChild ! == null

3、node.childNodes && node.childNodes.length > 0



##### Node.prototype.cloneNode()

> `cloneNode`方法拷贝一个节点，并且可以接受一个布尔值，来表示是否同时拷贝子节点。它的返回值是一个克隆出来的新节点。

深拷贝：深入进去全部拷贝，包括子节点。

浅拷贝：只拷贝节点本身。

值得注意的是，该方法返回的节点不在文档中，无任何父节点，必须用如`appendChild()`等方法添加。



##### Node.prototype.insertBefore()

> `insertBefore`方法用于将某个节点插入父节点内部的指定位置。

`insertBefore`方法接受两个参数，第一个参数是所要插入的节点`newNode`，第二个参数是父节点`parentNode`内部的一个子节点`referenceNode`。`newNode`将插在`referenceNode`这个子节点的前面。返回值是插入的新节点`newNode`。



##### Node.prototype.removeChild()

> `removeChild`方法接受一个子节点作为参数，用于从当前节点移除该子节点。返回值是移除的子节点。

值得注意的是，被移除的节点依然存在于内存之中，但不再是DOM的一部分。所以，一个节点移除以后，依然可以使用它，比如插入到另一个节点下面。

如果参数节点不是当前节点的子节点，`removeChild`方法将报错。



##### Node.prototype.replaceChild()

> `replaceChild`方法用于将一个新的节点，替换当前节点的某一个子节点。



##### Node.prototype.contains()

> `contains`方法返回一个布尔值，表示参数节点是否为该节点的后代节点。



#####  Node.prototype.isEqualNode()，Node.prototype.isSameNode()

> `isEqualNode`方法返回一个布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。
>  `isSameNode`方法返回一个布尔值，表示两个节点是否为同一个节点。

所以说，`isSameNode`就等同于 `===`严格相等运算符。



##### Node.prototype.normalize()

> `normailize`方法用于清理当前节点内部的所有文本节点（text）。它会去除空的文本节点，并且将毗邻的文本节点合并成一个，也就是说不存在空的文本节点，以及毗邻的文本节点



### Document API

`document`节点对象代表整个文档，每张网页都有自己的`document`对象。`window.document`属性就指向这个对象。只要浏览器开始载入 HTML 文档，该对象就存在了，可以直接使用。

`document`对象有不同的办法可以获取。

#### 属性

1.1 用于指向其他节点(快捷获取某些特殊节点)的属性

- `document.doctype` 指向`<DOCTYPE>`节点，即文档类型节点。
- `document.documentElement`指向 DOM 的 `html`节点
- `document.activeElement`指向获得焦点的那个节点
- `document.fullscreenElement`返回当前以全屏状态展示的 DOM 元素。
- `document.body`指向`<body>`节点
- `document.head`指向`<head>`节点。
- `document.scrollingElement`返回文档的滚动元素。



1.2 返回文档特定元素的伪数组集合的属性

- `document.links`属性返回当前文档所有设定了`href`属性的`<a>`及`<area>`节点。
- `document.forms`属性返回所有`<form>`表单节点。
- `document.images`属性返回页面所有`<img>`图片节点。
- `document.scripts`属性返回所有`<script>`节点。
- `document.styleSheets`属性返回文档内嵌或引入的样式表集合

以上均为动态集合，而且除了`document.styleSheets`，以上的集合属性返回的都是`HTMLCollection`实例。



1.3 返回文档信息的属性

- `document.documentURI和document.URL`属性都返回一个字符串，表示当前文档的网址。
- `document.domain`属性返回当前文档的域名，不包含协议和接口。
- `document.Location`对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。
- `document.title`属性返回当前文档的标题。
- `document.characterSet`属性返回当前文档的编码，比如`UTF-8`
- `document.referrer`属性返回一个字符串，表示当前文档的访问者来自哪里



1.4 返回文档状态的属性

- `document.hidden`属性返回一个布尔值，表示当前页面是否可见。

- `document.visibilityState`返回文档的可见状态。

  

#### 方法

- `document.open`方法清除当前文档所有内容，使得文档处于可写状态，供`document.write`方法写入内容。
- `document.close`方法用来关闭`document.open()`打开的文档。
- `document.write`方法用于向当前文档写入内容。
- `document.writeln`方法与`write`方法完全一致，除了会在输出内容的尾部添加换行符。
- `document.querySelector`接受一个 CSS 选择器作为参数，返回匹配该选择器的元素节点。
- `document.querySelectorAll`方法与`querySelector`用法类似，区别是返回一个`NodeList`对象，包含所有匹配给定选择器的节点。
- `document.getElementsByTagName`搜索 HTML 标签名，返回符合条件的元素。
- `document.getElementsByClassName` 返回一个类似数组的对象（`HTMLCollection`实例），包括了所有`class`名字符合指定条件的元素，元素的变化实时反映在返回结果中。
- `document.getElementsByName`方法用于选择拥有`name`属性的 HTML 元素，返回一个类似数组的的对象（`NodeList`实例）.
- `document.getElementById`方法返回匹配指定`id`属性的元素节点
- `document.createElement`方法用来生成元素节点，并返回该节点。
- `document.createTextNode`方法用来生成文本节点（`Text`实例）。
- `document.createDocumentFragment`方法生成一个空的文档片段对象（`DocumentFragment`实例）。
- `document.hasFocus`方法返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。



### Element API

#### 属性

- `Element.id`属性返回指定元素的`id`属性，该属性可读写。
- `Element.tagName`属性返回指定元素的大写标签名
- `Element.title`属性用来读写当前元素的 HTML 属性`title`
- `Element.attributes`属性返回一个类似数组的对象，成员是当前元素节点的所有属性节点
- `Element.className`属性用来读写当前元素节点的`class`属性。
- `Element.classList`返回一个伪数组，成员是当前元素节点的每个`class`。
- `Element.innerHTML`属性返回一个字符串，等同于该元素包含的所有 HTML 代码。
- `Element.clientHeight`属性返回一个整数值，表示元素的可见高度，即 内容 + padding。
- `Element.offsetHeight`属性返回一个整数值，表示元素的像素高度，即 可见高度 + border = 内容 + padding + border。
- `Element.clientWidth`属性返回元素节点的可见宽度，同样只对块级元素。
- `Element.scrollHeight`属性返回一个整数值（小数会四舍五入），表示当前元素的总高度（单位像素），包括溢出容器、当前不可见的部分。
- `Element.scrollTop` 返回元素上边缘与视图之间的距离，即滚出可见区域的高度。
- `Element.offsetTop` 返回元素相对父元素垂直偏移位置，即当前元素到父元素上边缘的高度。
- `Element.scrollWidth`属性表示当前元素的总宽度（单位像素），其他地方都与`scrollHeight`属性类似。
- `Element.children`属性返回一个类似数组的对象（`HTMLCollection`实例），包括当前元素节点的所有子元素。
- `Element.childElementCount`属性返回当前元素节点包含的子元素节点的个数，与`Element.children.length`的值相同。



#### 方法

- `getAttribute()`读取某个属性的值
- `getAttributeNames()`返回当前元素的所有属性名
- `setAttribute()`写入属性值
- `hasAttribute()`某个属性是否存在
- `hasAttributes()`当前元素是否有属性
- `removeAttribute()`删除属性
- `Element.querySelector`接受 CSS 选择器作为参数，返回父元素的第一个匹配的子元素。
- `Element.querySelectorAll`接受 CSS 选择器作为参数，返回一个`NodeList`实例，包含所有匹配的子元素。
- `Element.remove`方法继承自 ChildNode 接口，用于将当前元素节点从它的父节点移除。
- `Element.getBoundingClientRect`方法返回一个对象，提供当前元素节点的大小、位置等信息，基本上就是 CSS 盒状模型的所有信息
- `Element.addEventListener()`：添加事件的回调函数
- `Element.removeEventListener()`：移除事件监听函数
- `Element.dispatchEvent()`：触发事件





## 四、什么是闭包



## 五、解释事件冒泡和事件捕获



## 六、JS如何实现重载和多态



## 七、深拷贝的原理是什么



## 八、JS中实现继承的方式



## 九、深入理解this关键字



## 十、call、applay、bind的区别



# Vue类

## 一、vue中computed和watch的区别



## 二、深入理解vue中的插槽



## 三、vue中路由的使用步骤



## 四、vue的生命周期



## 五、深入理解 MVC、MVVM



## 六、vue双向绑定的原理



## 七、vue实现父组件向子组件传递数据



## 八、vue中如何自定义一个过滤器



## 九、如何开发一个vue插件



## 十、vue中如何实现给样式添加作用域，其实现原理是什么


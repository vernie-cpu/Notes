### 一、内存溢出和内存泄漏

**内存溢出 out of memory :**

​		指程序要求的内存超出了系统所能分配的范围，出现out of memory；比如申请一个int类型，但给了它一个long才能存放的数，就会出现内存溢出，或者是创建一个大的对象，而堆内存放不下这个对象，这也是内存溢出。

**内存泄露 memory leak :**

​		是指程序在申请内存后，无法释放已申请的内存空间(<font color='red'>指分配出去的内存无法被gc回收</font>)。一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。

　　以上可以推断出内存泄露可能会导致内存溢出。内存溢出会抛出**OOM**异常，内存泄露不会抛出异常，此时程序看起来是正常运行的。



### 二、服务器性能指标

#### **1、CPU**

- **CPU占用率**：即cpu的使用率，单核cpu通常临界点在50%，70%，90%。

  - < 50%：认为cpu工作状态正常。
  - 50%～70%：认为cpu工作状态饱和。
  - 70%～90%：认为cpu工作状态繁忙。通常在大于70%时，就开始预警。
  - \>90%：认为cpu处于性能瓶颈。
  - 以上分析以单核为例。如果是多核，需要按空闲率倒过来算，比如 双核、空闲率保证 30%，那么 cpu 的实际使用率是170%。

- **CPU队列：**

  - **CPU的运行队列统计**:在Linux里，一个进程，对于线程来说要不在运行，要不在阻塞。一个阻塞的进程可能是在等着一些io的数据处理，或者等待一些系统的调用。当这些进程是运行状态，等待CPU处理的任务数就叫运行队列。任务越多队列越长，运行队列越长表示我的压力机就越大。

  - top 命令打印结果中的 load average 就表示cpu的队列信息。

    ``` shell
    [root@VM-0-10-centos ~]# top
    top - 15:18:44 up 1 day, 21:54,  1 user,  load average: 0.00, 0.01, 0.05 # 只复制了第一行
    
    # 说明：
    # 0.00 过去一分钟系统的平均负载
    # 0.01 过去五分钟系统的平均负载
    # 0.05 过去十五分钟系统的平均负载
    
    # 系统忙不忙的判断标准：
    # 统计值 <= cpu 核数，表示不忙
    # 统计值 介于 cpu核数 和 cpu核数*3 之间，不确定
    # 统计值 大于 cpu核数*3 ，表示繁忙
    ```

- **CPU中断：**

  - 中断是系统响应硬件设备请求的一种机制，它会打断进程的正常调度和执行，然后调用内核中的中断处理程序来响应设备的请求。

    - 硬中断：由与系统相连的外设(比如网卡、硬盘)自动产生的。主要是用来通知操作系统系统外设状态的变化。比如当网卡收到数据包的时候，就会发出一个中断。我们通常所说的中断指的是硬中断(hardirq)。

    - 软中断：由软中断指令产生。为了满足实时系统的要求，中断处理应该是越快越好。linux为了实现这个特点，当中断发生的时候，硬中断处理那些短时间就可以完成的工作，而将那些处理事件比较长的工作，放到中断之后来完成，也就是软中断(softirq)来完成。

    - 中断嵌套：Linux下硬中断是可以嵌套的，但是没有优先级的概念，也就是说任何一个新的中断都可以打断正在执行的中断，但同种中断除外。软中断不能嵌套，但相同类型的软中断可以在不同CPU上并行执行。

    - 软中断指令：int是软中断指令。中断向量表是中断号和中断处理函数地址的对应表。int n - 触发软中断n。相应的中断处理函数的地址为：中断向量表地址 + 4 * n。

      ``` shell
      [root@VM-0-10-centos ~]# top
      top - 15:41:25 up 1 day, 22:17,  1 user,  load average: 0.29, 0.18, 0.11
      Tasks: 113 total,   1 running, 112 sleeping,   0 stopped,   0 zombie
      %Cpu(s):  0.3 us,  0.7 sy,  0.0 ni, 99.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
      
      # 说明：
      # 0.3% us — 用户空间占用CPU的百分比。
      # 0.7% sy — 内核空间占用CPU的百分比。
      # 0.0% ni — 改变过优先级的进程占用CPU的百分比
      # 99.0% id — 空闲CPU百分比
      # 0.0% wa — IO等待占用CPU的百分比
      # 0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比
      # 0.0% si — 软中断（Software Interrupts）占用CPU的百分比
      ```

- **CPU上下文切换：**<font style="color:red">一般上下文切换在数百到一万之内，上下文切换超过1万，很可能遇到性能问题。</font>

  - Linux 是一个多任务的操作系统，它支持远大于CPU数量的任务同时运行，当然并不是真正的同时运行，是每个任务轮流执行CPU分给他们的时间片，让人感觉是同时在运行。

  - 每一个任务运行前，CPU都需要知道任务从哪里加载，又从哪里运行，也就是说，需要系统事先设置好CPU寄存器。

  - CPU寄存器包含指令寄存器(IR)和程序计数器(PC)。他们用来暂存指令，数据和地址，程序运行的下一条指令地址，这些都是任务运行时的必要环境。因此也被称作**CPU上下文**。

  - 上下文切换就是把前一个任务的CPU上下文保存起来，然后加载新任务的上下文到这些指令寄存器(IR)和程序寄存器(PC)等寄存器中。这些被保存下来的上下文会存储在操作系统的内核空间中，等待任务重新调度执行时再次加载进来，这样就能保证任务的原来状态不受影响，让任务看起来是连续运行的。

  - CPU的上下文切换又分为进程上下文切换，线程上下文切换以及中断上下文切换。过多的上下文切换也是导致CPU出现性能瓶颈的原因。

    ``` shell
    [root@VM-0-10-centos ~]# vmstat
    procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
     r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
     3  0      0  84592  11812 193752    0    0    80    26   32  118  1  1 98  0  0
     
    # cs (centext switch) 每秒的上下文切换次数
    # in (interrupt) 每秒的中断次数
    # r (Runing or Runnable) 就绪队列的长度，也就是正在运行和等待CPU的进程数。
    # b (Blocked) 阻塞状态的进程数
    
    # pidstat 可以看到具体的某个应用程序的上下文切换情况
    [root@VM-0-10-centos ~]# pidstat -w 1
    Linux 3.10.0-1127.19.1.el7.x86_64 (VM-0-10-centos) 	2021年09月27日 	_x86_64_	(1 CPU)
    
    16时18分23秒   UID       PID   cswch/s nvcswch/s  Command
    16时18分24秒     0         6      1.98      0.00  ksoftirqd/0
    16时18分24秒     0         9     45.54      0.00  rcu_sched
    16时18分24秒     0      1243      0.99      0.00  pidstat
    16时18分24秒     0      1376      0.99      0.00  YDLive
    16时18分24秒     0      1424      0.99      0.00  barad_agent
    16时18分24秒     0     12195      0.99      0.00  tini
    16时18分24秒     0     18845      8.91      0.00  kworker/0:3
    16时18分24秒     0     25375      0.99      0.00  sshd
    16时18分24秒   999     26595     13.86      0.00  redis-server
    16时18分24秒     0     27269      0.99      0.00  uwsgi
    16时18分24秒     0     27270      6.93      0.00  celery
    
    # cswch (voluntary context switches) 自愿上下文切换，指的是进程无法获得所需的资源导致的上下文切换。比如I/O不足，内存不足。
    # nvcswch (non voluntary context switches) 非自愿上下文切换，指的是 进程由于时间片已到等原因，被系统强制调度，进而发生上下文切换。
    ```

    

#### **2、内存**

> 内存是计算机中重要的部件之一，它是与CPU进行沟通的桥梁。计算机中所有程序的运行都是在内存中进行的，因此内存的性能对计算机的影响非常大。
> 内存(Memory)也被称为内存储器，其作用是用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据。

- **物理内存** 指通过物理内存条而获得的内存空间。即随机存取存储器（random access memory，RAM），是与CPU直接交换数据的内部存储器，也叫主存(内存)。
- **虚拟内存** 是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。
- **Swap分区** 在系统的物理内存不够用的时候，把硬盘内存中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的硬盘空间就是swap分区，通常用来临时保存一些不活跃的运行程序，当需要运行时，再从swap读到内存中去。

``` shell
[root@VM-0-10-centos ~]# free -m   # 以M为单位显示结果
              total        used        free      shared  buff/cache   available
Mem:           1837        1554          74           1         208         134
Swap:             0           0           0

# total: 所有物理内存
# used: 已被分配的内存，包含了 buff/cache。
# free: 未被分配的内存，真实的剩余物理内存。
# shared: 共享内存。基本用不到。
# buff/cache: 缓冲/缓存。缓冲：内存->磁盘；缓存：磁盘->内存。目的都是减少IO次数，提高IO性能。
# available: 还能被应用程序分配的内存，其中包含了一些buff/cache内存空间。
```

``` shell
[root@VM-0-10-centos ~]# top  # 持续统计CPU和内存信息
top - 17:19:36 up 1 day, 23:55,  1 user,  load average: 0.06, 0.09, 0.07
Tasks: 113 total,   1 running, 112 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.0 us,  1.0 sy,  0.0 ni, 97.7 id,  0.3 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  1882016 total,    81996 free,  1592476 used,   207544 buff/cache  
KiB Swap:        0 total,        0 free,        0 used.   136492 avail Mem
```




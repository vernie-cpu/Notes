"""
把列表按步长h分为两个元素为一组的序列，并对每组记录采用直接插入排序方法进行排序。
随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录，则完成排序。

示例:
    a = [11, 22, 17, 23, 14, 3, 9]
    h = 2
    那么分组就是:(11, 17, 14, 9), (22, 23, 3)
"""

a = [6, 4, 2, 1, 7, 5, 10, 22, 17, 23, 14, 3, 9, 16, 27, 33, 31, 22, 13, 6, 7]
h = 0

# 确认步长初始值，即最大的步长
while h < len(a) / 2:
    h = 2 * h + 1

# 循环条件是步长大于等于 1。每一次布长的循环，都会使按当前步长划分出的各个分组内部有序
while h >= 1:
    # 外层循环初值就是步长，取到序列结束。这个过程中，只要 步长 不是 1，那么 每下一次 循环，都会切换一个分组
    for i in range(h, len(a)):
        # 内层循环，就是把当前分组的 无序部分 的第一个值，插入到 当前分组的 有序部分 的合适的位置。分组内部的逻辑，就是插入排序的逻辑
        # 内层循环的 初值 就是 i，此时的 i 就是当前分组 无序部分的 第一个值。因为 插入排序 默认 第一个元素是有序的
        for k in range(i, h - 1, -h):
            # 判断逻辑就跟 插入排序 一样了
            if a[k - h] <= a[k]:
                break
            a[k - h], a[k] = a[k], a[k - h]

    # 减小步长
    h = int(h / 2)

print(a)

'''
希尔排序的时间的时间复杂度为O(n^1.5)，希尔排序时间复杂度的下界是n*log2n。
希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。但是比O(n^2)复杂度的算法快得多。
'''

'''
把列表按步长h分为两个元素为一组的序列，并对每组记录采用直接插入排序方法进行排序。
随着步长逐渐减小，所分成的组包含的记录越来越多，当步长的值减小到 1 时，整个数据合成为一组，构成一组有序记录，则完成排序。

示例:
    a = [11, 22, 17, 23, 14, 3, 9]
    h = 2
    那么分组就是:(11, 17, 14, 9), (22, 23, 3)
'''

a = [6, 4, 2, 1, 7, 5, 10, 22, 17, 23, 14, 3, 9, 16, 27, 33, 31, 22, 13, 6, 7]


# 确认步长初始值，即最大的步长
# h = int(len(a)/2)
h = 1

while (h < len(a) / 2):
    h = 2 * h + 1

while (h >= 1):
    # 外层循环：找到待插入的值
    for i in range(h, len(a)):
        # 内层循环：把待插入的值插入到合适的位置，即对分组进行插入排序
        for k in range(i, h - 1, -h):
            # 判断是否进行插入
            if a[k - h] <= a[k]:
                break
            a[k], a[k - h] = a[k - h], a[k]

    # 减小步长
    h = int(h / 2)

print(a)

'''
希尔排序的时间的时间复杂度为O(n^1.5)，希尔排序时间复杂度的下界是n*log2n。
希尔排序没有快速排序算法快 O(n(logn))，因此中等大小规模表现良好，对规模非常大的数据排序不是最优选择。但是比O(n^2)复杂度的算法快得多。
'''
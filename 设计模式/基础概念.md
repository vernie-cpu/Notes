**面向对象三大特性**
- 封装
- 继承
- 多态: python中没有重载，但可以用overloads模块中的装饰器@overloads来实现

**接口**

- 定义：若干抽象方法的集合。

- 作用：限制实现接口的类必须按照接口给定的调用方式实现这些方法；对高层模块隐藏了类的内部实现。

- 示例：
    ``` python
    from abc import ABCMeta, abstractmethod
    
    class Payment(metaclass=ABCMeta):
        """
        抽象类
        """
    
        # abc = abstract class
        # 抽象类：内部有抽象方法的类
        # 抽象方法：规定了一个方法的名称和入参。继承了抽象类的所有子类都必须实现该抽象方法，规范了所有子类同一方法的实现方式
        @abstractmethod
        def pay(self, money):
            pass
          
    class AliPay(Payment):
        def pay(self, money):
            print("支付宝支付：%s元" % money)
            
    class WechatPay(Payment):
        def pay(self, money):
            print("微信支付：%s元" % money)
            
    if __name__ == '__main__':
        pay = AliPay()
        # pay = WechatPay()
        
        # 因为两个支付类都继承了同一个支付基类，所以都实现了同一个pay支付方法
        # 所以即便调用的实例不同，但调用的函数、入参都是相同的，这就是接口存在的意义
        pay.pay(100)        
    ```
    
    

**面向对象设计SOLID原则**
- 开放封闭原则：一个软件实体 如类、模块和函数应该对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。
- 里氏替换原则：所有引用父类对象的地方必须能够透明的使用其子类对象。即在调用一个父类对象的地方，传入其子类对象，同样可以实现相同的功能。
- 依赖倒置原则：高层模块(调用方)不应该依赖低层模块，二者都应该依赖其抽象对象；抽象不应该依赖细节；细节应该依赖抽象。换言之，要针对接口编程，而不是针对实现编程。
- 接口隔离原则：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些他不需要的接口。
- 单一职责原则：不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。

**创建型模式：**
> 在创建对象的时候使用的模式
- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式
- 建造者模式
- 单例模式
- 原型模式：几乎用不到

**结构型模式：**
- 适配器模式
- 桥模式
- 组合模式
- 装饰模式
- 外观模式
- 享元模式
- 代理模式

**行为型模式：**
- 解释器模式
- 责任链模式
- 命令模式
- 迭代器模式
- 中介者模式
- 备忘录模式
- 观察者模式
- 状态模式
- 策略模式
- 访问者模式
- 模版方法模式